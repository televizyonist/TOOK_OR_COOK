<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PENÇE HAREKATI</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --ui-font-size-large: clamp(1.5em, 3vw, 2em);
            --ui-font-size-medium: clamp(1.1em, 2.2vw, 1.5em);
            --ui-font-size-base: clamp(0.9em, 1.8vw, 1em);
            --ui-font-size-small: clamp(0.7em, 1.5vw, 0.8em);
            --crt-glow: 0 0 5px #00ff88, 0 0 10px #00ff88, 0 0 15px #00ff88;
            --crt-color: #00ff88;
            --bar-bg: rgba(10, 30, 10, 0.5);
            --dashboard-bg-start: #05140a;
            --dashboard-bg-end: #102a16;
            --dashboard-border: #002a0f;
            --info-display-bg: #1a2a1a;
            --info-display-border: #3c5a3c;
            --shield-color: #00aaff;
            --shield-glow: 0 0 5px #00aaff, 0 0 10px #00aaff, 0 0 15px #00aaff;
        }

        body {
            background-color: #000;
            color: #e0e0e0;
            font-family: 'Orbitron', sans-serif;
            margin: 0;
            overflow: hidden;
        }

        body::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.3) 0, rgba(0,0,0,0.3) 1px, transparent 1px, transparent 2px);
            pointer-events: none;
            z-index: 9999;
            opacity: 0.5;
        }

        canvas {
            display: block;
            background-color: #0c0c0c;
        }
        
        #gameContainer {
            display: block; /* Changed */
            position: relative;
            width: 100vw;
            height: 100vh;
            box-shadow: inset 0 0 150px rgba(0, 255, 136, 0.15);
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 1; }
            50% { opacity: 0.95; }
            100% { opacity: 1; }
        }

        .game-ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        #top-head-band {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: var(--bar-bg);
            border-bottom: 2px solid var(--crt-color);
            box-shadow: 0 2px 15px rgba(0, 255, 136, 0.2);
            padding: 10px 20px;
            box-sizing: border-box;
            z-index: 6;
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }

        .top-ui {
            position: static;
            width: 100%;
            padding: 0;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }

        .top-right-ui {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        #bossBarsWrapper {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .boss-health-container {
            width: 100%;
            height: 25px;
            background-color: rgba(51, 51, 51, 0.7);
            border: 2px solid rgba(255, 0, 0, 0.4);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
            position: relative;
            transition: all 0.3s ease-in-out;
        }

        .boss-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, rgba(255, 68, 68, 0.4), rgba(255, 0, 0, 0.4));
            transition: width 0.2s linear;
        }

        .boss-name {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: var(--ui-font-size-base);
            text-shadow: 1px 1px 2px black;
            width: 100%;
            text-align: center;
        }

        /* --- Panel and HUD Styles --- */

        .info-display {
            background-color: var(--info-display-bg);
            border: 2px solid var(--info-display-border);
            border-radius: 5px;
            padding: clamp(5px, 1vh, 10px) clamp(10px, 1vw, 20px);
            color: var(--crt-color);
            text-shadow: var(--crt-glow);
            font-family: 'Orbitron', sans-serif;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 0 5px rgba(0,0,0,0.3);
            transition: all 0.5s ease;
            pointer-events: auto;
            white-space: nowrap;
        }

        #totalMoneyDisplay {
            border-color: #ffd700;
            color: #ffd700;
            text-shadow: 0 0 8px #ffd700;
            animation: money-glow 2s infinite ease-in-out;
            margin-bottom: 10px;
            text-align: center;
        }

        @keyframes money-glow {
            0%, 100% {
                box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 0 10px rgba(255, 215, 0, 0.7);
                border-color: #ffd700;
            }
            50% {
                box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 0 20px rgba(255, 215, 0, 1);
                border-color: #fff;
            }
        }

        #magazine-display {
            min-width: 280px;
            justify-content: center;
        }

        #gameTimer { font-size: var(--ui-font-size-large); }
        #score, #flag-counter, #money { font-size: var(--ui-font-size-medium); }

        #weapon-ui {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 10px;
            pointer-events: auto;
        }
        .weapon-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-around; /* Changed */
            gap: 2px; /* A little less gap */
            color: #fff;
            font-size: var(--ui-font-size-small);
            background-color: #333;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #555;
            width: clamp(55px, 6vw, 70px); /* A bit wider */
            height: clamp(65px, 7vw, 80px); /* A bit taller */
            box-sizing: border-box;
        }
        .weapon-slot.mermi-manyagi { border-color: #ffd700; box-shadow: inset 0 0 8px rgba(255, 215, 0, 0.5); }
        .weapon-slot.kundakci { border-color: #ff6600; box-shadow: inset 0 0 8px rgba(255, 102, 0, 0.5); }
        .weapon-slot.teknoloji-meraklisi { border-color: #00ffff; box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.5); }
        .weapon-slot.oyuncak-sever { border-color: #cc33ff; box-shadow: inset 0 0 8px rgba(204, 51, 255, 0.5); }

        .weapon-slot.mermi-manyagi .weapon-icon { color: #ffd700; }
        .weapon-slot.kundakci .weapon-icon { color: #ff6600; }
        .weapon-slot.teknoloji-meraklisi .weapon-icon { color: #00ffff; }
        .weapon-slot.oyuncak-sever .weapon-icon { color: #cc33ff; }

        .weapon-icon {
            font-size: clamp(1.5em, 3vw, 1.8em);
            width: auto;
            line-height: 1;
        }
        .weapon-level {
            font-size: 0.9em;
            line-height: 1;
        }
        .weapon-damage {
            font-size: 0.9em;
            color: #ffdd88;
            font-weight: bold;
            line-height: 1;
        }

        #dashboard {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, var(--dashboard-bg-start) 0%, var(--dashboard-bg-end) 100%);
            border-top: 4px solid var(--dashboard-border);
            box-shadow: 0 -5px 15px rgba(0, 255, 136, 0.2) inset;
            padding: clamp(10px, 1.5vh, 15px) clamp(15px, 2vw, 25px);
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            gap: clamp(10px, 2vw, 20px);
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }

        .panel-section {
            display: flex;
            align-items: center;
            gap: clamp(10px, 1.5vw, 15px);
        }
        #left-panel { flex: 1 1 30%; }
        #center-panel { flex: 1 1 40%; }
        #right-panel { flex: 1 1 30%; justify-content: flex-end; }

        .gauge-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .xp-gauge {
            justify-content: center;
        }
        .gauge-label {
            font-size: var(--ui-font-size-small);
            color: #ccc;
            text-transform: uppercase;
            margin-bottom: 5px;
            text-shadow: 1px 1px 1px #000;
        }
        #health-bar-container .gauge-label {
            position: absolute;
            left: 10px; /* Sağa yaslıdan sola yaslıya değiştirildi */
            right: auto; /* 'right' özelliğini geçersiz kıl */
            top: 50%;
            transform: translateY(-50%);
            margin-bottom: 0;
            pointer-events: none;
            font-weight: bold; /* Kalın yapıldı */
            font-size: var(--ui-font-size-base);
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
        #xp-bar-container .gauge-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            margin-bottom: 0;
            pointer-events: none;
            font-weight: bold;
            font-size: var(--ui-font-size-base);
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
        .gauge-bar-container {
            width: 100%;
            background-color: #1a1a1a;
            border: 1px solid #000;
            border-radius: 5px;
            overflow: hidden;
            padding: 2px;
            position: relative;
        }
        #health-bar-container { height: clamp(30px, 4vh, 35px); }
        #xp-bar-container { height: clamp(30px, 4vh, 35px); }
        
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #777;
            background-image: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.1),
                rgba(255, 255, 255, 0.1) 8px,
                rgba(0, 0, 0, 0.1) 8px,
                rgba(0, 0, 0, 0.1) 16px
            ), linear-gradient(to bottom, #9e9e9e, #616161);
            border-radius: 3px;
            transition: width 0.2s linear;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
        }
        #xp-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #007bb5, #00aaff);
            border-radius: 3px;
            transition: width 0.2s linear, background-color 0.5s;
            box-shadow: 0 0 5px #00aaff, 0 0 10px #00aaff, 0 0 15px #00aaff;
        }
        .gauge-text {
            text-align: center;
            color: #fff;
            font-size: var(--ui-font-size-base);
            font-weight: bold;
            margin-top: calc(-1 * clamp(23px, 3vh, 28px));
            text-shadow: 1px 1px 2px #000;
            position: relative;
            pointer-events: none;
        }
        #health-bar-container > #health-text {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            transform: translateY(-50%);
            margin-top: 0;
        }

        .skill-gauge {
            width: clamp(80px, 8vw, 100px);
            height: 10px;
            margin-bottom: 5px;
            border-radius: 5px;
            overflow: hidden;
            padding: 2px;
            display: flex;
            gap: 2px;
        }

        .fuel-segment {
            flex-grow: 1;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 1px;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            border: 1px solid #000;
        }

        .fuel-segment.charged {
            background-color: var(--crt-color);
            box-shadow: var(--crt-glow);
        }

        .shield-segment {
            flex-grow: 1;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 1px;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            border: 1px solid #000;
        }

        .shield-segment.charged {
            background-color: var(--shield-color);
            box-shadow: var(--shield-glow);
        }

        #dash-fuel-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #ffc400, #ffd700);
            border-radius: 3px;
            transition: width 0.1s linear;
        }

        #skills-container {
            display: flex;
            gap: clamp(10px, 2vw, 20px);
        }
        .skill-button-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .skill-label {
            font-size: var(--ui-font-size-small);
            color: #ccc;
            text-transform: uppercase;
            text-shadow: 1px 1px 1px #000;
            display: none;
        }
        .skill-button {
            width: clamp(80px, 8vw, 100px);
            height: clamp(45px, 5vh, 50px);
            background: linear-gradient(to bottom, #777, #555);
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px #222, 0 6px 6px rgba(0,0,0,0.4);
            color: #fff;
            text-shadow: 1px 1px 1px #000;
            font-family: 'Orbitron', sans-serif;
            font-size: var(--ui-font-size-base);
            cursor: pointer;
            transition: all 0.1s ease-out;
        }
        .skill-button:active {
            transform: translateY(4px);
            box-shadow: 0 0 #222;
        }
        .skill-button.ready {
            background: linear-gradient(to bottom, #00ab66, #008751);
            color: #fff;
            text-shadow: var(--crt-glow);
            box-shadow: 0 4px #004d2e, 0 6px 6px rgba(0,0,0,0.4);
        }
        .skill-button.ready:active {
            transform: translateY(4px);
            box-shadow: 0 0 #004d2e;
        }
        
        /* --- Pop-up & Menu Styles --- */
        .objective-popup {
            display: none;
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2.5em, 6vw, 4.5em);
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px var(--crt-color), 0 0 20px var(--crt-color), 0 0 40px var(--crt-color);
            z-index: 1050;
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
        }

        .objective-popup.show {
            display: block;
            animation: fadeInOut 2s ease-in-out forwards;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }

        #achievement-toast {
            position: absolute;
            bottom: 150px; /* Position above dashboard */
            right: -400px; /* Start off-screen */
            background-color: rgba(255, 215, 0, 0.9);
            color: #000;
            padding: 15px;
            border-radius: 10px 0 0 10px;
            border: 2px solid #000;
            z-index: 20;
            transition: right 0.5s ease-in-out;
            text-shadow: none;
            width: 320px;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #achievement-toast.show {
            right: 0; /* Slide in */
        }

        #achievement-title {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        #achievement-desc {
            font-size: 1em;
        }

        .map-hint {
            position: absolute;
            top: 170px;
            left: 20px;
            background-color: rgba(20, 50, 20, 0.8);
            border: 1px solid var(--crt-color);
            border-radius: 5px;
            padding: 8px 15px;
            color: var(--crt-color);
            text-shadow: var(--crt-glow);
            font-size: var(--ui-font-size-base);
            z-index: 10;
            pointer-events: none;
            animation: hint-pulse 2s infinite ease-in-out;
        }

        @keyframes hint-pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.9;
            }
            50% {
                transform: scale(1.05);
                opacity: 1;
            }
        }

        #activeQuestUI {
            position: absolute;
            top: 120px;
            left: 20px;
            background-color: rgba(50, 40, 20, 0.8);
            border: 1px solid #ffd700;
            border-radius: 5px;
            padding: 8px 15px;
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700, 0 0 10px #ffd700;
            font-size: var(--ui-font-size-base);
            z-index: 10;
            pointer-events: none;
        }

        .game-over-screen, .level-up-screen, .pause-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 20, 10, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 850px; /* Genişletildi */
            /* z-index, daha belirli seçicilerle aşağıda ele alınmıştır */
            pointer-events: auto;
            box-sizing: border-box;
        }
        .game-over-screen { z-index: 1030; border: 2px solid #ff0000; color: #ff0000; box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); }
        .game-over-screen.win { border: 2px solid #ffd700; color: #ffd700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
        .pause-menu { z-index: 1020; border: 2px solid #aaaaaa; color: #aaaaaa; box-shadow: 0 0 20px rgba(200, 200, 200, 0.5); max-width: 1100px; }
        #levelUpScreen { z-index: 1010; }
        #discardWeaponScreen { z-index: 1000; }
        
        #pause-main-content {
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            gap: 30px;
            margin-top: 20px;
        }
        
        #pause-panels-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            flex: 3;
            order: 2; /* Sağa yaslamak için */
        }

        .pause-panel {
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--crt-color);
            border-radius: 8px;
            padding: 10px; /* Reduced padding */
            box-shadow: inset 0 0 10px #000;
        }

        .pause-panel h3 {
            margin-top: 0;
            margin-bottom: 10px; /* Reduced margin */
            color: var(--crt-color);
            text-shadow: var(--crt-glow);
            text-align: center;
            font-size: 1.1em; /* Reduced font size */
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 8px; /* Reduced padding */
        }

        /* Silah grupları için yeni stiller */
        .pause-panel.mermi-manyagi { border-color: #ffd700; }
        .pause-panel.mermi-manyagi h3, .pause-panel.mermi-manyagi .weapon-list .weapon-icon { color: #ffd700; text-shadow: 0 0 8px #ffd700; }

        .pause-panel.kundakci { border-color: #ff6600; }
        .pause-panel.kundakci h3, .pause-panel.kundakci .weapon-list .weapon-icon { color: #ff6600; text-shadow: 0 0 8px #ff6600; }

        .pause-panel.teknoloji-meraklisi { border-color: #00ffff; }
        .pause-panel.teknoloji-meraklisi h3, .pause-panel.teknoloji-meraklisi .weapon-list .weapon-icon { color: #00ffff; text-shadow: 0 0 8px #00ffff; }

        .pause-panel.oyuncak-sever { border-color: #cc33ff; }
        .pause-panel.oyuncak-sever h3, .pause-panel.oyuncak-sever .weapon-list .weapon-icon { color: #cc33ff; text-shadow: 0 0 8px #cc33ff; }

        .weapon-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: var(--ui-font-size-small); /* Reduced font size */
        }

        .weapon-list li {
            padding: 4px 0; /* Reduced padding */
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 8px; /* Reduced gap */
        }
        
        .weapon-list li, .pause-panel h3[data-achievement-id] {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .pause-panel h3[data-achievement-id]:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        .weapon-list li:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .weapon-list .weapon-icon {
            font-size: 1.4em;
            width: 25px;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 5px #fff;
        }

        .game-over-screen h2, .level-up-screen h2, .pause-menu h2 { margin: 0 0 20px 0; font-size: 3em; text-shadow: 0 0 10px currentColor; }
        .game-over-screen p { font-size: 1.5em; }
        
        #upgrade-options { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        .menu-buttons { 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            flex: 1;
            justify-content: flex-end;
            align-items: flex-start; /* Sola yaslamak için */
            order: 1; /* Sola yaslamak için */
        }

        #discard-weapon-options {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        #discard-weapon-options .upgrade-button {
            flex-direction: column;
            width: 110px;
            height: 100px;
            padding: 10px;
        }
        #discard-weapon-options .upgrade-text {
            text-align: center;
        }

        .menu-button, .upgrade-button { background-color: #2a2a2a; color: var(--crt-color); border: 2px solid var(--crt-color); padding: 15px 20px; font-family: 'Orbitron', sans-serif; font-size: 1em; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; gap: 15px; position: relative; }
        .upgrade-button { opacity: 0; transform: scale(0.9); animation: slot-in 0.5s forwards; }
        @keyframes slot-in { to { opacity: 1; transform: scale(1); } }
        .upgrade-button.max-level { color: #888; border-color: #888; cursor: not-allowed; }
        .menu-button:hover, .upgrade-button:not(.max-level):hover { background-color: var(--crt-color); color: #1a1a1a; box-shadow: 0 0 15px var(--crt-color); }
        
        .upgrade-button.mermi-manyagi { border-color: #ffd700; color: #ffd700; box-shadow: 0 0 10px rgba(255, 215, 0, 0.7); }
        .upgrade-button.mermi-manyagi:not(.max-level):hover { background-color: #ffd700; color: #1a1a1a; box-shadow: 0 0 15px #ffd700; }

        .upgrade-button.kundakci { border-color: #ff6600; color: #ff6600; box-shadow: 0 0 10px rgba(255, 102, 0, 0.7); }
        .upgrade-button.kundakci:not(.max-level):hover { background-color: #ff6600; color: #1a1a1a; box-shadow: 0 0 15px #ff6600; }

        .upgrade-button.teknoloji-meraklisi { border-color: #00ffff; color: #00ffff; box-shadow: 0 0 10px rgba(0, 255, 255, 0.7); }
        .upgrade-button.teknoloji-meraklisi:not(.max-level):hover { background-color: #00ffff; color: #1a1a1a; box-shadow: 0 0 15px #00ffff; }

        .upgrade-button.oyuncak-sever { border-color: #cc33ff; color: #cc33ff; box-shadow: 0 0 10px rgba(204, 51, 255, 0.7); }
        .upgrade-button.oyuncak-sever:not(.max-level):hover { background-color: #cc33ff; color: #1a1a1a; box-shadow: 0 0 15px #cc33ff; }

        /* GLOWING BUTTON STYLES START */
        .upgrade-button.glowing.mermi-manyagi { animation: slot-in 0.5s forwards, glowing-mermi 1.5s ease-in-out infinite; }
        .upgrade-button.glowing.kundakci { animation: slot-in 0.5s forwards, glowing-kundakci 1.5s ease-in-out infinite; }
        .upgrade-button.glowing.teknoloji-meraklisi { animation: slot-in 0.5s forwards, glowing-teknoloji 1.5s ease-in-out infinite; }
        .upgrade-button.glowing.oyuncak-sever { animation: slot-in 0.5s forwards, glowing-oyuncak 1.5s ease-in-out infinite; }

        @keyframes glowing-mermi {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.7), 0 0 15px #ffd700; border-color: #ffd700;}
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 0 30px #ffd700, 0 0 10px #fff inset; border-color: #fff;}
        }
        @keyframes glowing-kundakci {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 102, 0, 0.7), 0 0 15px #ff6600; border-color: #ff6600;}
            50% { box-shadow: 0 0 20px rgba(255, 102, 0, 1), 0 0 30px #ff6600, 0 0 10px #fff inset; border-color: #fff;}
        }
        @keyframes glowing-teknoloji {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.7), 0 0 15px #00ffff; border-color: #00ffff;}
            50% { box-shadow: 0 0 20px rgba(0, 255, 255, 1), 0 0 30px #00ffff, 0 0 10px #fff inset; border-color: #fff;}
        }
        @keyframes glowing-oyuncak {
            0%, 100% { box-shadow: 0 0 10px rgba(204, 51, 255, 0.7), 0 0 15px #cc33ff; border-color: #cc33ff;}
            50% { box-shadow: 0 0 20px rgba(204, 51, 255, 1), 0 0 30px #cc33ff, 0 0 10px #fff inset; border-color: #fff;}
        }

        /* FINAL CHOICE ANIMATION */
        @keyframes pulsing-scale {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .upgrade-button.final-choice .upgrade-icon,
        .upgrade-button.final-choice .upgrade-text {
            animation: pulsing-scale 1.2s ease-in-out infinite;
        }
        /* GLOWING BUTTON STYLES END */

        .new-tag {
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: #ffd700;
            color: #1a1a1a;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: bold;
            line-height: 1;
            z-index: 1;
            text-shadow: none;
        }

        .menu-button { color: #ccc; border-color: #ccc; }
        .menu-button:hover { color: #1a1a1a; background-color: #ccc; }
        .upgrade-icon { font-size: 2em; line-height: 1; width: 40px; text-align: center; }
        .upgrade-text { text-align: left; }
        .upgrade-text strong { display: block; }
        .upgrade-text span { font-size: 0.8em; color: #ccc; }
        #restartButton { background-color: var(--crt-color); color: #1a1a1a; border: none; padding: 15px 30px; font-family: 'Orbitron', sans-serif; font-size: 1.2em; font-weight: bold; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 0 15px rgba(0, 255, 136, 0.5); }
        #restartButton:hover { background-color: #fff; color: #000; box-shadow: 0 0 25px rgba(255, 255, 255, 0.8); }
        
        #gameOverStatsContainer {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-top: 30px;
            width: 100%;
        }

        #scoreboard, #weaponDamageScoreboard { 
            flex: 1;
            text-align: left; 
            color: var(--crt-color); 
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--crt-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: inset 0 0 10px #000;
        }
        .game-over-screen.win #scoreboard, .game-over-screen.win #weaponDamageScoreboard { 
            color: #ffd700; 
            border-color: #ffd700;
        }
        #scoreboard h3, #weaponDamageScoreboard h3 { text-align: center; margin-bottom: 10px; }
        #scoreboard ol, #weaponDamageScoreboard ol { padding-left: 0; list-style: none; font-size: 1.1em; }
        #scoreboard li, #weaponDamageScoreboard li { margin-bottom: 5px; display: flex; justify-content: space-between; gap: 15px; align-items: center;}
        #scoreboard li span:first-child, #weaponDamageScoreboard li span:first-child { flex-grow: 1; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        #scoreboard small { color: #aaa; font-size: 0.8em; }
        .ui-button { pointer-events: auto; background-color: rgba(0,0,0,0.5); border: 2px solid var(--crt-color); color: var(--crt-color); font-size: 1.5em; width: 50px; height: 50px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; text-shadow: var(--crt-glow); }
        .ui-button:hover { background-color: var(--crt-color); color: #1a1a1a; }

        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            gap: 0;
            align-items: center;
            justify-content: center;
            overflow-y: hidden;
            z-index: 2000;
            color: var(--crt-color);
            text-align: center;
            text-shadow: var(--crt-glow);
            padding: 20px;
            box-sizing: border-box;
        }
        #mainMenu h1 {
            font-size: clamp(3em, 10vw, 6em);
            margin: 0;
            letter-spacing: 5px;
            animation: text-flicker 3s infinite alternate;
        }
        #mainMenu .subtitle {
            font-size: var(--ui-font-size-medium);
            margin: 5px 0 20px 0;
            opacity: 0.8;
        }
        #startButton {
            background-color: var(--crt-color);
            color: #1a1a1a;
            border: none;
            padding: 20px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.7);
            animation: button-pulse 2s infinite ease-in-out;
        }
        #startButton:hover {
            background-color: #fff;
            color: #000;
            box-shadow: 0 0 35px rgba(255, 255, 255, 0.9);
            animation-play-state: paused;
        }
        .instructions {
           display: none;
        }
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 20px;
            text-align: left;
        }
        .controls-grid p {
            margin: 0;
            font-size: var(--ui-font-size-base);
        }
        .controls-grid p strong {
            color: #fff;
            min-width: 80px;
            display: inline-block;
        }

        .main-layout-container {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            justify-content: space-around;
            align-items: center;
            gap: 40px;
            width: 100%;
            max-width: 1800px;
            height: 100%;
        }

        .center-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-shrink: 0;
        }

        #vehicles-panel {
            flex: 1 1 350px; /* Panel boyutu küçültüldü */
            max-width: 400px; /* Maksimum genişlik azaltıldı */
            align-self: center;
        }

        .vehicle-category {
            margin-bottom: 8px;
        }
        .vehicle-category:last-child {
            margin-bottom: 0;
        }

        .vehicle-category h4 {
            color: #ccc;
            text-align: left;
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            font-size: var(--ui-font-size-base);
            text-shadow: none;
            font-weight: normal;
        }

        .permanent-upgrades-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: rgba(0, 20, 10, 0.7);
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 10px;
            flex: 1 1 450px;
            max-width: 500px;
            align-self: center;
        }
        .permanent-upgrades-container h3 {
            margin: 0;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 10px;
            margin-bottom: 10px;
            width: 100%;
            text-align: center;
        }

        .panel-tabs {
            display: flex;
            width: 100%;
            margin-bottom: 20px;
        }

        .panel-tab {
            flex: 1;
            padding: 10px;
            background-color: transparent;
            border: 2px solid var(--crt-color);
            color: var(--crt-color);
            font-family: 'Orbitron', sans-serif;
            font-size: var(--ui-font-size-base);
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: var(--crt-glow);
        }

        .panel-tab:first-child {
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
            border-right: 1px solid var(--crt-color);
        }

        .panel-tab:last-child {
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
            border-left: 1px solid var(--crt-color);
        }

        .panel-tab:hover:not(.active) {
            background-color: rgba(0, 255, 136, 0.2);
        }

        .panel-tab.active {
            background-color: var(--crt-color);
            color: #000;
            text-shadow: none;
            font-weight: bold;
        }

        .panel-content {
            display: none;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            height: 420px; /* Sabit yükseklik */
            justify-content: center; /* Yükseltmeler sekmesini ortalamak için */
        }
        
        #vehiclesContent {
            justify-content: space-around; /* Dikeyde daha iyi dağılım için değiştirildi */
            overflow-y: hidden; /* Kaydırma çubuğu kaldırıldı */
            padding: 10px;
            box-sizing: border-box;
        }
        
        .panel-content.active {
            display: flex;
        }

        .upgrade-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            width: 100%;
        }

        .upgrade-label {
            font-size: var(--ui-font-size-base);
            flex: 2;
            text-align: left;
        }

        .upgrade-slots {
            display: flex;
            gap: 8px;
        }

        .upgrade-slot {
            width: 30px;
            height: 15px;
            border: 1px solid var(--crt-color);
            background-color: rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }
        .upgrade-slot.purchased {
            background-color: var(--crt-color);
            box-shadow: var(--crt-glow);
        }

        .upgrade-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 0;
            flex: 3;
            justify-content: center;
        }

        .upgrade-cost {
            font-size: var(--ui-font-size-small);
            color: #ccc;
            min-height: 1.2em; /* Prevent layout shift */
            flex: 1;
            text-align: right;
        }

        .buy-upgrade-button {
            background-color: transparent;
            color: var(--crt-color);
            border: 2px solid var(--crt-color);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: bold;
            padding: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        .buy-upgrade-button:hover:not(:disabled) {
            background-color: var(--crt-color);
            color: #1a1a1a;
        }
        .buy-upgrade-button:disabled {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Vehicle Selection Styles */
        .vehicle-selection-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            margin-top: 10px;
        }

        .vehicle-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 5px;
            border: 2px solid var(--crt-color);
            border-radius: 8px;
            background-color: rgba(0,0,0,0.5);
            cursor: pointer;
            transition: all 0.3s ease;
            height: 80px; /* Sabit yükseklik */
        }

        .vehicle-item:not(.locked):not(.selected):hover {
            background-color: var(--crt-color);
            color: #1a1a1a;
            transform: scale(1.05);
        }
        
        .vehicle-item.buyable {
             border-color: #00ff88;
             box-shadow: none;
             color: var(--crt-color);
        }

        .vehicle-item.buyable:hover {
            background-color: #00ff88;
            color: #1a1a1a;
            transform: scale(1.05);
        }

        .vehicle-item.selected {
            border-color: #ffd700;
            box-shadow: 0 0 15px #ffd700;
            cursor: default;
        }
        
        .vehicle-item.selected:hover {
            transform: none; /* Seçili öğenin büyümesini engelle */
        }

        .vehicle-item.locked:not(.buyable) {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .vehicle-item.locked:not(.buyable):hover {
            background-color: rgba(0,0,0,0.5);
            color: #555;
        }

        .vehicle-icon {
            font-size: 2.2em;
            line-height: 1;
        }

        .vehicle-name {
            font-size: var(--ui-font-size-small);
            font-weight: bold;
            text-align: center;
        }

        .vehicle-price {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }

        /* Tooltip styles */
        .vehicle-tooltip {
            display: none;
            position: absolute;
            background-color: rgba(0, 20, 10, 0.95);
            border: 1px solid var(--crt-color);
            border-radius: 8px;
            padding: 15px;
            color: #e0e0e0;
            text-shadow: none;
            z-index: 2010; /* Above main menu */
            width: 300px;
            pointer-events: none; /* Tooltip itself shouldn't be interactive */
            font-size: var(--ui-font-size-small);
            text-align: left;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .vehicle-tooltip h4 {
            margin: 0 0 10px 0;
            color: var(--crt-color);
            text-shadow: var(--crt-glow);
            font-size: var(--ui-font-size-base);
        }

        .vehicle-tooltip p {
            margin: 0 0 10px 0;
            color: #ccc;
        }

        .vehicle-tooltip .stats {
    padding: 0;
    margin: 10px 0 0 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.stat-bar-container {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
}
.stat-bar-label {
    width: 60px; /* Sabit genişlik */
    flex-shrink: 0;
    color: #fff;
    font-weight: bold;
}
.stat-bar-wrapper {
    flex-grow: 1;
    display: flex;
    height: 12px;
    background-color: rgba(0,0,0,0.5);
    border-radius: 3px;
    overflow: hidden;
    border: 1px solid #555;
}
.stat-bar-fill {
    height: 100%;
    background: linear-gradient(to right, var(--crt-color), #00ffc8);
    border-radius: 2px;
    box-shadow: inset 0 0 5px rgba(255,255,255,0.2), 0 0 5px var(--crt-color);
}

.weapon-list li.locked {
    color: #555;
    cursor: default;
}
.pause-panel h3.locked {
    color: #555;
    cursor: default;
}
.pause-panel h3.locked:hover {
    background-color: transparent;
}
.weapon-list li.locked .weapon-icon {
    opacity: 0.4;
}
.weapon-list li.locked:hover {
    background-color: transparent;
}

.weapon-stats-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
    font-size: 0.9em;
}
.weapon-stats-table th, .weapon-stats-table td {
    border: 1px solid rgba(0, 255, 136, 0.2);
    padding: 4px;
    text-align: left;
}
.weapon-stats-table th {
    background-color: rgba(0, 0, 0, 0.3);
}

@keyframes text-flicker {
    0%, 100% { opacity: 1; text-shadow: var(--crt-glow); }
    50% { opacity: 0.8; text-shadow: 0 0 5px #00ff88; }
        }

        @keyframes button-pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 25px rgba(0, 255, 136, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(0, 255, 136, 1); }
        }

        .difficulty-button {
            background-color: var(--crt-color);
            color: #1a1a1a;
            border: none;
            padding: 20px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.7);
            animation: button-pulse 2s infinite ease-in-out;
        }
        .difficulty-button:hover {
            background-color: #fff;
            color: #000;
            box-shadow: 0 0 35px rgba(255, 255, 255, 0.9);
            animation-play-state: paused;
        }

        .difficulty-button.secondary {
            background-color: rgba(0, 255, 136, 0.2);
            border: 2px solid var(--crt-color);
            color: var(--crt-color);
            box-shadow: none;
            animation: none;
            opacity: 0.8;
            font-size: 1.2em;
            padding: 15px 30px;
            font-weight: normal;
        }
        .difficulty-button.secondary:hover {
            background-color: var(--crt-color);
            color: #1a1a1a;
            opacity: 1;
        }

        #muteButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            font-size: 2em;
            z-index: 2001;
        }

        #lootBoxAnimationContainer {
            display: none;
            position: absolute;
            top: 75%; /* Changed from 50% to move it lower */
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1040;
            pointer-events: none;
        }

        @keyframes chest-glow {
            0%, 100% { box-shadow: inset 0 0 15px rgba(0,0,0,0.4), 0 0 10px #ffd700, 0 0 20px #ffc400; }
            50% { box-shadow: inset 0 0 15px rgba(0,0,0,0.4), 0 0 20px #ffd700, 0 0 35px #ffd700; }
        }

        #lootBoxChest {
            position: relative;
            width: 200px;
            height: 160px;
        }

        .chest-lid, .chest-base {
            position: absolute;
            width: 100%; /* 200px */
            background: linear-gradient(135deg, #f0c84a, #d4a22a);
            box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
            border: 4px solid #4a3c22;
            animation: chest-glow 2.5s infinite ease-in-out;
            box-sizing: border-box;
        }

        .chest-lid {
            height: 50px;
            top: 0;
            border-radius: 10px 10px 0 0;
            border-bottom: none;
        }

        .chest-base {
            height: 110px;
            top: 50px;
            border-radius: 0 0 10px 10px;
        }

        @keyframes gem-glow {
            0%, 100% { 
                background-color: #00aaff;
                box-shadow: 0 0 15px #00c0ff, 0 0 30px #00c0ff, 0 0 45px #00aaff, inset 0 0 10px rgba(255,255,255,0.3); 
            }
            50% { 
                background-color: #00c0ff;
                box-shadow: 0 0 30px #00c0ff, 0 0 60px #00c0ff, 0 0 90px #00aaff, inset 0 0 15px rgba(255,255,255,0.5); 
            }
        }

        /* Lid Top Detail */
        .chest-lid::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35px;
            height: 35px;
            background-color: #00aaff;
            border-radius: 50%;
            border: 4px solid #2e3a4e;
            animation: gem-glow 1.5s infinite ease-in-out;
        }

        /* Base Front Detail */
        .chest-base::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 60px;
            background-color: #3a3a3a;
            border: 4px solid #222;
            border-radius: 5px;
        }
        .chest-base::after {
            content: '';
            position: absolute;
            top: 28px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 44px;
            background: linear-gradient(to bottom, #555, #444);
            border-radius: 3px;
        }


        #lootBoxChest.grow {
            animation: grow-in 0.5s ease-out forwards;
        }

        #lootBoxChest.shake {
            animation-name: shake-animation;
            animation-duration: 0.1s;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }

        @keyframes grow-in {
            from {
                transform: scale(0);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes shake-animation {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-8px, 0) rotate(-3deg); }
            50% { transform: translate(8px, 0) rotate(3deg); }
            75% { transform: translate(-8px, 0) rotate(-3deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }

        #damageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            overflow: hidden;
        }

        #damageOverlay svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.4s ease-out;
            will-change: opacity, filter;
        }

        #damageOverlay.critical svg {
            opacity: 1;
        }

        #damageOverlay .cracks {
            animation: crack-shimmer 2.5s infinite ease-in-out;
        }

        #damageOverlay .cracks path {
            fill: none;
            stroke: white;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        #damageOverlay .blood-splatters {
            transform-origin: center center;
            opacity: 0.8; /* Static opacity */
        }

        #damageOverlay .blood-splatters path,
        #damageOverlay .blood-splatters circle {
            fill: rgba(180, 0, 0, 0.6);
            stroke: none;
            filter: drop-shadow(0 0 5px rgba(100,0,0,0.8));
        }

        @keyframes crack-shimmer {
            0%, 100% {
                filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.7));
            }
            50% {
                filter: drop-shadow(0 0 10px rgba(255, 255, 255, 1));
            }
        }

        /* Yeni Uyarı Modalı Stili */
        #easyModeConfirmModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 20, 10, 0.95);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 600px;
            z-index: 2020; /* Ana menünün üzerinde olması için */
            pointer-events: auto;
            border: 2px solid #ffd700;
            color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        #easyModeConfirmModal h2 {
            margin: 0 0 20px 0;
            font-size: 2.5em;
            text-shadow: 0 0 10px currentColor;
        }
        #easyModeConfirmModal p {
            font-size: 1.2em;
            color: #e0e0e0;
            text-shadow: none;
            line-height: 1.6;
            margin-bottom: 30px;
        }
        #easyModeConfirmModal .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }


        /* Responsiveness */
        @media (max-width: 1024px) {
            #dashboard {
                flex-wrap: wrap;
                justify-content: center;
            }
            #left-panel, #right-panel {
                flex-basis: 45%;
                flex-grow: 1;
            }
            #center-panel {
                flex-basis: 100%;
                order: 3;
            }
        }

        @media (max-width: 768px) {
            #top-head-band {
                padding: 5px;
            }
            .top-ui {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
            #weapon-ui {
                order: 3;
                justify-content: center;
            }
            #dashboard {
                padding: 5px;
                gap: 5px;
                flex-direction: column;
            }
            .panel-section {
                width: 100%;
                justify-content: center;
            }
            #left-panel, #right-panel, #center-panel {
                flex-basis: auto;
            }
            #right-panel {
                justify-content: center;
            }

            #bossBarsWrapper {
                top: 240px; /* Top UI panelinin altına itmek için */
                width: 80%;
            }

            #activeQuestUI {
                top: 200px; /* Adjust for smaller screens */
                left: 10px;
                width: auto;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div id="mainMenu" class="menu-screen">
        <div class="main-layout-container">
            <div id="weapons-panel" class="permanent-upgrades-container" style="flex: 1 1 450px; max-width: 500px; display: flex; flex-direction: column;">
                <h3>SİLAHLAR</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; flex-grow: 1; overflow-y: auto; padding: 5px;">
                    <div class="pause-panel mermi-manyagi">
                        <h3 data-achievement-id="mermiManyagi">Mermi Manyağı</h3>
                        <ul class="weapon-list">
                            <li data-weapon-id="defaultGun"><span class="weapon-icon">🔫</span> Ana Silah</li>
                            <li data-weapon-id="railgun"><span class="weapon-icon">➡️</span> Zırh Delici</li>
                            <li data-weapon-id="shotgun"><span class="weapon-icon">🔥</span> Saçmalı Tüfek</li>
                            <li data-weapon-id="barrage"><span class="weapon-icon">▓</span> Yaylım Ateşi</li>
                            <li data-weapon-id="shrapnel"><span class="weapon-icon">☄️</span> Şarapnel Topu</li>
                        </ul>
                    </div>
                    <div class="pause-panel kundakci">
                        <h3 data-achievement-id="kundakci">Kundakçı</h3>
                        <ul class="weapon-list">
                            <li data-weapon-id="mortar"><span class="weapon-icon">💣</span> Bomba Atar</li>
                            <li data-weapon-id="flamethrower"><span class="weapon-icon">♨️</span> Alev Püskürtücü</li>
                            <li data-weapon-id="flameTrail"><span class="weapon-icon">👣</span> Alev İzi</li>
                            <li data-weapon-id="flameDance"><span class="weapon-icon">✨</span> Alev Dansı</li>
                        </ul>
                    </div>
                    <div class="pause-panel teknoloji-meraklisi">
                        <h3 data-achievement-id="teknolojiMeraklisi">Teknoloji Meraklısı</h3>
                        <ul class="weapon-list">
                            <li data-weapon-id="laser"><span class="weapon-icon">〰</span> Lazer Işını</li>
                            <li data-weapon-id="chain"><span class="weapon-icon">⚡</span> Zincir Şimşek</li>
                            <li data-weapon-id="missile"><span class="weapon-icon">🚀</span> Güdümlü Füze</li>
                            <li data-weapon-id="pulseCannon"><span class="weapon-icon">💨</span> Darbe Topu</li>
                        </ul>
                    </div>
                    <div class="pause-panel oyuncak-sever">
                        <h3 data-achievement-id="oyuncakSever">Oyuncak Sever</h3>
                        <ul class="weapon-list">
                            <li data-weapon-id="mines"><span class="weapon-icon">💥</span> Mayın Döşeyici</li>
                            <li data-weapon-id="turret"><span class="weapon-icon">🗼</span> Taret</li>
                            <li data-weapon-id="drone"><span class="weapon-icon">🤖</span> Savaş Dronu</li>
                            <li data-weapon-id="roboSpider"><span class="weapon-icon">🕷️</span> Robo-Örümcek</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="center-column">
                <h1 style="line-height: 1;">PENÇE<br>HAREKATI</h1>
                <p class="subtitle">Vatan sana emanet.</p>
                <div id="difficulty-selection" style="display: flex; flex-direction: column; align-items: center; gap: 20px; margin-top: 20px;">
                    <button id="normalModeButton" class="difficulty-button">NORMAL MOD</button>
                    <button id="easyModeButton" class="difficulty-button secondary">KOLAY MOD</button>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button id="controlsButton" class="menu-button">KONTROLLER</button>
                    <button id="resetDataButton" class="menu-button" style="color: #ff8888; border-color: #ff8888;">SIFIRLA</button>
                </div>
            </div>

             <div class="permanent-upgrades-container" style="flex: 1 1 450px; max-width: 500px; display: flex; flex-direction: column;">
                <div class="panel-tabs">
                    <button id="showVehiclesTab" class="panel-tab active">ARAÇLAR</button>
                    <button id="showUpgradesTab" class="panel-tab">YÜKSELTMELER</button>
                </div>

                <div id="vehiclesContent" class="panel-content active">
                    <div class="vehicle-category">
                        <div id="armoredVehicleContainer" class="vehicle-selection-container">
                            <!-- Zırhlı araçlar buraya dinamik olarak eklenecek -->
                        </div>
                    </div>
                    <div class="vehicle-category">
                        <div id="tankVehicleContainer" class="vehicle-selection-container">
                            <!-- Tanklar buraya dinamik olarak eklenecek -->
                        </div>
                    </div>
                    <div class="vehicle-category">
                        <div id="helicopterVehicleContainer" class="vehicle-selection-container">
                            <!-- Helikopterler buraya dinamik olarak eklenecek -->
                        </div>
                    </div>
                </div>
                
                <div id="upgradesContent" class="panel-content">
                    <div id="selected-vehicle-display-upgrades" style="display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 10px; border: 2px solid #ffd700; border-radius: 8px; background-color: rgba(0,0,0,0.5); margin-bottom: 20px; box-shadow: 0 0 15px #ffd700;">
                        <!-- JS ile doldurulacak -->
                    </div>
                    <div class="upgrade-row">
                        <span class="upgrade-label">Zırh Seviyesi</span>
                        <div class="upgrade-controls">
                            <button id="buyArmorUpgradeButton" class="buy-upgrade-button">+</button>
                            <div id="maxArmorSlots" class="upgrade-slots"></div>
                        </div>
                        <span id="armorUpgradeCost" class="upgrade-cost"></span>
                    </div>
                    <div class="upgrade-row">
                        <span class="upgrade-label">Kalkan Süresi</span>
                        <div class="upgrade-controls">
                            <button id="buyShieldUpgradeButton" class="buy-upgrade-button">+</button>
                            <div id="maxShieldSlots" class="upgrade-slots"></div>
                        </div>
                        <span id="shieldUpgradeCost" class="upgrade-cost"></span>
                    </div>
                    <div class="upgrade-row">
                        <span class="upgrade-label">Atılma Yakıtı</span>
                        <div class="upgrade-controls">
                            <button id="buyDashUpgradeButton" class="buy-upgrade-button">+</button>
                            <div id="maxDashSlots" class="upgrade-slots"></div>
                        </div>
                        <span id="dashUpgradeCost" class="upgrade-cost"></span>
                    </div>
                    <div class="upgrade-row">
                        <span class="upgrade-label">Saldırı Hızı (Ana Silah)</span>
                        <div class="upgrade-controls">
                            <button id="buyAttackSpeedUpgradeButton" class="buy-upgrade-button">+</button>
                            <div id="maxAttackSpeedSlots" class="upgrade-slots"></div>
                        </div>
                        <span id="attackSpeedUpgradeCost" class="upgrade-cost"></span>
                    </div>
                </div>
                
                <div style="margin-top: auto; display: flex; flex-direction: column; align-items: center; gap: 15px; padding-top: 20px; border-top: 1px solid rgba(0, 255, 136, 0.2);">
                    <div id="totalMoneyDisplay" class="info-display" style="font-size: var(--ui-font-size-large);">TL: <span>0</span></div>
                </div>
            </div>
        </div>
    </div>
    <div id="objectivePopup" class="objective-popup"></div>
    <div id="gameContainer" style="display: none;">
        <div id="damageOverlay">
            <svg viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice">
                <g class="cracks">
                    <!-- Connecting Lines -->
                    <path d="M250 150 L 700 400" stroke-width="1.5"></path>
                    <path d="M1700 100 L 1100 450" stroke-width="1.5"></path>
                    <path d="M150 900 L 800 600" stroke-width="1.5"></path>
                    <path d="M1800 950 L 1200 550" stroke-width="1.5"></path>
                    <path d="M960 540 L 500 800" stroke-width="1"></path>
                    <path d="M960 540 L 1400 200" stroke-width="1"></path>
            
                    <!-- Crack Clusters -->
                    <!-- Top Left -->
                    <path d="M250 150 l-50 -80 l20 30 l-40 -20 l30 40 l-60 -10" stroke-width="3"></path>
                    <path d="M250 150 l-100 50 l30 -20 l40 40 l-20 -50" stroke-width="2.5"></path>
                    <!-- Top Right -->
                    <path d="M1700 100 l80 -50 l-30 40 l50 -10 l-40 50 l70 -20" stroke-width="3"></path>
                    <path d="M1700 100 l100 80 l-40 -10 l20 50 l-50 -20" stroke-width="2.5"></path>
                    <!-- Bottom Left -->
                    <path d="M150 900 l-80 100 l40 -30 l-10 50 l50 -40 l-20 60" stroke-width="3"></path>
                    <path d="M150 900 l50 120 l-20 -40 l40 30 l-50 -10" stroke-width="2.5"></path>
                    <!-- Bottom Right -->
                    <path d="M1800 950 l100 50 l-40 -30 l50 50 l-60 -20 l30 70" stroke-width="3"></path>
                    <path d="M1800 950 l50 -100 l20 40 l-40 -20 l10 50" stroke-width="2.5"></path>
                </g>
                <g class="blood-splatters">
                    <!-- Main Splatters (Paths) -->
                    <!-- Top Left -->
                    <path d="M 180 100 C 80 70, 100 250, 220 220 Q 280 260, 300 180 T 180 100 Z"></path>
                    <!-- Top Right -->
                    <path d="M 1750 120 C 1850 100, 1820 250, 1700 240 Q 1650 280, 1640 200 T 1750 120 Z"></path>
                    <!-- Bottom Left -->
                    <path d="M 120 950 C 40 900, 180 930, 200 1000 Q 140 1050, 60 1020 Z"></path>
                    <!-- Bottom Right -->
                    <path d="M 1800 900 C 1880 860, 1880 1000, 1780 1010 Q 1720 950, 1800 900 Z"></path>
                    
                    <!-- Droplets (Circles) -->
                    <circle cx="350" cy="150" r="36"></circle>
                    <circle cx="200" cy="250" r="54"></circle>
                    <circle cx="400" cy="100" r="24"></circle>
                    <circle cx="420" cy="250" r="18"></circle>
                    
                    <circle cx="1650" cy="100" r="45"></circle>
                    <circle cx="1700" cy="280" r="27"></circle>
                    <circle cx="1580" cy="250" r="21"></circle>
                    
                    <circle cx="100" cy="850" r="42"></circle>
                    <circle cx="280" cy="1000" r="33"></circle>
                    <circle cx="350" cy="920" r="27"></circle>

                    <circle cx="1850" cy="1020" r="51"></circle>
                    <circle cx="1750" cy="850" r="24"></circle>
                    <circle cx="1880" cy="880" r="36"></circle>
                    <circle cx="1780" cy="1010" r="18"></circle>
                </g>
            </svg>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="game-ui-overlay">
            
            <div id="activeQuestUI" style="display: none;">
                <span id="questText"></span>
            </div>

             <div id="achievement-toast">
                <div id="achievement-title">BAŞARIM KAZANILDI!</div>
                <div id="achievement-desc">Açıklama buraya gelecek.</div>
            </div>
            <div id="top-head-band">
                <div class="top-ui">
                    <div id="weapon-ui" class="panel-section">
                        <!-- Weapon slots will be generated by JS -->
                    </div>
                    <div class="top-right-ui">
                        <div id="gameTimer" class="info-display">00:00</div>
                         <div id="score" class="info-display">SKOR: <span>0</span></div>
                         <div id="money" class="info-display">TL: <span>0</span></div>
                         <div id="flag-counter" class="info-display">🚩 <span>0/4</span></div>
                         <button id="mapButton" class="ui-button">🗺️</button>
                         <button id="pauseButton" class="ui-button">⏸️</button>
                    </div>
                </div>
            </div>
            
            <div id="bossBarsWrapper"></div>

            <div id="mapHint" class="map-hint" style="display: none;">Harita için [M] tuşuna bas</div>
    
            <div id="dashboard">
                <div id="left-panel" class="panel-section">
                    <div class="gauge-container">
                        <div id="health-bar-container" class="gauge-bar-container">
                            <div id="health-bar"></div>
                            <div class="gauge-label">ZIRH</div>
                            <div id="health-text" class="gauge-text">100 / 100</div>
                        </div>
                    </div>
                </div>
                <div id="center-panel" class="panel-section">
                    <div class="gauge-container xp-gauge">
                         <div id="xp-bar-container" class="gauge-bar-container">
                             <div id="xp-bar"></div>
                             <div class="gauge-label">SEVİYE <span id="level-value">1</span></div>
                         </div>
                    </div>
                    <div id="magazine-display" class="info-display" style="display: none; font-size: var(--ui-font-size-medium);"></div>
                </div>
                <div id="right-panel" class="panel-section">
                     <div id="skills-container">
                         <div class="skill-button-wrapper">
                             <div class="skill-label">ATILMA</div>
                             <div id="dash-fuel-bar-container" class="skill-gauge gauge-bar-container">
                                <div class="fuel-segment"></div>
                                <div class="fuel-segment"></div>
                                <div class="fuel-segment"></div>
                                <div class="fuel-segment"></div>
                                <div class="fuel-segment"></div>
                             </div>
                             <button id="dashSkill" class="skill-button">SHIFT</button>
                         </div>
                         <div class="skill-button-wrapper">
                             <div class="skill-label">KALKAN</div>
                             <div id="shield-duration-bar-container" class="skill-gauge gauge-bar-container">
                                <div class="shield-segment"></div>
                                <div class="shield-segment"></div>
                                <div class="shield-segment"></div>
                                <div class="shield-segment"></div>
                                <div class="shield-segment"></div>
                             </div>
                             <button id="shieldSkill" class="skill-button">SPACE</button>
                         </div>
                     </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameOverScreen" class="game-over-screen" style="display: none;">
        <h2 id="gameOverTitle">OYUN BİTTİ</h2>
        <p id="finalScore"></p>
        <div id="gameOverStatsContainer">
            <div id="scoreboard"></div>
            <div id="weaponDamageScoreboard"></div>
        </div>
        <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 20px;">
            <button id="restartButton">YENİDEN BAŞLAT</button>
            <button id="mainMenuFromGameOverButton" class="menu-button">ANA MENÜ</button>
        </div>
    </div>

    <div id="levelUpScreen" class="level-up-screen" style="display: none;">
        <h2>SEVİYE ATLADIN!</h2>
        <p id="levelUpInfo">Bir silah seç veya yükselt:</p>
        <div id="upgrade-options"></div>
        <div style="display: flex; margin-top: 20px; gap: 15px;">
            <button id="rerollButton" class="menu-button" style="display: none;">Yenile</button>
            <button id="skipButton" class="menu-button" style="margin-left: auto;">VAZGEÇ</button>
        </div>
    </div>

    <div id="discardWeaponScreen" class="level-up-screen" style="display: none;">
        <h2>KARARGAH GÜVENDE!</h2>
        <p>Ödül olarak bir silahı bırakıp yerine Ganimet Kutusu alabilirsin.</p>
        <div id="discard-weapon-options"></div>
        <button id="cancelDiscardButton" class="menu-button" style="margin-top: 15px;">VAZGEÇ</button>
    </div>

     <div id="pauseMenu" class="pause-menu" style="display: none;">
        <h2>OYUN DURDURULDU</h2>
        <div id="pause-main-content">
            <div id="pause-panels-container">
                <div class="pause-panel mermi-manyagi">
                    <h3 data-achievement-id="mermiManyagi">Mermi Manyağı</h3>
                    <ul class="weapon-list">
                        <li data-weapon-id="defaultGun"><span class="weapon-icon">🔫</span> Ana Silah</li>
                        <li data-weapon-id="railgun"><span class="weapon-icon">➡️</span> Zırh Delici</li>
                        <li data-weapon-id="shotgun"><span class="weapon-icon">🔥</span> Saçmalı Tüfek</li>
                        <li data-weapon-id="barrage"><span class="weapon-icon">▓</span> Yaylım Ateşi</li>
                        <li data-weapon-id="shrapnel"><span class="weapon-icon">☄️</span> Şarapnel Topu</li>
                    </ul>
                </div>
                <div class="pause-panel kundakci">
                    <h3 data-achievement-id="kundakci">Kundakçı</h3>
                    <ul class="weapon-list">
                        <li data-weapon-id="mortar"><span class="weapon-icon">💣</span> Bomba Atar</li>
                        <li data-weapon-id="flamethrower"><span class="weapon-icon">♨️</span> Alev Püskürtücü</li>
                        <li data-weapon-id="flameTrail"><span class="weapon-icon">👣</span> Alev İzi</li>
                        <li data-weapon-id="flameDance"><span class="weapon-icon">✨</span> Alev Dansı</li>
                    </ul>
                </div>
                <div class="pause-panel teknoloji-meraklisi">
                    <h3 data-achievement-id="teknolojiMeraklisi">Teknoloji Meraklısı</h3>
                    <ul class="weapon-list">
                        <li data-weapon-id="laser"><span class="weapon-icon">〰</span> Lazer Işını</li>
                        <li data-weapon-id="chain"><span class="weapon-icon">⚡</span> Zincir Şimşek</li>
                        <li data-weapon-id="missile"><span class="weapon-icon">🚀</span> Güdümlü Füze</li>
                        <li data-weapon-id="pulseCannon"><span class="weapon-icon">💨</span> Darbe Topu</li>
                    </ul>
                </div>
                <div class="pause-panel oyuncak-sever">
                    <h3 data-achievement-id="oyuncakSever">Oyuncak Sever</h3>
                    <ul class="weapon-list">
                        <li data-weapon-id="mines"><span class="weapon-icon">💥</span> Mayın Döşeyici</li>
                        <li data-weapon-id="turret"><span class="weapon-icon">🗼</span> Taret</li>
                        <li data-weapon-id="drone"><span class="weapon-icon">🤖</span> Savaş Dronu</li>
                        <li data-weapon-id="roboSpider"><span class="weapon-icon">🕷️</span> Robo-Örümcek</li>
                    </ul>
                </div>
            </div>
            <div class="menu-buttons">
                <button id="resumeButton" class="menu-button">DEVAM ET</button>
                <button id="restartFromPauseButton" class="menu-button">YENİDEN BAŞLAT</button>
                <button id="mainMenuFromPauseButton" class="menu-button">ANA MENÜYE DÖN</button>
            </div>
        </div>
    </div>

    <div id="lootBoxAnimationContainer" style="display: none;">
        <div id="lootBoxChest">
            <div class="chest-lid"></div>
            <div class="chest-base"></div>
        </div>
    </div>

    <div id="vehicleTooltip" class="vehicle-tooltip"></div>
    <div id="weaponTooltip" class="vehicle-tooltip"></div>
    
    <!-- Controls Modal -->
    <div id="controlsModal" class="pause-menu" style="display: none; z-index: 2020;">
        <h2>KONTROLLER</h2>
        <div class="controls-grid" style="grid-template-columns: 1fr 1fr; gap: 10px 20px; text-align: left; max-width: 500px; margin: 20px auto 30px auto;">
            <p><strong>W/S:</strong> İleri/Geri</p>
            <p><strong>A/D:</strong> Dönüş (Tank) / Kayma (Helikopter)</p>
            <p><strong>SHIFT:</strong> Hızlanma</p>
            <p><strong>SPACE:</strong> Kalkan</p>
            <p><strong>E:</strong> Farlar (Tank)</p>
            <p><strong>M:</strong> Harita</p>
            <p><strong>ESC:</strong> Duraklat</p>
            <p><strong>R:</strong> Yeniden Başlat</p>
        </div>
        <button id="closeControlsButton" class="menu-button">KAPAT</button>
    </div>


    <!-- Veri Sıfırlama Onay Modalı -->
    <div id="resetConfirmModal" class="pause-menu" style="display: none; z-index: 2030; max-width: 600px; border-color: #ff5555; color: #ff5555;">
        <h2>UYARI</h2>
        <p style="color: #e0e0e0; text-shadow: none; font-size: 1.2em; line-height: 1.6;">
            Tüm ilerlemeniz (kazanılan para, açılan araçlar ve yükseltmeler) kalıcı olarak silinecektir.<br>
            <strong>Bu işlem geri alınamaz.</strong> Emin misiniz?
        </p>
        <div class="modal-buttons" style="display: flex; justify-content: space-between; align-items: center; margin-top: 30px;">
            <button id="confirmResetButton" class="menu-button" style="background-color: #c00; border-color: #c00; color: #fff;">EVET, SIFIRLA</button>
            <button id="cancelResetButton" class="menu-button">İPTAL</button>
        </div>
    </div>


    <!-- Kolay Mod Uyarı Modalı -->
    <div id="easyModeConfirmModal" style="display: none;">
        <h2>UYARI</h2>
        <p>Bu modda para kazanamaz ve kalıcı geliştirmeleri kullanamazsınız.<br>Bu mod sadece pratik yapmak içindir.</p>
        <div class="modal-buttons">
            <button id="confirmEasyModeButton" class="difficulty-button">Devam Et</button>
            <button id="cancelEasyModeButton" class="menu-button">İptal</button>
        </div>
    </div>

    <script>
        // Canvas and UI elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const scoreEl = document.querySelector('#score span');
        const healthTextEl = document.getElementById('health-text');
        const levelValueEl = document.getElementById('level-value');
        const xpBarEl = document.getElementById('xp-bar');
        const dashSkillEl = document.getElementById('dashSkill');
        const shieldSkillEl = document.getElementById('shieldSkill');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const finalScoreEl = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const levelUpScreen = document.getElementById('levelUpScreen');
        const upgradeOptionsContainer = document.getElementById('upgrade-options');
        const weaponUIContainer = document.getElementById('weapon-ui');
        const levelUpInfoEl = document.getElementById('levelUpInfo');
        const scoreboardEl = document.getElementById('scoreboard');
        const gameTimerEl = document.getElementById('gameTimer');
        const pauseMenuEl = document.getElementById('pauseMenu');
        const resumeButton = document.getElementById('resumeButton');
        const restartFromPauseButton = document.getElementById('restartFromPauseButton');
        const pauseButton = document.getElementById('pauseButton');
        const mapButton = document.getElementById('mapButton');
        const bossBarsWrapper = document.getElementById('bossBarsWrapper');
        const flagCounterEl = document.querySelector('#flag-counter span');
        const moneyEl = document.querySelector('#money span');
        const rerollButton = document.getElementById('rerollButton');
        const skipButton = document.getElementById('skipButton');
        const achievementToast = document.getElementById('achievement-toast');
        const achievementTitle = document.getElementById('achievement-title');
        const achievementDesc = document.getElementById('achievement-desc');
        const discardWeaponScreen = document.getElementById('discardWeaponScreen');
        const discardWeaponOptions = document.getElementById('discard-weapon-options');
        const cancelDiscardButton = document.getElementById('cancelDiscardButton');
        const lootBoxAnimationContainer = document.getElementById('lootBoxAnimationContainer');
        const lootBoxChest = document.getElementById('lootBoxChest');
        const damageOverlay = document.getElementById('damageOverlay');
        const mapHintEl = document.getElementById('mapHint');
        const topHeadBandEl = document.getElementById('top-head-band');
        const dashboardEl = document.getElementById('dashboard');
        const mainMenuEl = document.getElementById('mainMenu');
        const easyModeButton = document.getElementById('easyModeButton');
        const normalModeButton = document.getElementById('normalModeButton');
        const totalMoneyDisplayEl = document.querySelector('#totalMoneyDisplay span');
        const buyArmorUpgradeButton = document.getElementById('buyArmorUpgradeButton');
        const maxArmorSlotsContainer = document.getElementById('maxArmorSlots');
        const buyShieldUpgradeButton = document.getElementById('buyShieldUpgradeButton');
        const maxShieldSlotsContainer = document.getElementById('maxShieldSlots');
        const buyDashUpgradeButton = document.getElementById('buyDashUpgradeButton');
        const maxDashSlotsContainer = document.getElementById('maxDashSlots');
        const armorUpgradeCostEl = document.getElementById('armorUpgradeCost');
        const shieldUpgradeCostEl = document.getElementById('shieldUpgradeCost');
        const dashUpgradeCostEl = document.getElementById('dashUpgradeCost');
        const buyAttackSpeedUpgradeButton = document.getElementById('buyAttackSpeedUpgradeButton');
        const maxAttackSpeedSlotsContainer = document.getElementById('maxAttackSpeedSlots');
        const attackSpeedUpgradeCostEl = document.getElementById('attackSpeedUpgradeCost');
        const easyModeConfirmModal = document.getElementById('easyModeConfirmModal');
        const confirmEasyModeButton = document.getElementById('confirmEasyModeButton');
const cancelEasyModeButton = document.getElementById('cancelEasyModeButton');
const controlsButton = document.getElementById('controlsButton');
const controlsModal = document.getElementById('controlsModal');
const closeControlsButton = document.getElementById('closeControlsButton');
const magazineDisplayEl = document.getElementById('magazine-display');
const activeQuestUI = document.getElementById('activeQuestUI');
const questTextEl = document.getElementById('questText');
const resetDataButton = document.getElementById('resetDataButton');
const resetConfirmModal = document.getElementById('resetConfirmModal');
const confirmResetButton = document.getElementById('confirmResetButton');
const cancelResetButton = document.getElementById('cancelResetButton');
const showVehiclesTab = document.getElementById('showVehiclesTab');
const showUpgradesTab = document.getElementById('showUpgradesTab');
const vehiclesContent = document.getElementById('vehiclesContent');
const upgradesContent = document.getElementById('upgradesContent');


        // --- AUDIO ---
        let audioCtx;
        let isAudioInitialized = false;

        function initAudio() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    isAudioInitialized = true;
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser");
                }
            }
        }

        function playSound(type) {
            if (!audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'hover':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5
                    gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'click':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // A4
                    oscillator.frequency.exponentialRampToValueAtTime(220, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'purchase':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
                    oscillator.frequency.exponentialRampToValueAtTime(1046.50, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.12, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'error':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;
            }
        }
        
        // Game variables
        let playerName = 'Pilot';
        let score = 0, isGameOver = false, gamePaused = false, isMapView = false, isBossActive = false;
        let totalMoney = 0;
        let discoveredWeapons = ['defaultGun'];
        let unlockedAchievements = [];
        let allVehicleUpgrades = {};
        const ARMOR_UPGRADE_COSTS = [3, 6, 12, 21, 30];
        const ARMOR_BONUS_PER_LEVEL = 10;
        const SHIELD_UPGRADE_COSTS = [3, 9, 15, 24, 36];
        const SHIELD_BONUS_PER_LEVEL = 30; // 0.5 saniye @ 60fps
        const DASH_UPGRADE_COSTS = [3, 9, 15, 24, 36];
        const DASH_BONUS_PER_LEVEL = 20; // 0.33 saniye @ 60fps
        const ATTACK_SPEED_UPGRADE_COSTS = [6, 12, 18, 27, 39];
        const ATTACK_SPEED_BONUS_PER_LEVEL = 5; // 5 frame cooldown reduction

        let unlockedVehicles = ['Ejder Yalçın'];
        let selectedVehicle = 'Ejder Yalçın';
        const VEHICLES = {
            'ALTAY': { 
                name: 'ALTAY', 
                icon: '■-■', 
                price: 110, 
                type: 'tank', 
                health: 120, 
                speed: 2.5, 
                width: 42, 
                height: 52, 
                color: '#c2b280', 
                turretColor: '#8a7e5a',
                description: "Türkiye'nin ilk milli ana muharebe tankı projesi olan Altay, BMC tarafından üretilmektedir. Gelişmiş atış kontrol sistemleri, yüksek hareket kabiliyeti ve modern zırh korumasıyla dikkat çeker."
            },
            'TULPAR': { 
                name: 'TULPAR', 
                icon: '-▫-', 
                price: 20, 
                type: 'tank', 
                health: 100, 
                speed: 3.0, 
                width: 38, 
                height: 48, 
                color: '#78866b', 
                turretColor: '#545d4b',
                description: "Otokar tarafından geliştirilen Tulpar, yeni nesil bir piyade savaş aracıdır. Yüksek balistik ve mayın koruması, modüler yapısı ve farklı silah sistemleriyle donatılabilme özelliği sayesinde modern orduların ihtiyaçlarına cevap verir."
            },
            'KAPLAN STA': { 
                name: 'KAPLAN STA', 
                icon: 'ʌ-ʌ', 
                price: 50, 
                type: 'tank', 
                health: 85, 
                speed: 3.5, 
                width: 35, 
                height: 45, 
                color: '#555555', 
                turretColor: '#333333',
                description: "FNSS tarafından üretilen Kaplan, modern bir tanksavar aracıdır. Üzerinde taşıdığı tanksavar füzeleri ile düşman zırhlı birliklerine karşı etkili bir güç oluşturur. Düşük silüeti ve yüksek hareket kabiliyeti ile öne çıkar."
            },
            'T129 ATAK': { 
                name: 'T129 ATAK', 
                icon: '🚁', 
                price: 90, 
                type: 'helicopter', 
                health: 75, 
                speed: 4.0, 
                width: 30, 
                height: 45, 
                color: '#4a4a4a', 
                turretColor: '#2b2b2b',
                description: "Türk Havacılık ve Uzay Sanayii (TUSAŞ) tarafından üretilen T129 ATAK, taarruz ve taktik keşif helikopteridir. Sıcak hava ve yüksek irtifa koşullarında sergilediği üstün performans, taşıdığı yerli mühimmatlar ve modern aviyonik sistemleriyle öne çıkmaktadır. Hem terörle mücadele operasyonlarında hem de yurt dışı görevlerde etkin bir şekilde kullanılmaktadır."
            },
            'T625 Gökbey': { 
                name: 'T625 Gökbey', 
                icon: '🛸', 
                price: 110, 
                type: 'helicopter', 
                health: 90, 
                speed: 3.8, 
                width: 35, 
                height: 50, 
                color: '#1e90ff', 
                turretColor: '#104e8b',
                description: "Türkiye'nin ilk özgün ve milli genel maksat helikopteri olan Gökbey, yine TUSAŞ tarafından geliştirilmiştir. Hem askeri hem de sivil amaçlarla kullanılabilecek olan Gökbey; personel taşıma, arama-kurtarma, VIP taşıma ve hava ambulansı gibi çok çeşitli görevleri yerine getirebilecek şekilde tasarlanmıştır."
            },
            'ATAK-2': { 
                name: 'ATAK-2', 
                icon: '🔥', 
                price: 120, 
                type: 'helicopter', 
                health: 80, 
                speed: 4.2, 
                width: 32, 
                height: 48, 
                color: '#556B2F', 
                turretColor: '#3B4A20',
                description: "T129 ATAK helikopterinden elde edilen tecrübelerle geliştirilen ATAK-2, daha fazla mühimmat taşıma kapasitesi, daha gelişmiş aviyonik sistemler ve daha güçlü motorlara sahip olacak şekilde tasarlanmaktadır."
            },
            'Ejder Yalçın': {
                name: 'Ejder Yalçın',
                icon: '⛟',
                price: 0,
                type: 'armored',
                health: 90,
                speed: 3.2,
                width: 36,
                height: 46,
                color: '#d2b48c',
                turretColor: '#8b7355',
                description: "Nurol Makina tarafından üretilen Ejder Yalçın, 4x4 segmentinde kendini kanıtlamış bir zırhlı muharebe aracıdır. Farklı görevler için (sınır güvenliği, keşif, komuta-kontrol) kolayca yapılandırılabilen modüler tasarımı ve yüksek koruma seviyesi ile birçok ülkeye ihraç edilmiştir."
            },
            'Cobra II': {
                name: 'Cobra II',
                icon: '🐍',
                price: 30,
                type: 'armored',
                health: 85,
                speed: 3.7,
                width: 34,
                height: 44,
                color: '#556b2f',
                turretColor: '#3b4a20',
                description: "Otokar üretimi olan Cobra II, modüler yapısı, amfibi kabiliyeti ve yüksek beka seviyesi ile dikkat çeker. Farklı silah kuleleri ve görev ekipmanları entegre edilebilen araç, çok yönlü bir platformdur."
            },
            'Arma': {
                name: 'Arma',
                icon: '⛒',
                price: 50,
                type: 'armored',
                health: 110,
                speed: 3.0,
                width: 40,
                height: 50,
                color: '#808080',
                turretColor: '#595959',
                description: "Otokar'ın Arma serisi, modüler ve amfibi özelliklere sahip tekerlekli zırhlı araç ailesidir. Yüksek taşıma kapasitesi ve farklı arazi koşullarındaki üstün performansıyla hem yurt içinde hem de uluslararası pazarda tercih edilmektedir."
            }
        };

        const VEHICLE_BASE_DAMAGE = {
            // Tanks
            'ALTAY': 25,
            'TULPAR': 15,
            'KAPLAN STA': 20,
            // Armored
            'Ejder Yalçın': 1,
            'Cobra II': 2,
            'Arma': 3,
            // Helicopters
            'T129 ATAK': 3,
            'T625 Gökbey': 4,
            'ATAK-2': 5
        };

        const STAT_SCALES = {
            armor: { min: 75, max: 120 },
            speed: { min: 2.5, max: 4.2 },
            dps: { min: 6, max: 20 } // Saniye Başına Hasar için yeni ölçek
        };

        const TIER_3_VEHICLES = {
            'ALTAY': ['TULPAR', 'KAPLAN STA'],
            'Arma': ['Ejder Yalçın', 'Cobra II'],
            'ATAK-2': ['T129 ATAK', 'T625 Gökbey']
        };

        let gameMode = 'normal'; // 'normal' or 'easy'
        let rerollCharges = 3;
        let hasMapUpgrade = false;
        let bullets = [], enemies = [], particles = [], powerups = [], xpOrbs = [], obstacles = [], muzzleFlashes = [], floatingTexts = [], specialProjectiles = [], permanentUpgrades = [], flags = [], npcs = [];
        let weaponDamageStats = {};
        let damageUpdateInterval;
        let enemySpawnTimer = 0, enemySpawnInterval = 120; // Başlangıç spawn aralığı
        let enemyIdCounter = 0;
        let gameTimeInSeconds = 0;
        let bossesSpawned = 0;
        let capturedFlags = 0;
        const bossSpawnTimes = [60, 240, 420]; // 1, 4, 7 minutes
        const mouse = { x: 0, y: 0 };
        const keys = {};
        const world = { width: 16000, height: 12000 };
        const camera = { x: 0, y: 0, width: canvas.width, height: canvas.height };
        const screenShake = { intensity: 0, duration: 0 };
        let nextScalingBossTime = 0;
        let scalingBossSpawnCount = 1;
        let nextBossCountIncreaseTime = 600; // 10 dakika
        let animationFrameId;
        let uiColorState = 'normal'; // 'normal' or 'boss'
        let laserTargetId = null;
        let laserFocusTime = 0;
        let laserCumulativeDamage = 0;
        let modalQueue = [];
        let isModalActive = false;
        let modalBaseZIndex = 1000; // Modalların z-endeksini dinamik olarak yönetmek için
        const SPAWN_PADDING = 50; // Nesneler arasında bırakılacak minimum boşluk
        let nextPrisonerScoreReward = 100;
        let nextPrisonerXpReward = 50;
        let prisonersRescuedCount = 0;
        const PRISONER_DIALOGUE = [
            "Yardım et!", "Buradayım!", "Kurtar beni!", "Acele et!", "Beni burada bırakma!",
            "Dışarı çıkarın beni!", "Hey! Tank!", "Bu taraftayım!", "Unutulduk sandım!",
            "Geliyorlar!", "Dikkat et!", "Kahramanımız geldi!", "Çabuk ol!", "Beni al!", "Teşekkürler!"
        ];
        
        // Final Phase Variables
        let isFinalPhase = false;
        let fireWallRadius;
        let escapePlane = null;


        // Pathfinding Grid
        const GRID_SIZE = 50;
        let grid = [];

        // Player tank object
        const player = {
            type: 'tank', // Will be updated by selected vehicle
            vehicleType: 'ALTAY',
            x: world.width / 2, y: world.height / 2, width: 40, height: 50,
            color: '#00cc66', turretColor: '#00aa55', angle: 0, turretAngle: 0,
            isHit: false, hitTimer: 0, health: 100,
            maxHealth: 100, speed: 2.5, damageBonus: 0, healthRegen: 0, xpGainMultiplier: 1.0,
            level: 1, xp: 0, xpToNextLevel: 100,
            weapons: {}, weaponCooldowns: {},
            magazine: 30,
            maxMagazine: 30,
            isReloading: false,
            reloadTime: 120, // 2 saniye
            reloadTimer: 0,
            dashFuel: 120, maxDashFuel: 120, // 120 kare = 2 saniye
            isBoosting: false,
            headlightsOn: false, // Işıklar başlangıçta kapalı
            isShielded: false, shieldTimer: 0, shieldDuration: 180, shieldCooldown: 600, shieldCooldownTimer: 0,
            isMoving: false,
            trackSpawnTimer: 0,
            rotorAngle: 0, rotorSpeed: 0.3, // For helicopters
            // Achievement bonuses
            damageBonusMultiplier: 1,
            fireRateBonus: 1,
            damageReduction: 1,
            defaultGunCooldownBonus: 0,
        };
        
        // --- ACHIEVEMENT SYSTEM ---
        const ACHIEVEMENT_SETS = {
            mermiManyagi: {
                name: "Mermi Manyağı",
                weapons: ['defaultGun', 'railgun', 'shotgun', 'barrage', 'shrapnel'],
                description: "Bütün silahların hasarı 2 kat arttı.",
                applyBonus: () => { player.damageBonusMultiplier = 2; },
                isApplied: false
            },
            kundakci: {
                name: "Kundakçı",
                weapons: ['mortar', 'flamethrower', 'flameTrail', 'flameDance'],
                description: "Aleve dokunan düşmanlarda kalıcı olarak yanma efekti uygulanır.",
                applyBonus: () => { /* Logic is handled in weapon fire functions */ },
                isApplied: false
            },
            teknolojiMeraklisi: {
                name: "Teknoloji Meraklısı",
                weapons: ['laser', 'chain', 'missile', 'pulseCannon'],
                description: "Saldırı hızı iki katına çıktı.",
                applyBonus: () => { player.fireRateBonus = 0.5; },
                isApplied: false
            },
            oyuncakSever: {
                name: "Oyuncak Sever",
                weapons: ['mines', 'turret', 'drone', 'roboSpider'],
                description: "Aldığın hasar yarıya iner.",
                applyBonus: () => { player.damageReduction = 0.5; },
                isApplied: false
            }
        };

        function checkAchievements() {
            const ownedWeapons = new Set(Object.keys(player.weapons));
            for (const key in ACHIEVEMENT_SETS) {
                const achievement = ACHIEVEMENT_SETS[key];
                if (!achievement.isApplied) {
                    const hasAllWeapons = achievement.weapons.every(w => ownedWeapons.has(w));
                    if (hasAllWeapons) {
                        unlockAchievement(key);
                    }
                }
            }
        }

        function unlockAchievement(key) {
            const achievement = ACHIEVEMENT_SETS[key];
            if (!achievement.isApplied) {
                achievement.isApplied = true;
                achievement.applyBonus();
                showAchievementToast(achievement.name, achievement.description);
                if (!unlockedAchievements.includes(key)) {
                    unlockedAchievements.push(key);
                    saveUnlockedAchievements();
                }
            }
        }

        function showAchievementToast(title, desc) {
            achievementTitle.textContent = `BAŞARIM: ${title}`;
            achievementDesc.textContent = desc;
            achievementToast.classList.add('show');
            setTimeout(() => {
                achievementToast.classList.remove('show');
            }, 5000);
        }

        // --- Drawing Functions ---

        function drawUnit(unit) {
             ctx.save();
             ctx.translate(unit.x, unit.y);
             ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;

            if (unit.type === 'helicopter' && unit !== player) { // Player helicopter is handled separately
                ctx.rotate(unit.angle - Math.PI / 2);
                const w2 = unit.width / 2;
                const h2 = unit.height / 2;

                // --- Draw based on color ---
                ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;

                switch (unit.color) {
                    case '#ff9933': // Orange - Attack Copter
                        // Tail
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-w2 * 2.5, -h2 * 0.1, w2 * 1.5, h2 * 0.2);
                        ctx.fillRect(-w2 * 2.5, -h2 * 0.4, w2 * 0.2, h2 * 0.8);
                        // Body
                        ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, w2 * 1.5, h2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Cockpit
                        ctx.fillStyle = 'rgba(0, 200, 255, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(w2, 0, w2 * 0.6, h2 * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Stub wings for weapons
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-w2 * 0.5, -h2 * 1.5, w2, h2 * 0.4);
                        ctx.fillRect(-w2 * 0.5, h2 * 1.1, w2, h2 * 0.4);
                        break;
                    
                    case '#cc33ff': // Purple - Heavy Gunship
                        // Tail
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-w2 * 2, -h2 * 0.2, w2, h2 * 0.4);
                        // Body
                        ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                        ctx.fillRect(-w2 * 1.5, -h2, unit.width * 1.5, unit.height);
                        // Weapon pods
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-w2, -h2 * 1.5, w2 * 2, h2 * 0.5);
                        ctx.fillRect(-w2, h2, w2 * 2, h2 * 0.5);
                        break;

                    case '#ffffff': // White - Sleek Scout
                        // Tail
                        ctx.fillStyle = unit.turretColor;
                        ctx.beginPath();
                        ctx.moveTo(-w2 * 1.2, 0);
                        ctx.lineTo(-w2 * 2.2, -h2 * 0.5);
                        ctx.lineTo(-w2 * 2.2, h2 * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        // Body
                        ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                        ctx.beginPath();
                        ctx.moveTo(w2 * 1.8, 0);
                        ctx.lineTo(-w2, -h2);
                        ctx.lineTo(-w2 * 1.5, 0);
                        ctx.lineTo(-w2, h2);
                        ctx.closePath();
                        ctx.fill();
                        break;

                    case '#00ffff': // Cyan - High Tech
                        // Tail (Fenestron)
                        ctx.fillStyle = unit.turretColor;
                        ctx.beginPath();
                        ctx.arc(-w2 * 2, 0, h2 * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = unit.color;
                        ctx.fillRect(-w2 * 2, -h2 * 0.2, w2, h2 * 0.4);
                        // Body
                        ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                        ctx.beginPath();
                        ctx.moveTo(w2 * 1.5, 0);
                        ctx.lineTo(w2, -h2);
                        ctx.lineTo(-w2 * 1.5, -h2 * 0.8);
                        ctx.lineTo(-w2 * 1.5, h2 * 0.8);
                        ctx.lineTo(w2, h2);
                        ctx.closePath();
                        ctx.fill();
                        break;

                    case '#ffd700': // Gold - Armored Transport
                        // Tail
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-w2 * 2.5, -h2 * 0.25, w2 * 1.5, h2 * 0.5);
                        // Body
                        ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                        ctx.fillRect(-w2 * 1.5, -h2, unit.width * 1.5, unit.height);
                        ctx.fillRect(-w2, -h2 * 1.2, unit.width, unit.height * 0.2);
                        ctx.fillRect(-w2, h2, unit.width, unit.height * 0.2);
                        break;

                    case '#ff69b4': // Pink - Stealth/Elite
                        // Angled Body
                        ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                        ctx.beginPath();
                        ctx.moveTo(w2 * 2, 0); // Pointy nose
                        ctx.lineTo(-w2, -h2);
                        ctx.lineTo(-w2 * 1.8, -h2 * 0.3);
                        ctx.lineTo(-w2 * 1.8, h2 * 0.3);
                        ctx.lineTo(-w2, h2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    
                    default: // Red - Basic
                        // Tail
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-unit.width * 1.4, -3, unit.width, 6);
                        ctx.fillRect(-unit.width * 1.5, -8, 8, 16);
                        // Main body
                        ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, w2 * 1.2, h2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.rotate(-(unit.angle - Math.PI/2));
                // Propeller (same for all)
                ctx.rotate(unit.rotorAngle);
                ctx.fillStyle = 'rgba(180,180,180,0.7)';
                ctx.fillRect(-unit.width, -2, unit.width * 2, 4);
                
            } else if (unit.type === 'motorcycle') {
                ctx.rotate(unit.angle - Math.PI/2);

                // --- BÜTÜNSEL FAR EFEKTİ ---
                ctx.save();

                const lightSourceX = unit.width / 2;
                const lightLength = 120;
                const lightEndSpread = 60; // Işık konisinin sonundaki yarım genişlik

                // Işık hüzmesi için yol (path) oluşturma
                ctx.beginPath();
                ctx.moveTo(lightSourceX, -unit.height / 4); // Farın üst kısmı
                ctx.lineTo(lightSourceX + lightLength, -lightEndSpread); // Uzak-üst nokta
                // Hüzmenin sonunu yuvarlatmak için kuadratik eğri kullan
                ctx.quadraticCurveTo(
                    lightSourceX + lightLength + 20, // Kontrol noktası X (eğriyi dışa doğru iter)
                    0,                               // Kontrol noktası Y (eğrinin merkezi)
                    lightSourceX + lightLength,      // Bitiş noktası X
                    lightEndSpread                   // Bitiş noktası Y (uzak-alt nokta)
                );
                ctx.lineTo(lightSourceX, unit.height / 4); // Farın alt kısmı
                ctx.closePath();

                // Işık hüzmesi için gradyan oluşturma
                const grad = ctx.createLinearGradient(lightSourceX, 0, lightSourceX + lightLength, 0);
                grad.addColorStop(0, 'rgba(255, 255, 224, 0.25)'); // Kaynakta daha parlak
                grad.addColorStop(1, 'rgba(255, 255, 224, 0)');   // Sona doğru kaybolur

                ctx.fillStyle = grad;
                ctx.fill();

                ctx.restore();

                const w2 = unit.width / 2;
                const h2 = unit.height / 2;

                // --- Wheels (drawn for all types) ---
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(-w2, 0, w2 * 0.8, 0, Math.PI * 2); // Rear wheel
                ctx.arc(w2, 0, w2 * 0.8, 0, Math.PI * 2); // Front wheel
                ctx.fill();

                // --- Body (varies by color) ---
                ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                
                switch (unit.color) {
                    case '#ff9933': // Orange - Standard
                        ctx.beginPath();
                        ctx.moveTo(-w2 * 1.5, -h2);
                        ctx.lineTo(w2, -h2);
                        ctx.lineTo(w2 * 1.5, 0);
                        ctx.lineTo(w2, h2);
                        ctx.lineTo(-w2 * 1.5, h2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case '#cc33ff': // Purple - Tough
                        ctx.fillRect(-w2 * 1.2, -h2, unit.width * 1.2, unit.height);
                        // Side armor
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-w2 * 1.2, -h2 * 1.2, unit.width * 1.2, h2 * 0.4);
                        ctx.fillRect(-w2 * 1.2, h2 * 0.8, unit.width * 1.2, h2 * 0.4);
                        break;
                    case '#ffffff': // White - Strong
                        ctx.beginPath();
                        ctx.moveTo(-w2 * 1.5, 0);
                        ctx.lineTo(0, -h2 * 1.2);
                        ctx.lineTo(w2 * 1.5, 0);
                        ctx.lineTo(0, h2 * 1.2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case '#00ffff': // Cyan - Advanced
                        ctx.fillRect(-w2, -h2, unit.width, unit.height);
                        // Fins
                        ctx.fillStyle = unit.turretColor;
                        ctx.beginPath();
                        ctx.moveTo(-w2, -h2);
                        ctx.lineTo(-w2 * 1.5, -h2 * 1.5);
                        ctx.lineTo(-w2 * 1.2, -h2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(-w2, h2);
                        ctx.lineTo(-w2 * 1.5, h2 * 1.5);
                        ctx.lineTo(-w2 * 1.2, h2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case '#ffd700': // Gold - Veteran
                        ctx.fillRect(-w2 * 1.2, -h2, unit.width * 1.2, unit.height);
                        // Gold trim
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-w2 * 1.3, -h2, 5, unit.height);
                        ctx.fillRect(w2 * 1.2, -h2, 5, unit.height);
                        break;
                    case '#ff69b4': // Pink - Elite
                         ctx.beginPath();
                         ctx.moveTo(w2 * 1.5, 0); // Nose
                         ctx.lineTo(-w2, -h2 * 1.2);
                         ctx.lineTo(-w2 * 1.5, 0);
                         ctx.lineTo(-w2, h2 * 1.2);
                         ctx.closePath();
                         ctx.fill();
                        break;
                    default: // Red - Basic
                        ctx.fillRect(-w2, -h2, unit.width, unit.height);
                        break;
                }


                // --- Headlight Visual (on top of body) ---
                ctx.fillStyle = "#ffffaa";
                ctx.fillRect(w2, -h2/2, 10, h2);

            } else if (unit.type === 'boss') {
                ctx.rotate(unit.angle - Math.PI); // Rotated 90 degrees left
                const w = unit.width * 0.8;
                const h = unit.height * 0.8;

                // --- Draw Arms/Legs (drawn first to be in the background) ---
                ctx.fillStyle = unit.isHit ? '#fff' : '#E74C3C'; // Main arm color
                
                // Left Arm Block
                ctx.beginPath();
                ctx.moveTo(-w / 3, -h / 2.2);
                ctx.lineTo(-w / 1.8, -h / 2.5);
                ctx.lineTo(-w / 1.8, h / 2.5);
                ctx.lineTo(-w / 3, h / 2.2);
                ctx.closePath();
                ctx.fill();

                // Right Arm Block
                ctx.beginPath();
                ctx.moveTo(w / 3, -h / 2.2);
                ctx.lineTo(w / 1.8, -h / 2.5);
                ctx.lineTo(w / 1.8, h / 2.5);
                ctx.lineTo(w / 3, h / 2.2);
                ctx.closePath();
                ctx.fill();
                
                // --- Draw Main Body ---
                ctx.fillStyle = unit.isHit ? '#fff' : '#D35400'; // Central body color
                ctx.beginPath();
                ctx.moveTo(0, -h / 2);
                ctx.lineTo(w / 2.8, -h / 4);
                ctx.lineTo(w / 2.8, h / 4);
                ctx.lineTo(0, h / 2);
                ctx.lineTo(-w / 2.8, h / 4);
                ctx.lineTo(-w / 2.8, -h / 4);
                ctx.closePath();
                ctx.fill();

                // --- Details on top ---
                // Visor
                ctx.fillStyle = '#1ABC9C'; // Teal/Green visor
                ctx.beginPath();
                ctx.moveTo(-w / 3.5, -h / 10);
                ctx.lineTo(w / 3.5, -h / 10);
                ctx.lineTo(w / 4, h / 6);
                ctx.lineTo(-w / 4, h / 6);
                ctx.closePath();
                ctx.fill();
                
                // Top head part
                ctx.fillStyle = '#34495E'; // Dark grey
                ctx.beginPath();
                ctx.moveTo(-w / 4, -h / 2.2);
                ctx.lineTo(w / 4, -h / 2.2);
                ctx.lineTo(w / 5, -h / 2 - 10);
                ctx.lineTo(-w / 5, -h / 2 - 10);
                ctx.closePath();
                ctx.fill();

                // Antennae
                ctx.strokeStyle = '#2C3E50'; // Darker grey
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(-w / 10, -h / 2 - 10);
                ctx.lineTo(-w / 8, -h / 2 - 20);
                ctx.moveTo(w / 10, -h / 2 - 10);
                ctx.lineTo(w / 8, -h / 2 - 20);
                ctx.stroke();

                // Thrusters
                ctx.fillStyle = '#3498DB'; // Blue
                ctx.fillRect(-w / 1.8 + 2, h / 2.5, 16, 10);
                ctx.fillRect(w / 1.8 - 18, h / 2.5, 16, 10);
            
            } else if (unit.type === 'kule') {
                // Base - no rotation needed
                ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                ctx.fillRect(-unit.width / 2, -unit.height / 2, unit.width, unit.height);
                ctx.fillStyle = '#666'; // Inner part
                ctx.fillRect(-unit.width/2 + 4, -unit.height/2 + 4, unit.width - 8, unit.height - 8);

                // Turret - rotates
                ctx.rotate(unit.turretAngle);
                ctx.fillStyle = unit.turretColor;
                ctx.fillRect(-6, -6, 12, 12); // Turret base
                ctx.fillRect(-3, -25, 6, 25); // Barrel
                ctx.rotate(-unit.turretAngle); // un-rotate to be safe
            } else if (unit.type === 'prisoner') {
                // Konseptle uyumlu izometrik mahkum çizimi
                ctx.rotate(unit.angle);

                const bodyWidth = 14;
                const bodyHeight = 22;
                const headRadius = 7;
                const skinColor = '#f0d2a0'; // Ten rengi
                const darkJumpsuitColor = '#d4a22a'; // Detaylar için daha koyu sarı
                const shadowOffsetY = bodyHeight / 2; 

                // 1. Gölge (ilk olarak çizilir, altta kalması için)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(0, shadowOffsetY, bodyWidth / 1.5, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // 2. Gövde (Tulum)
                ctx.fillStyle = unit.color; // Ana sarı renk
                ctx.fillRect(-bodyWidth / 2, -bodyHeight / 2, bodyWidth, bodyHeight);

                // 3. Basit bir yaka detayı
                ctx.fillStyle = darkJumpsuitColor;
                ctx.fillRect(-bodyWidth / 2, -bodyHeight / 2, bodyWidth, 4);

                // 4. Kafa (Gövdenin üzerinde)
                ctx.fillStyle = skinColor;
                ctx.beginPath();
                // Kafayı gövdenin merkezinden biraz 'yukarı' konumlandır
                ctx.arc(0, -bodyHeight / 2, headRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // 5. Kurtarma İlerleme Çubuğu
                if (unit.rescueTimer > 0) {
                    const RESCUE_TIME = 60; // 1 saniye
                    const barWidth = 20;
                    const barHeight = 4;
                    const barYOffset = - (bodyHeight / 2) - headRadius - 8; // Kafanın üstünde

                    // Arka Plan Çubuğu
                    ctx.fillStyle = '#555';
                    ctx.fillRect(-barWidth / 2, barYOffset, barWidth, barHeight);

                    // İlerleme Çubuğu
                    const progress = unit.rescueTimer / RESCUE_TIME;
                    ctx.fillStyle = '#00ff88'; // CRT yeşili
                    ctx.fillRect(-barWidth / 2, barYOffset, barWidth * progress, barHeight);
                }


            } else if ((unit.type === 'armored' || (unit === player && player.type === 'armored'))) {
                ctx.rotate(unit.angle);
                const w2 = unit.width / 2;
                const h2 = unit.height / 2;

                // Farların ışık konisi (sadece oyuncu için)
                if (unit === player && player.headlightsOn) {
                    ctx.save();
                    const lightSourceY = -h2; // Aracın önü
                    const lightLength = 150;
                    const lightEndSpread = 80;

                    ctx.beginPath();
                    ctx.moveTo(-w2 + 5, lightSourceY);
                    ctx.lineTo(-lightEndSpread, lightSourceY - lightLength);
                    ctx.quadraticCurveTo(0, lightSourceY - lightLength - 20, lightEndSpread, lightSourceY - lightLength);
                    ctx.lineTo(w2 - 5, lightSourceY);
                    ctx.closePath();

                    const grad = ctx.createLinearGradient(0, lightSourceY, 0, lightSourceY - lightLength);
                    grad.addColorStop(0, 'rgba(255, 255, 224, 0.25)');
                    grad.addColorStop(1, 'rgba(255, 255, 224, 0)');
                    ctx.fillStyle = grad;
                    ctx.fill();
                    ctx.restore();
                }

                // --- Wheels ---
                ctx.fillStyle = '#2d2d2d';
                const wheelWidth = unit.width * 0.3;
                const wheelHeight = unit.height * 0.25;
                const wheelInsetX = w2 * 0.9;
                const wheelInsetY = h2 * 0.9;
                // Rear wheels
                ctx.fillRect(-wheelInsetX, wheelInsetY - wheelHeight, wheelWidth, wheelHeight);
                ctx.fillRect(wheelInsetX - wheelWidth, wheelInsetY - wheelHeight, wheelWidth, wheelHeight);
                // Front wheels
                ctx.fillRect(-wheelInsetX, -wheelInsetY, wheelWidth, wheelHeight);
                ctx.fillRect(wheelInsetX - wheelWidth, -wheelInsetY, wheelWidth, wheelHeight);


                // --- Body ---
                ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                ctx.fillRect(-w2, -h2, unit.width, unit.height);

                // --- Details based on color/name ---
                ctx.fillStyle = unit.turretColor;
                switch (unit.color) {
                    case '#d2b48c': // Ejder Yalçın
                        // Armored plates
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(-w2 * 0.7, -h2, w2 * 1.4, h2 * 0.2);
                        ctx.fillRect(-w2, -h2 * 0.5, w2 * 0.2, h2);
                        ctx.fillRect(w2 * 0.8, -h2 * 0.5, w2 * 0.2, h2);
                        ctx.globalAlpha = 1.0;
                        break;
                    case '#556b2f': // Cobra II
                        // Angled front
                        ctx.beginPath();
                        ctx.moveTo(-w2, -h2);
                        ctx.lineTo(w2, -h2);
                        ctx.lineTo(w2 * 0.8, -h2 * 0.5);
                        ctx.lineTo(-w2 * 0.8, -h2 * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case '#808080': // Arma
                        // Side boxes
                         ctx.globalAlpha = 0.6;
                        ctx.fillRect(-w2 - 4, -h2 * 0.6, 4, h2 * 1.2);
                        ctx.fillRect(w2, -h2 * 0.6, 4, h2 * 1.2);
                         ctx.globalAlpha = 1.0;
                        break;
                }

                // --- Windshield ---
                ctx.fillStyle = 'rgba(150, 200, 255, 0.4)';
                ctx.fillRect(-w2 * 0.7, -h2 * 0.9, w2 * 1.4, h2 * 0.4);
                ctx.strokeStyle = 'rgba(200, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(-w2 * 0.7, -h2 * 0.9, w2 * 1.4, h2 * 0.4);

                // Far detayları (sadece oyuncu için)
                if (unit === player) {
                    ctx.fillStyle = "#ffffaa";
                    ctx.fillRect(-w2 + 5, -h2 - 3, 10, 6);
                    ctx.fillRect(w2 - 15, -h2 - 3, 10, 6);
                }
                
                // --- Roof Machine Gun ---
                ctx.rotate(-unit.angle); // un-rotate body rotation
                ctx.rotate(unit.turretAngle); // apply turret rotation
                ctx.fillStyle = unit.turretColor;
                ctx.fillRect(-6, -8, 12, 12); // Small turret base
                // Çift namlulu yapı
                ctx.fillRect(-5, -25, 3, 18); // Sol namlu
                ctx.fillRect(2, -25, 3, 18); // Sağ namlu
            } else { // Tank
                ctx.rotate(unit.angle);
                ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;

                // Oyuncuya özel detaylar
                if (unit === player) {
                    // Farların ışık konisi (sadece açıkken ve tank ise)
                    if (player.headlightsOn && player.type === 'tank') {
                        ctx.save();

                        const lightSourceY = -unit.height / 2;
                        const lightLength = 150;
                        const lightEndSpread = 80;

                        // Işık hüzmesi için yol (path) oluşturma
                        ctx.beginPath();
                        ctx.moveTo(-unit.width / 2 + 5, lightSourceY); // Sol farın dış kenarı
                        ctx.lineTo(-lightEndSpread, lightSourceY - lightLength); // Uzak-sol nokta
                        // Hüzmenin sonunu yuvarlatmak için kuadratik eğri kullan
                        ctx.quadraticCurveTo(
                            0,                               // Kontrol noktası X (eğrinin merkezi)
                            lightSourceY - lightLength - 20, // Kontrol noktası Y (eğriyi dışa doğru iter)
                            lightEndSpread,                  // Bitiş noktası X
                            lightSourceY - lightLength       // Bitiş noktası Y (uzak-sağ nokta)
                        );
                        ctx.lineTo(unit.width / 2 - 5, lightSourceY); // Sağ farın dış kenarı
                        ctx.closePath();

                        // Işık hüzmesi için gradyan oluşturma
                        const grad = ctx.createLinearGradient(0, lightSourceY, 0, lightSourceY - lightLength);
                        grad.addColorStop(0, 'rgba(255, 255, 224, 0.25)'); // Kaynakta daha parlak
                        grad.addColorStop(1, 'rgba(255, 255, 224, 0)');   // Sona doğru kaybolur

                        ctx.fillStyle = grad;
                        ctx.fill();

                        ctx.restore();
                    }

                    // Araca göre gövdeyi çiz
                    switch (player.vehicleType) {
                        case 'LEOPARD 2':
                            ctx.fillRect(-unit.width / 2, -unit.height / 2, unit.width, unit.height);
                            ctx.fillStyle = 'rgba(0,0,0,0.2)';
                            ctx.fillRect(-unit.width/2, -unit.height/2 + 5, unit.width, 10);
                            ctx.fillRect(-unit.width/2 + 5, unit.height/2 - 15, unit.width - 10, 5);
                            break;
                        case 'M1 ABRAMS':
                            ctx.beginPath();
                            ctx.moveTo(-unit.width / 2, -unit.height / 2);
                            ctx.lineTo(unit.width / 2, -unit.height / 2);
                            ctx.lineTo(unit.width / 2 - 5, unit.height / 2);
                            ctx.lineTo(-unit.width / 2 + 5, unit.height / 2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.fillRect(-unit.width/2 + 10, -unit.height/2 + 10, unit.width-20, 5);
                            break;
                        case 'T129 ATAK':
                        case 'T625 Gökbey':
                        case 'ATAK-2':
                            ctx.save();
                            // Model sağa bakacak şekilde çizilir, oyunun rotasyon mantığı bunu fareye göre ayarlar.
                            ctx.rotate(-Math.PI / 2); 
                            const w2_p = unit.width / 2;
                            const h2_p = unit.height / 2;

                            // --- Kuyruk Bomu (Tail Boom) ---
                            // İnce bir yamuk
                            ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                            ctx.beginPath();
                            ctx.moveTo(-h2_p * 0.5, -w2_p * 0.4); // Gövdeye yakın üst köşe
                            ctx.lineTo(-h2_p * 2.5, -w2_p * 0.2); // Kuyruğun sonu üst köşe
                            ctx.lineTo(-h2_p * 2.5, w2_p * 0.2);  // Kuyruğun sonu alt köşe
                            ctx.lineTo(-h2_p * 0.5, w2_p * 0.4);  // Gövdeye yakın alt köşe
                            ctx.closePath();
                            ctx.fill();

                            // --- Ana Gövde (Main Fuselage) ---
                            // Daha karmaşık bir çokgen
                            ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                            ctx.beginPath();
                            ctx.moveTo(h2_p * 1.3, 0);            // Sivri burun
                            ctx.lineTo(h2_p * 0.7, -w2_p * 0.8);   // Kokpitin üstü
                            ctx.lineTo(-h2_p * 0.6, -w2_p * 0.9);  // Gövdenin arka üstü
                            ctx.lineTo(-h2_p * 0.6, w2_p * 0.9);   // Gövdenin arka altı
                            ctx.lineTo(h2_p * 0.7, w2_p * 0.8);    // Kokpitin altı
                            ctx.closePath();
                            ctx.fill();

                            // --- Kuyruk Yüzgeçleri ---
                            ctx.fillStyle = unit.turretColor;
                            // Dikey Yüzgeç (Vertical Stabilizer)
                            ctx.beginPath();
                            ctx.moveTo(-h2_p * 2.0, -w2_p * 0.2);
                            ctx.lineTo(-h2_p * 2.6, -w2_p * 1.3);
                            ctx.lineTo(-h2_p * 2.3, -w2_p * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            // Yatay Yüzgeç (Horizontal Stabilizer)
                            ctx.beginPath();
                            ctx.moveTo(-h2_p * 2.5, -w2_p * 1.5);
                            ctx.lineTo(-h2_p * 2.1, -w2_p * 1.4);
                            ctx.lineTo(-h2_p * 2.1, w2_p * 1.4);
                            ctx.lineTo(-h2_p * 2.5, w2_p * 1.5);
                            ctx.closePath();
                            ctx.fill();

                            // --- Kokpit Camı ---
                            ctx.fillStyle = 'rgba(150, 200, 255, 0.5)';
                            ctx.strokeStyle = 'rgba(200, 255, 255, 0.7)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(h2_p * 1.25, 0);          // Burun ucu
                            ctx.lineTo(h2_p * 0.7, -w2_p * 0.7);  // Üst köşe
                            ctx.lineTo(h2_p * 0.4, 0);            // Arka orta
                            ctx.lineTo(h2_p * 0.7, w2_p * 0.7);   // Alt köşe
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();

                            // --- Yan Kanatçıklar (Stub Wings) ---
                            ctx.fillStyle = unit.turretColor;
                            // Üst kanatçık (sol taraf)
                            ctx.beginPath();
                            ctx.moveTo(h2_p * 0.2, -w2_p * 0.8);
                            ctx.lineTo(h2_p * 0.4, -w2_p * 2.5);
                            ctx.lineTo(h2_p * 0.1, -w2_p * 2.6);
                            ctx.lineTo(-h2_p * 0.2, -w2_p * 0.9);
                            ctx.closePath();
                            ctx.fill();
                            // Alt kanatçık (sağ taraf)
                            ctx.beginPath();
                            ctx.moveTo(h2_p * 0.2, w2_p * 0.8);
                            ctx.lineTo(h2_p * 0.4, w2_p * 2.5);
                            ctx.lineTo(h2_p * 0.1, w2_p * 2.6);
                            ctx.lineTo(-h2_p * 0.2, w2_p * 0.9);
                            ctx.closePath();
                            ctx.fill();

                            ctx.restore();
                            break;
                        case 'ALTAY':
                        default:
                            ctx.fillRect(-unit.width / 2, -unit.height / 2, unit.width, unit.height);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            const stripeWidth = 5;
                            const stripeOffset = unit.width / 3;
                            ctx.fillRect(-stripeOffset - stripeWidth / 2, -unit.height / 2 - 2, stripeWidth, unit.height + 4);
                            ctx.fillRect(stripeOffset - stripeWidth / 2, -unit.height / 2 - 2, stripeWidth, unit.height + 4);
                            break;
                    }

                    // Tanklar için far ve tampon detayları
                    if (player.type === 'tank') {
                        ctx.fillStyle = "#ffffaa";
                        ctx.fillRect(-unit.width / 2 + 5, -unit.height / 2 - 3, 10, 6);
                        ctx.fillRect(unit.width / 2 - 15, -unit.height / 2 - 3, 10, 6);
                        ctx.fillStyle = "#555";
                        ctx.fillRect(-unit.width / 2 + 5, unit.height / 2, unit.width - 10, 5);
                    }

                } else { // Düşman tankı
                    // Düşman tanklarını renklerine göre farklı çiz
                    const w2 = unit.width / 2;
                    const h2 = unit.height / 2;
                    ctx.fillStyle = unit.isHit ? '#ffffff' : unit.color;
                    ctx.strokeStyle = unit.turretColor;
                    ctx.lineWidth = 2;

                    switch (unit.color) {
                        case '#ff9933': // Orange - Standard
                            ctx.beginPath();
                            ctx.moveTo(-w2, -h2);
                            ctx.lineTo(w2, -h2);
                            ctx.lineTo(w2 * 0.8, h2);
                            ctx.lineTo(-w2 * 0.8, h2);
                            ctx.closePath();
                            ctx.fill();
                            break;
                        case '#cc33ff': // Purple - Tough
                            ctx.beginPath();
                            ctx.moveTo(-w2 * 0.8, -h2);
                            ctx.lineTo(w2 * 0.8, -h2);
                            ctx.lineTo(w2, h2);
                            ctx.lineTo(-w2, h2);
                            ctx.closePath();
                            ctx.fill();
                            // Side pods
                            ctx.fillStyle = unit.turretColor;
                            ctx.fillRect(-w2 - 5, -h2 * 0.5, 5, h2);
                            ctx.fillRect(w2, -h2 * 0.5, 5, h2);
                            break;
                        case '#ffffff': // White - Strong
                            ctx.beginPath();
                            ctx.moveTo(0, -h2);
                            ctx.lineTo(w2, -h2 * 0.3);
                            ctx.lineTo(w2, h2 * 0.8);
                            ctx.lineTo(-w2, h2 * 0.8);
                            ctx.lineTo(-w2, -h2 * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            break;
                        case '#00ffff': // Cyan - Advanced
                            ctx.beginPath();
                            ctx.moveTo(-w2, -h2);
                            ctx.lineTo(w2, -h2);
                            ctx.lineTo(w2, h2);
                            ctx.lineTo(-w2, h2);
                            ctx.closePath();
                            ctx.fill();
                            // Vents
                            ctx.fillStyle = unit.turretColor;
                            ctx.fillRect(-w2*0.6, h2, w2*0.3, 5);
                            ctx.fillRect(w2*0.3, h2, w2*0.3, 5);
                            break;
                        case '#ffd700': // Gold - Veteran
                            ctx.beginPath();
                            ctx.moveTo(-w2, -h2);
                            ctx.lineTo(w2, -h2);
                            ctx.lineTo(w2 + 10, h2);
                            ctx.lineTo(-w2 - 10, h2);
                            ctx.closePath();
                            ctx.fill();
                            // Front spikes
                            ctx.fillStyle = unit.turretColor;
                            ctx.beginPath();
                            ctx.moveTo(-w2, -h2);
                            ctx.lineTo(-w2 - 10, -h2 + 10);
                            ctx.lineTo(-w2, -h2 + 20);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(w2, -h2);
                            ctx.lineTo(w2 + 10, -h2 + 10);
                            ctx.lineTo(w2, -h2 + 20);
                            ctx.closePath();
                            ctx.fill();
                            break;
                        case '#ff69b4': // Pink - Elite
                            ctx.beginPath();
                            ctx.moveTo(0, -h2);
                            ctx.lineTo(w2, -h2/2);
                            ctx.lineTo(w2, h2/2);
                            ctx.lineTo(0, h2);
                            ctx.lineTo(-w2, h2/2);
                            ctx.lineTo(-w2, -h2/2);
                            ctx.closePath();
                            ctx.fill();
                            break;
                        default: // Red - Basic
                            ctx.fillRect(-w2, -h2, unit.width, unit.height);
                            break;
                    }
                }

                ctx.rotate(-unit.angle); // Gövde rotasyonunu geri al
                
                // Taret (hem oyuncu hem de düşman için)
                ctx.rotate(unit.turretAngle);
                ctx.fillStyle = unit.turretColor;
                if (unit === player) {
                    if (player.type === 'helicopter') {
                        ctx.rotate(player.rotorAngle);
                        ctx.fillStyle = 'rgba(180,180,180,0.7)';
                        // 4'lü pervane (uzatılmış)
                        ctx.fillRect(-unit.width * 1.6, -2, unit.width * 3.2, 4);
                        ctx.fillRect(-2, -unit.width * 1.6, 4, unit.width * 3.2);
                        ctx.rotate(-player.rotorAngle); 
                        
                        ctx.fillStyle = unit.turretColor;
                        ctx.fillRect(-6, -6, 12, 12); // Rotor merkezi
                    } else {
                        ctx.fillRect(-12, -20, 24, 30); // Taret tabanı (daha geniş)
                        ctx.fillRect(-2.5, -45, 5, 45); // Taret namlusu (daha uzun)
                    }
                } else {
                     // Düşman taretlerini renklerine göre farklı çiz
                    if (unit.color === '#00ffff') { // Cyan
                        ctx.fillRect(-5, -5, 10, 10); // Base
                        ctx.fillRect(-5, -35, 3, 35); // Left Barrel
                        ctx.fillRect(2, -35, 3, 35); // Right Barrel
                    } else if (unit.color === '#ff69b4') { // Pink
                        ctx.beginPath();
                        ctx.arc(0, -5, 10, 0, Math.PI * 2); // Base
                        ctx.fill();
                        ctx.fillStyle = '#ff0000'; // Glowing eye
                        ctx.beginPath();
                        ctx.arc(0, -15, 5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (unit.color === '#ffd700') { // Gold
                        ctx.fillRect(-8, -8, 16, 16); // Wider Base
                        ctx.fillRect(-4, -40, 8, 40); // Thicker Barrel
                    } else {
                        ctx.fillRect(-5, -5, 10, 10); // Taret tabanı
                        ctx.fillRect(-2.5, -35, 5, 35); // Taret namlusu
                    }
                }
            }
             ctx.restore();

            if (unit.isShielded) { // Only on player
                ctx.beginPath();
                ctx.arc(unit.x, unit.y, unit.width, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 200, 255, 0.3)';
                ctx.strokeStyle = 'rgba(0, 200, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();
            }

            // --- Konuşma Baloncuğunu Çiz ---
            if (unit.currentDialogue && unit.currentDialogue.life > 0) {
                drawSpeechBubble(ctx, unit.x, unit.y - 45, unit.currentDialogue.text, unit.color);
            }
        }
        
        function drawBullet(bullet) {
            if (bullet.shape === 'missile') {
                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                ctx.rotate(bullet.angle);
                const w = bullet.width || 6;
                const h = bullet.height || 14;

                // Gövde
                ctx.fillStyle = bullet.color; // Beyaz
                ctx.beginPath();
                ctx.moveTo(0, -h / 2 - 4); // Sivri burun
                ctx.lineTo(-w / 2, -h / 2);
                ctx.lineTo(-w / 2, h / 2);
                ctx.lineTo(w / 2, h / 2);
                ctx.lineTo(w / 2, -h / 2);
                ctx.closePath();
                ctx.fill();

                // Kanatçıklar
                ctx.fillStyle = '#bbbbbb';
                ctx.fillRect(-w/2 - 3, h/2 - 6, 3, 6);
                ctx.fillRect(w/2, h/2 - 6, 3, 6);
                
                ctx.restore();
            } else {
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSpeechBubble(ctx, x, y, text, color = 'var(--crt-color)') {
            const padding = 10;
            ctx.font = 'bold 16px Orbitron';
            const textMetrics = ctx.measureText(text);
            const textWidth = textMetrics.width;
            const bubbleWidth = textWidth + padding * 2;
            const bubbleHeight = 25 + padding;
            const bubbleX = x - bubbleWidth / 2;
            const bubbleY = y - bubbleHeight;

            let bgColor = 'rgba(0, 20, 10, 0.8)';
            let strokeColor = color;
            let textColor = color;
            
            // Mahkumlar için özel renkler
            if (color === '#ffd700') {
                bgColor = 'rgba(100, 80, 0, 0.8)'; // Koyu, yarı saydam sarı
                strokeColor = '#ffd700'; // Ana kıyafet rengi
                textColor = '#ffd700'; // Ana kıyafet rengi
            }

            ctx.save();
            ctx.globalAlpha = 0.9;
            
            // Bubble Body (rounded rect)
            ctx.fillStyle = bgColor;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bubbleX + 8, bubbleY);
            ctx.lineTo(bubbleX + bubbleWidth - 8, bubbleY);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + 8);
            ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 8);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - 8, bubbleY + bubbleHeight);
            ctx.lineTo(bubbleX + 8, bubbleY + bubbleHeight);
            ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 8);
            ctx.lineTo(bubbleX, bubbleY + 8);
            ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 8, bubbleY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Pointer
            ctx.beginPath();
            ctx.moveTo(x - 8, bubbleY + bubbleHeight - 1);
            ctx.lineTo(x, bubbleY + bubbleHeight + 8);
            ctx.lineTo(x + 8, bubbleY + bubbleHeight - 1);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Text
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x, bubbleY + bubbleHeight / 2);

            ctx.restore();
        }

        function drawSpecialProjectile(proj) {
            if (proj.type === 'laser') {
                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.strokeStyle = proj.color;
                ctx.lineWidth = proj.width;
                ctx.beginPath();
                ctx.moveTo(proj.x, proj.y);
                ctx.lineTo(proj.targetX, proj.targetY);
                ctx.stroke();
                ctx.restore();
            } else if (proj.type === 'mine') {
                // Mayının kendisini çiz (küçük iç daire)
                // Henüz kurulmadıysa, kurulduğunu göstermek için yanıp sönsün.
                const armingPulse = !proj.armed ? Math.abs(Math.sin(proj.armTimer * 0.2)) * 0.5 + 0.5 : 1;
                ctx.fillStyle = '#ff9900';
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, (proj.radius * 0.7) * armingPulse, 0, Math.PI * 2);
                ctx.fill();
    
                // Mayın kurulduysa patlama yarıçapı dairesini çiz
                if (proj.armed) {
                    const pulse = Math.sin(gameTimeInSeconds * 4) * 0.1 + 0.9; // Hafif yanıp sönme efekti
                    ctx.save();
                    ctx.globalAlpha = 0.4;
                    ctx.strokeStyle = '#ff5500';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff5500';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.explosionRadius * pulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            } else if (proj.type === 'chainLightningEffect') {
                ctx.save();
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.globalAlpha = proj.life * 5; // Fade out effect

                for (let i = 0; i < proj.points.length - 1; i++) {
                    const start = proj.points[i];
                    const end = proj.points[i + 1];

                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    
                    // Create a jagged line for lightning effect
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const distance = Math.hypot(dx, dy);
                    const segments = Math.max(5, Math.floor(distance / 20)); // More segments for longer bolts
                    
                    for (let j = 1; j <= segments; j++) {
                        const t = j / segments;
                        let midX = start.x + dx * t;
                        let midY = start.y + dy * t;
                        
                        // Add random offset perpendicular to the line segment
                        if (j < segments) {
                             const offsetX = (Math.random() - 0.5) * 20;
                             const offsetY = (Math.random() - 0.5) * 20;
                             midX += offsetX;
                             midY += offsetY;
                        }

                        ctx.lineTo(midX, midY);
                    }
                    
                    ctx.stroke();
                }

                ctx.restore();
            } else if (proj.type === 'flame') {
                ctx.save();
                ctx.globalAlpha = proj.life;
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            } else if (proj.type === 'forceRing') {
                ctx.save();
                ctx.globalAlpha = proj.life * 2;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 10 * proj.life;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            } else if (proj.type === 'mortarTarget') {
                ctx.save();
                const radius = proj.initialRadius * (proj.life / proj.maxLife);
                ctx.globalAlpha = 0.7;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            } else if (proj.type === 'firePatch') {
                ctx.save();
                ctx.globalAlpha = 0.6 * (proj.life / proj.maxLife);
                for(let i=0; i<5; i++) {
                    const flickerRadius = proj.radius * (0.8 + Math.random() * 0.4);
                    const offsetX = (Math.random() - 0.5) * proj.radius * 0.5;
                    const offsetY = (Math.random() - 0.5) * proj.radius * 0.5;
                    ctx.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100 + 100)}, 0, 0.5)`;
                    ctx.beginPath();
                    ctx.arc(proj.x + offsetX, proj.y + offsetY, flickerRadius / (i + 1), 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            } else if (proj.type === 'turret') {
                const level = player.weapons.turret || 1;
                const range = [350, 400, 450, 500, 550, 575, 600, 625, 650, 700][level-1];
                
                ctx.save();
                ctx.translate(proj.x, proj.y);

                // --- Taban (Altıgen) ---
                const baseRadius = proj.radius * 1.5;
                ctx.fillStyle = '#333';
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    ctx.lineTo(baseRadius * Math.cos(i * Math.PI / 3), baseRadius * Math.sin(i * Math.PI / 3));
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // --- Dönen Platform ---
                ctx.fillStyle = '#5a5a5a';
                ctx.strokeStyle = '#777';
                ctx.beginPath();
                ctx.arc(0, 0, proj.radius * 1.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();


                // --- Taret Namlusu ve Göz ---
                let angleToTarget = proj.lastAngle || 0;
                const closestEnemy = findClosestEnemy(range, proj);
                if (closestEnemy) {
                    angleToTarget = Math.atan2(closestEnemy.y - proj.y, closestEnemy.x - proj.x) + Math.PI / 2;
                    proj.lastAngle = angleToTarget;
                }
                ctx.rotate(angleToTarget);

                // Namlu Tabanı
                ctx.fillStyle = '#777';
                ctx.fillRect(-6, -6, 12, 18);

                // Namlu
                ctx.fillStyle = '#999';
                ctx.fillRect(-3, -proj.radius * 2.5, 6, proj.radius * 2);
                
                // Namlu Ağzı
                ctx.fillStyle = '#666';
                ctx.fillRect(-5, -proj.radius * 2.8, 10, 4);

                // Parlayan Göz
                const eyeGlow = Math.sin(gameTimeInSeconds * 5) * 5 + 10;
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = eyeGlow;
                ctx.beginPath();
                ctx.arc(0, 5, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            } else if (proj.type === 'drone') {
                ctx.save();
                ctx.translate(proj.x, proj.y);

                const bodySize = proj.radius * 1.8; // Ana gövde boyutu
                const halfBody = bodySize / 2;

                // Gövdeyi kare olarak çiz
                ctx.fillStyle = '#445';
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 8;
                ctx.fillRect(-halfBody, -halfBody, bodySize, bodySize);
                ctx.strokeRect(-halfBody, -halfBody, bodySize, bodySize);

                // Merkezdeki 'göz' veya ışık
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(0, 0, proj.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // 4 köşeye pervaneleri çiz
                const corners = [
                    { x: -halfBody, y: -halfBody },
                    { x: halfBody, y: -halfBody },
                    { x: -halfBody, y: halfBody },
                    { x: halfBody, y: halfBody }
                ];

                const propSize = proj.radius * 1.2;
                
                corners.forEach(corner => {
                    ctx.save();
                    ctx.translate(corner.x, corner.y);
                    ctx.rotate(gameTimeInSeconds * 25); // Hızlı dönüş
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.6)';
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 6;
                    ctx.fillRect(-propSize / 2, -1, propSize, 2); // Pervane kanatları
                    ctx.fillRect(-1, -propSize / 2, 2, propSize);
                    ctx.restore();
                });
                
                ctx.shadowBlur = 0; // Diğer çizimler için gölgeyi sıfırla
                ctx.restore();
            } else if (proj.type === 'roboSpider') {
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.rotate(proj.angle + Math.PI / 2); // Örümceğin ileri bakması için rotasyonu ayarla

                const bodyWidth = proj.radius * 1.2;
                const bodyLength = proj.radius * 2.2;
                const headRadius = proj.radius * 0.8;

                // --- Bacakları Çiz (Gövdenin altında kalması için önce çizilir) ---
                ctx.strokeStyle = '#333'; // Koyu gri bacaklar
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';

                const legAnimSpeed = 20;
                const legReach = proj.radius * 2.5;
                const legSpread = proj.radius * 1.5;

                for (let i = 0; i < 8; i++) {
                    const side = (i < 4) ? -1 : 1; // Sol (-1) veya Sağ (1)
                    const legNum = i % 4;
                    
                    // Bacakların gövdeye bağlandığı nokta
                    const baseX = side * (bodyWidth / 2);
                    const baseY = (legNum - 1.5) * (bodyLength * 0.3);
                    
                    // Yürüme animasyonu için sinüs dalgası
                    const animPhase = (i < 4) ? legNum : 3 - legNum;
                    const animSin = Math.sin(gameTimeInSeconds * legAnimSpeed + animPhase * (Math.PI / 2));
                    
                    // Bacak eklemlerinin konumu
                    const jointX = baseX + side * legSpread;
                    const jointY = baseY + animSin * 10;
                    
                    const footX = baseX + side * (legSpread * 0.5 + Math.abs(animSin) * 5);
                    const footY = baseY + legReach * 0.5 - Math.abs(animSin) * 5;

                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);       // Gövdeye bağlantı
                    ctx.lineTo(jointX, jointY);     // Diz eklemi
                    ctx.lineTo(footX, footY);       // Ayak
                    ctx.stroke();
                }

                // --- Gövde ve Kafa ---
                // Silindir Gövde
                ctx.fillStyle = '#1a1a1a'; // Çok koyu gri / Siyah
                ctx.strokeStyle = '#ff0000'; // Kırmızı kenarlık
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;

                // Canvas'ta roundRect desteği yoksa, elle çizim yap
                if (typeof ctx.roundRect === 'function') {
                    ctx.beginPath();
                    ctx.roundRect(-bodyWidth / 2, -bodyLength / 2, bodyWidth, bodyLength, 5);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // Fallback for browsers without roundRect
                    const r = 5;
                    const x = -bodyWidth / 2, y = -bodyLength / 2, w = bodyWidth, h = bodyLength;
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    ctx.lineTo(x + r, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    ctx.lineTo(x, y + r);
                    ctx.quadraticCurveTo(x, y, x + r, y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }


                // Yuvarlak Kafa
                const headY = -bodyLength / 2;
                ctx.beginPath();
                ctx.arc(0, headY, headRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Göz
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(0, headY, headRadius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function drawParticle(particle) {
            ctx.save();
            ctx.globalAlpha = particle.life;
            ctx.fillStyle = particle.color;
            if (particle.type === 'confetti') {
                ctx.fillRect(particle.x - particle.radius/2, particle.y - particle.radius, particle.radius, particle.radius * 2);
            } else if (particle.type === 'smoke') {
                // Check for a specific color for explosion smoke, otherwise default to grey for damage smoke
                if (particle.color === 'white') {
                    ctx.fillStyle = `rgba(220, 220, 220, ${particle.life * 0.4})`;
                } else {
                    ctx.fillStyle = `rgba(120, 120, 120, ${particle.life * 0.5})`; // Default damage smoke
                }
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            } else if (particle.type === 'boost') {
                ctx.fillStyle = `rgba(173, 216, 230, ${particle.life * 0.7})`; // Light blue
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            } else if (particle.type === 'track') {
                ctx.save();
                ctx.translate(particle.x, particle.y);
                ctx.rotate(particle.angle);
                ctx.fillStyle = `rgba(180, 180, 180, ${particle.life * 0.2})`;
                ctx.fillRect(-particle.width / 2, -particle.height / 2, particle.width, particle.height);
                ctx.restore();
            } else {
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
        
        function drawMuzzleFlash(flash) {
            ctx.save();
            ctx.translate(flash.x, flash.y);
            ctx.rotate(flash.angle);
            ctx.fillStyle = 'rgba(255, 220, 100, ' + flash.life + ')';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, -30);
            ctx.lineTo(10, -30);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawPowerup(powerup) {
            ctx.save();
            ctx.translate(powerup.x, powerup.y);
            ctx.fillStyle = powerup.color;
            ctx.fillRect(-powerup.size/2, -powerup.size/2, powerup.size, powerup.size);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(-powerup.size/2, -powerup.size/2, powerup.size, powerup.size);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(powerup.icon, 0, 1);
            ctx.restore();
        }

        function drawPermanentUpgrade(upgrade) {
            ctx.save();
            ctx.translate(upgrade.x, upgrade.y);
            ctx.fillStyle = upgrade.color;
            ctx.beginPath();
            ctx.arc(0, 0, upgrade.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(upgrade.icon, 0, 1);
            ctx.restore();
        }

        function drawXpOrb(orb) {
            ctx.fillStyle = orb.color || 'rgba(0, 255, 136, 0.7)';
            ctx.beginPath();
            ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawObstacle(obs) {
            ctx.fillStyle = obs.color;
            if (obs.type === 'rect') {
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            } else if (obs.type === 'circle') {
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawFlag(flag) {
            // Draw capture zone
            ctx.save();
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = flag.isCaptured ? '#00ff88' : '#aaaaaa';
            ctx.beginPath();
            ctx.arc(flag.x, flag.y, flag.captureRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Draw progress
            if (!flag.isCaptured && flag.captureProgress > 0) {
                ctx.save();
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.arc(flag.x, flag.y, flag.captureRadius, -Math.PI / 2, -Math.PI / 2 + (flag.captureProgress * Math.PI * 2));
                ctx.stroke();
                ctx.restore();
            }

            // Draw flag pole
            ctx.fillStyle = '#888';
            ctx.fillRect(flag.x - 5, flag.y - 100, 10, 100);
            
            // Draw flag icon
            ctx.font = '60px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🚩', flag.x, flag.y - 100);
        }

        function drawEscapePlane() {
            if (!escapePlane) return;
            const plane = escapePlane;

            // --- Pist (diğer her şeyin arkasına ilk olarak çizilir) ---
            ctx.save();
            const runwayWidth = 250;
            const runwayLength = world.height; // Tüm harita yüksekliğini kapla
            const runwayX = plane.x - runwayWidth / 2;
            const runwayY = 0;

            // Asfalt
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(runwayX, runwayY, runwayWidth, runwayLength);
            
            // Kenar Çizgileri
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 5;
            ctx.setLineDash([]); // Düz çizgi için
            ctx.beginPath();
            ctx.moveTo(runwayX + 15, runwayY);
            ctx.lineTo(runwayX + 15, runwayY + runwayLength);
            ctx.moveTo(runwayX + runwayWidth - 15, runwayY);
            ctx.lineTo(runwayX + runwayWidth - 15, runwayY + runwayLength);
            ctx.stroke();

            // Orta Kesikli Çizgi
            ctx.setLineDash([80, 40]);
            ctx.beginPath();
            ctx.moveTo(plane.x, runwayY);
            ctx.lineTo(plane.x, runwayY + runwayLength);
            ctx.stroke();

            // --- Yanıp Sönen LED Işıklar ---
            const lightSpacing = 120;
            const lightRadius = 6;
            const blinkState = Math.floor(gameTimeInSeconds * 2.5); // Saniyede 2.5 kez yanıp sönsün

            for (let y = 0; y < runwayLength; y += lightSpacing) {
                const isRed = (y / lightSpacing) % 5 === 0; // Her 5 ışıkta bir kırmızı olsun
                let lightOn = false;

                if (isRed) {
                    // Kırmızı ışıklar daha yavaş yanıp sönsün
                    lightOn = Math.floor(gameTimeInSeconds) % 2 === 0;
                } else {
                    // Beyaz ışıklar sıralı yanıp sönsün (kayan efekt)
                    lightOn = (blinkState + Math.floor(y / lightSpacing)) % 2 === 0;
                }

                if (lightOn) {
                    ctx.fillStyle = isRed ? '#ff0000' : '#ffffff';
                    ctx.shadowColor = isRed ? '#ff0000' : '#ffffff';
                    ctx.shadowBlur = 15;

                    // Sol Işık
                    ctx.beginPath();
                    ctx.arc(runwayX, y, lightRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Sağ Işık
                    ctx.beginPath();
                    ctx.arc(runwayX + runwayWidth, y, lightRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }


            ctx.restore();


            // Capture Zone
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(plane.x, plane.y, plane.captureRadius, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();

            // Capture Progress
             if (plane.captureProgress > 0) {
                ctx.save();
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 15;
                ctx.beginPath();
                ctx.arc(plane.x, plane.y, plane.captureRadius, -Math.PI / 2, -Math.PI / 2 + (plane.captureProgress * Math.PI * 2));
                ctx.stroke();
                ctx.restore();
            }

            // Plane Body
            ctx.save();
            ctx.translate(plane.x, plane.y);
            
            // Body
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.ellipse(0, 0, 40, 150, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wings
            ctx.fillStyle = '#a0a0a0';
            ctx.fillRect(-150, -20, 300, 40);
            
            // Tail
            ctx.beginPath();
            ctx.moveTo(0, 100);
            ctx.lineTo(-60, 160);
            ctx.lineTo(60, 160);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }

        function drawFireWall() {
            if (!isFinalPhase) return;
            ctx.save();
            const grad = ctx.createRadialGradient(world.width/2, world.height/2, fireWallRadius, world.width/2, world.height/2, fireWallRadius + 500);
            grad.addColorStop(0, 'rgba(255, 100, 0, 0)');
            grad.addColorStop(0.5, 'rgba(255, 80, 0, 0.4)');
            grad.addColorStop(1, 'rgba(255, 60, 0, 0.8)');
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(world.width/2, world.height/2, fireWallRadius + 500, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        function drawFloatingText(text) {
             ctx.save();
             ctx.globalAlpha = text.isOpaque ? 1.0 : text.life;
             ctx.fillStyle = text.color;
             ctx.font = `${text.size}px Orbitron`;
             ctx.textAlign = 'center';
             ctx.fillText(text.text, text.x, text.y);
             ctx.restore();
        }

        function drawBackground() {
            // Arka plan ızgarası kaldırıldı.
        }

        function drawMinimap() {
            const topBar = document.getElementById('top-head-band');
            const topBarHeight = topBar ? topBar.getBoundingClientRect().bottom : 90;
            const mapRadius = 70;
            const mapX = canvas.width - mapRadius - 25;
            const mapY = topBarHeight + mapRadius + 15; // Position below the top UI
            const minimapViewSize = 1800;
            const scale = (mapRadius * 2) / minimapViewSize;
            
            ctx.save();
            ctx.translate(mapX, mapY);

            // Radar Casing
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.beginPath();
            ctx.arc(0, 0, mapRadius + 10, 0, Math.PI * 2);
            ctx.fill();
            const grad = ctx.createLinearGradient(-mapRadius, -mapRadius, mapRadius, mapRadius);
            grad.addColorStop(0, '#555');
            grad.addColorStop(1, '#222');
            ctx.strokeStyle = grad;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, mapRadius + 8, 0, Math.PI * 2);
            ctx.stroke();

            // Clipping path for radar screen
            ctx.beginPath();
            ctx.arc(0, 0, mapRadius, 0, Math.PI * 2);
            ctx.clip();
            
            // Radar background
            ctx.fillStyle = 'rgba(10, 30, 10, 0.8)';
            ctx.fillRect(-mapRadius, -mapRadius, mapRadius*2, mapRadius*2);
            
            // Radar lines
            ctx.strokeStyle = 'rgba(50, 200, 50, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(0, 0, mapRadius * 0.33, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, mapRadius * 0.66, 0, Math.PI * 2); ctx.stroke();
            ctx.moveTo(-mapRadius, 0); ctx.lineTo(mapRadius, 0);
            ctx.moveTo(0, -mapRadius); ctx.lineTo(0, mapRadius);
            ctx.stroke();

            // Draw assets for player-centered view
            const drawOnMap = (entity, color, size) => {
                const dx = entity.x - player.x;
                const dy = entity.y - player.y;
                if (Math.hypot(dx * scale, dy * scale) < mapRadius) {
                    ctx.fillStyle = color;
                    ctx.fillRect(dx * scale - size / 2, dy * scale - size / 2, size, size);
                }
            };
            
            obstacles.forEach(obs => drawOnMap(obs.type === 'rect' ? {x: obs.x + obs.width / 2, y: obs.y + obs.height / 2} : obs, 'rgba(100,100,100,0.5)', 2));
            powerups.forEach(p => drawOnMap(p, p.color, 4));
            enemies.forEach(e => drawOnMap(e, e.color, 3));
            
            // Player is always in the center
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(0, -4);
            ctx.lineTo(4, 4);
            ctx.lineTo(-4, 4);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawObjectiveIndicators() {
            const objectives = [];

            if (!hasMapUpgrade) {
                // Harita alınmadıysa, SADECE harita güçlendirmesinin yerini göster.
                const mapUpgrade = permanentUpgrades.find(u => u.type === 'map');
                if (mapUpgrade) {
                    objectives.push({ x: mapUpgrade.x, y: mapUpgrade.y, color: mapUpgrade.color, icon: mapUpgrade.icon });
                }
            } else {
                // Harita alındıktan sonra, diğer tüm hedefleri göster.
                flags.filter(f => !f.isCaptured).forEach(f => objectives.push({ x: f.x, y: f.y, color: '#cccccc', icon: '🚩' }));
                permanentUpgrades.forEach(u => objectives.push({ x: u.x, y: u.y, color: u.color, icon: u.icon }));
                if (isFinalPhase && escapePlane && !escapePlane.isCaptured) {
                    objectives.push({ x: escapePlane.x, y: escapePlane.y, color: '#ffd700', icon: '✈️' });
                }
            }

            const topBar = document.getElementById('top-head-band');
            const bottomBar = document.getElementById('dashboard');
            const sidePadding = 30;
            const verticalPadding = 20;

            const topOffset = topBar ? topBar.getBoundingClientRect().bottom : 90;
            const bottomOffset = bottomBar ? bottomBar.offsetHeight : 100;

            objectives.forEach(obj => {
                const screenX = obj.x - camera.x;
                const screenY = obj.y - camera.y;

                // Only draw an indicator if the object is off-screen
                if (screenX > 0 && screenX < canvas.width && screenY > 0 && screenY < canvas.height) {
                    return;
                }

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const angleFromCenter = Math.atan2(screenY - centerY, screenX - centerX);

                // Define the boundaries for the indicators
                const minX = sidePadding;
                const maxX = canvas.width - sidePadding;
                const minY = topOffset + verticalPadding;
                const maxY = canvas.height - bottomOffset - verticalPadding;

                // Center of the safe area
                const safeCenterX = (minX + maxX) / 2;
                const safeCenterY = (minY + maxY) / 2;

                const tanA = Math.tan(angleFromCenter);
                const w = (maxX - minX) / 2;
                const h = (maxY - minY) / 2;

                let finalClampedX, finalClampedY;
                
                // Determine which screen edge the indicator should be on based on the safe area's aspect ratio
                if (Math.abs(h / tanA) <= w) {
                    // It intersects with the top or bottom edge of the safe area
                    finalClampedY = Math.sign(Math.sin(angleFromCenter)) * h;
                    finalClampedX = finalClampedY / tanA;
                } else {
                    // It intersects with the left or right edge of the safe area
                    finalClampedX = Math.sign(Math.cos(angleFromCenter)) * w;
                    finalClampedY = finalClampedX * tanA;
                }

                // Translate position to be relative to the safe area's center, not the canvas center
                finalClampedX += safeCenterX;
                finalClampedY += safeCenterY;

                ctx.save();
                ctx.translate(finalClampedX, finalClampedY);
                ctx.rotate(angleFromCenter);
                
                // Draw arrow body
                ctx.fillStyle = obj.color;
                ctx.globalAlpha = 0.9;
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-40, -20);
                ctx.lineTo(-40, 20);
                ctx.closePath();
                ctx.fill();

                // Draw icon inside the arrow
                ctx.shadowBlur = 0;
                ctx.font = '30px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'black';
                ctx.fillText(obj.icon, -20, 2);
                
                ctx.restore();
            });
        }

        function drawFullScreenMap() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const scaleX = canvas.width / world.width;
            const scaleY = canvas.height / world.height;
            const scale = Math.min(scaleX, scaleY) * 0.7; // Haritayı küçülttük

            const mapDisplayWidth = world.width * scale;
            const mapDisplayHeight = world.height * scale;
            const mapOffsetX = (canvas.width - mapDisplayWidth) / 2;
            const mapOffsetY = (canvas.height - mapDisplayHeight) / 2;

            ctx.save();
            ctx.translate(mapOffsetX, mapOffsetY);
            
            // Draw Map Background
            ctx.fillStyle = '#111';
            ctx.fillRect(0,0, mapDisplayWidth, mapDisplayHeight);
            ctx.strokeStyle = '#333';
            ctx.strokeRect(0,0, mapDisplayWidth, mapDisplayHeight);

            // Draw Runway if map is unlocked
            if (hasMapUpgrade && escapePlane) {
                const runwayWidthOnMap = 250 * scale;
                const runwayXOnMap = (escapePlane.x - 250 / 2) * scale;
                ctx.fillStyle = '#4a4a4a'; // Asphalt color
                ctx.fillRect(runwayXOnMap, 0, runwayWidthOnMap, mapDisplayHeight);
            }

            // Draw Obstacles
            obstacles.forEach(obs => {
                ctx.fillStyle = '#555';
                if (obs.type === 'rect') {
                    ctx.fillRect(obs.x * scale, obs.y * scale, obs.width * scale, obs.height * scale);
                } else if (obs.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(obs.x * scale, obs.y * scale, obs.radius * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw Permanent Upgrades
            permanentUpgrades.forEach(upg => {
                ctx.fillStyle = upg.color;
                ctx.beginPath();
                ctx.arc(upg.x * scale, upg.y * scale, upg.size * 3 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${200 * scale}px Orbitron`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(upg.icon, upg.x * scale, upg.y * scale);
            });

            // Draw Powerups (Health, Magnet, LootBox)
            powerups.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect((p.x - p.size * 5) * scale, (p.y - p.size * 5) * scale, p.size * 10 * scale, p.size * 10 * scale);
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${180 * scale}px Orbitron`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.icon, p.x * scale, p.y * scale);
            });
            
             // Draw Flags
            flags.forEach(flag => {
                ctx.fillStyle = flag.isCaptured ? '#00ff88' : '#aaaaaa';
                ctx.beginPath();
                ctx.arc(flag.x * scale, flag.y * scale, flag.captureRadius * 0.1 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = `bold ${200 * scale}px Orbitron`;
                ctx.fillText('🚩', flag.x * scale, flag.y * scale);
            });

            // Draw Enemies
            enemies.forEach(e => {
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.arc(e.x * scale, e.y * scale, e.width * 2 * scale, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw Escape Plane (before player)
            if (hasMapUpgrade && escapePlane) {
                ctx.fillStyle = '#ffd700';
                ctx.font = `bold ${250 * scale}px Orbitron`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('✈️', escapePlane.x * scale, escapePlane.y * scale);
            }

            // Draw Player
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.x * scale, player.y * scale, player.width * 3 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        // --- Spawning & Map Functions ---

        function createPrison(prisonX, prisonY) {
            const prison = { x: prisonX, y: prisonY, width: 1200, height: 900 };
            const gateSize = 150;
            const fenceWidth = 15;
            const fenceColor = 'rgba(150, 150, 150, 0.7)';

            // Ana Hapishane Binası (Daha küçük ve arkaya yakın)
            const buildingHeight = 250;
            const buildingWidth = 600;
            const buildingX = prison.x + (prison.width - buildingWidth) / 2;
            const buildingY = prison.y + prison.height - buildingHeight - fenceWidth - 50; // Alttan 50px boşluk
            obstacles.push({ type: 'rect', x: buildingX, y: buildingY, width: buildingWidth, height: buildingHeight, color: 'rgba(80, 80, 90, 0.9)' });
            
            // Hapishane Bahçesi Çitleri
            // Üst Çit
            obstacles.push({ type: 'rect', x: prison.x, y: prison.y, width: prison.width, height: fenceWidth, color: fenceColor });
            // Alt Çit
            obstacles.push({ type: 'rect', x: prison.x, y: prison.y + prison.height - fenceWidth, width: prison.width, height: fenceWidth, color: fenceColor });
            // Sol Çit
            obstacles.push({ type: 'rect', x: prison.x, y: prison.y, width: fenceWidth, height: prison.height, color: fenceColor });
            // Sağ Çit (Kapı boşluğu ile)
            obstacles.push({ type: 'rect', x: prison.x + prison.width - fenceWidth, y: prison.y, width: fenceWidth, height: (prison.height - gateSize) / 2, color: fenceColor });
            obstacles.push({ type: 'rect', x: prison.x + prison.width - fenceWidth, y: prison.y + (prison.height + gateSize) / 2, width: fenceWidth, height: (prison.height - gateSize) / 2, color: fenceColor });

            // Kuleleri Ekle
            const turretHealth = 100;
            const turretXP = 50;
            const turretConfig = {
                type: 'kule',
                width: 40, height: 40,
                color: '#888', turretColor: '#555',
                isStationary: true,
                angle: 0, turretAngle: 0,
                speed: 0,
                health: turretHealth, maxHealth: turretHealth, xpValue: turretXP,
                attackRange: 450,
                shootCooldown: 90, shootTimer: 0,
                isHit: false, hitTimer: 0,
                isBurning: false, burnDamage: 0,
                burnDamageAccumulator: 0,
                burnDamageDisplayTimer: 60,
                offScreenTimer: 0,
            };

            const cornerPositions = [
                {x: prison.x, y: prison.y},
                {x: prison.x + prison.width, y: prison.y},
                {x: prison.x, y: prison.y + prison.height},
                {x: prison.x + prison.width, y: prison.y + prison.height},
            ];

            cornerPositions.forEach(pos => {
                enemies.push({
                    ...turretConfig,
                    id: enemyIdCounter++,
                    x: pos.x,
                    y: pos.y,
                });
            });

            // Mahkumları Ekle
            const prisonerConfig = {
                type: 'prisoner',
                color: '#ffd700', // Sarı tulum
                speed: 1,
                width: 20, height: 40, // Çarpışma tespiti için
                rescueTimer: 0,
                prisonArea: prison,
                currentDialogue: null,
                dialogueTimer: Math.random() * 300 + 120 // 2-7 saniye sonra konuşmaya başla
            };
            npcs.push({
                ...prisonerConfig,
                x: prison.x + 100,
                y: prison.y + 100,
                wanderTarget: null,
                wanderTimer: 0
            });
            npcs.push({
                ...prisonerConfig,
                x: prison.x + 150,
                y: prison.y + 200,
                wanderTarget: null,
                wanderTimer: 0
            });

            return prison;
        }

        function generateMap() {
            obstacles = [];
            npcs = []; // Mahkumları temizle

            const prisonCount = 5; // Oluşturulacak hapishane sayısı
            const prisonWidth = 1200;
            const prisonHeight = 900;
            const worldPadding = 500; // Harita kenarlarından boşluk
            const minDistanceBetweenPrisons = 2000; // Hapishaneler arası minimum mesafe
            const playerSafeZone = 2500; // Oyuncu başlangıç alanı etrafındaki güvenli bölge
            const airportSafeZoneRadius = 2000; // Havaalanı etrafındaki korunaklı alanın yarıçapı
            const prisonAreas = [];

            for (let i = 0; i < prisonCount; i++) {
                let x, y;
                let validPosition = false;
                let attempts = 0;

                while (!validPosition && attempts < 100) {
                    // Yastıklı sınırlar içinde rastgele konum oluştur
                    x = worldPadding + Math.random() * (world.width - prisonWidth - worldPadding * 2);
                    y = worldPadding + Math.random() * (world.height - prisonHeight - worldPadding * 2);

                    validPosition = true; // Şimdilik geçerli kabul et

                    // Oyuncu güvenli bölgesini kontrol et
                    const playerStartX = world.width / 2;
                    const playerStartY = world.height / 2 + 300; // restartGame() fonksiyonundaki başlangıç konumu
                    if (Math.hypot((x + prisonWidth / 2) - playerStartX, (y + prisonHeight / 2) - playerStartY) < playerSafeZone) {
                        validPosition = false;
                        attempts++;
                        continue;
                    }

                    // Havaalanı güvenli bölgesini kontrol et
                    const runwayWidth = 250;
                    const runwayBuffer = 1000;
                    const safeZoneLeft = escapePlane.x - (runwayWidth / 2) - runwayBuffer;
                    const safeZoneRight = escapePlane.x + (runwayWidth / 2) + runwayBuffer;
                    const prisonLeft = x;
                    const prisonRight = x + prisonWidth;
                    if (prisonRight > safeZoneLeft && prisonLeft < safeZoneRight) {
                        validPosition = false;
                        attempts++;
                        continue;
                    }

                    // Diğer hapishanelere olan mesafeyi kontrol et
                    for (const prison of prisonAreas) {
                        const dist = Math.hypot((x + prisonWidth / 2) - (prison.x + prison.width / 2), (y + prisonHeight / 2) - (prison.y + prison.height / 2));
                        if (dist < minDistanceBetweenPrisons) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }

                if (validPosition) {
                   prisonAreas.push(createPrison(x, y));
                }
            }


            const obstacleCount = 150;
            const playerSafeZoneObstacle = 300;
            for (let i = 0; i < obstacleCount; i++) {
                let x, y, width, height, radius, isRect;
                let validPosition = false;
                let attempts = 0;

                while (!validPosition && attempts < 100) {
                    isRect = Math.random() < 0.6;
                    if (isRect) {
                        width = Math.random() * 150 + 50;
                        height = Math.random() * 150 + 50;
                        x = Math.random() * (world.width - width);
                        y = Math.random() * (world.height - height);
                    } else {
                        radius = Math.random() * 20 + 10;
                        width = height = radius * 2; // for distance check
                        x = Math.random() * (world.width - width) + radius;
                        y = Math.random() * (world.height - height) + radius;
                    }

                    validPosition = true; // Assume true until proven false

                    // Havaalanı alanına engel spawn olmasını engelle
                    const runwayWidth = 250;
                    const runwayBuffer = 1000;
                    const safeZoneLeft = escapePlane.x - (runwayWidth / 2) - runwayBuffer;
                    const safeZoneRight = escapePlane.x + (runwayWidth / 2) + runwayBuffer;


                    const obsLeft = isRect ? x : x - radius;
                    const obsRight = isRect ? x + width : x + radius;

                    if (obsRight > safeZoneLeft && obsLeft < safeZoneRight) {
                        validPosition = false;
                        attempts++;
                        continue;
                    }

                    // Hapishane alanlarına engel spawn olmasını engelle
                    let isInPrisonArea = false;
                    for (const prison of prisonAreas) {
                        const newObsRight = isRect ? x + width : x + radius;
                        const newObsBottom = isRect ? y + height : y + radius;
                        if (newObsRight > prison.x && x < prison.x + prison.width && newObsBottom > prison.y && y < prison.y + prison.height) {
                            isInPrisonArea = true;
                            break;
                        }
                    }
                    if (isInPrisonArea) {
                        validPosition = false;
                        attempts++;
                        continue;
                    }


                    // Check player safe zone
                    if (Math.hypot(x - player.x, y - player.y) < playerSafeZoneObstacle) {
                        validPosition = false;
                        attempts++;
                        continue;
                    }

                    // Check against other obstacles
                    for (const obs of obstacles) {
                        const obsCenterX = obs.type === 'rect' ? obs.x + obs.width / 2 : obs.x;
                        const obsCenterY = obs.type === 'rect' ? obs.y + obs.height / 2 : obs.y;
                        const newCenterX = isRect ? x + width / 2 : x;
                        const newCenterY = isRect ? y + height / 2 : y;
                        
                        const dist = Math.hypot(newCenterX - obsCenterX, newCenterY - obsCenterY);
                        const requiredDist = (width / 2) + ((obs.width || obs.radius * 2) / 2) + SPAWN_PADDING;
                        
                        if (dist < requiredDist) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }

                if (validPosition) {
                    if (isRect) {
                        obstacles.push({ type: 'rect', x, y, width, height, color: 'rgba(70, 70, 70, 0.8)' });
                    } else {
                        obstacles.push({ type: 'circle', x, y, radius, color: 'rgba(40, 60, 40, 0.8)' });
                    }
                }
            }
        }

        function createEnemy(forceType = null) {
            let x, y, validPosition = false;
            let attempts = 0;
            
            const enemyTypeRNG = Math.random();
            const enemyType = forceType ? forceType : (enemyTypeRNG < 0.15 ? 'helicopter' : enemyTypeRNG < 0.35 ? 'motorcycle' : 'tank');

            while(!validPosition && attempts < 100) {
                 x = player.x + (Math.random() - 0.5) * camera.width * 2.5;
                 y = player.y + (Math.random() - 0.5) * camera.height * 2.5;
                 
                 let inObstacle = false;
                 for (const obs of obstacles) {
                     if (checkPointInObstacle(x, y, obs)) {
                         inObstacle = true;
                         break;
                     }
                 }

                if (!inObstacle &&
                    !(x > camera.x && x < camera.x + camera.width && y > camera.y && y < camera.y + camera.height) &&
                    x > 0 && x < world.width && y > 0 && y < world.height) {
                    validPosition = true;
                }
                attempts++;
            }
            
            if(!validPosition) return;
            
            const healthMultiplier = (enemyType === 'motorcycle' ? 0.3 : 1);
            const speedMultiplier = (enemyType === 'motorcycle' ? 1.5 : 1);

            let health;
            if (enemyType === 'motorcycle') {
                // Motosikletlerin can değeri 15'ten başlar ve oyuncunun seviyesi/skoru ile artar.
                health = 15 + Math.floor(score / 250) + ((player.level - 1) * 8);
            } else {
                health = (20 + Math.floor(score / 250) + player.level * 20) * healthMultiplier;
            }

            if (gameMode === 'easy') {
                health *= 0.6; // %40 daha az can
            }

            const xpValue = Math.floor(health / 2);

            let color = '#ff4444', turretColor = '#cc0000';
            if (health >= 800)      { color = '#ff69b4'; turretColor = '#ff1493'; }
            else if (health >= 500) { color = '#ffd700'; turretColor = '#daa520'; }
            else if (health >= 300) { color = '#00ffff'; turretColor = '#00ced1'; }
            else if (health >= 200) { color = '#ffffff'; turretColor = '#cccccc'; }
            else if (health >= 120) { color = '#cc33ff'; turretColor = '#9900cc'; }
            else if (health >= 60)  { color = '#ff9933'; turretColor = '#cc6600'; }

            const size = (enemyType === 'motorcycle' ? 15 : Math.random() * 20 + 30);

            const enemyData = {
                id: enemyIdCounter++, x, y,
                color, turretColor, angle: 0,
                speed: (1 + Math.random() * 0.8) * speedMultiplier,
                attackRange: 350 + Math.random() * 100,
                shootCooldown: 120 + Math.random() * 50, shootTimer: 0,
                health: health, maxHealth: health, xpValue: xpValue,
                isHit: false, hitTimer: 0,
                isBurning: false, burnDamage: 0,
                burnDamageAccumulator: 0,
                burnDamageDisplayTimer: 60,
                offScreenTimer: 0,
            };

            if(enemyType === 'helicopter') {
                Object.assign(enemyData, {
                    type: 'helicopter', width: size, height: size,
                    rotorAngle: 0, rotorSpeed: 0.3, turretAngle: 0
                });
            } else if (enemyType === 'motorcycle') {
                 Object.assign(enemyData, {
                    type: 'motorcycle', width: size * 2, height: size,
                    turretAngle: 0
                });
            } else {
                Object.assign(enemyData, {
                    type: 'tank', width: size, height: size * 1.2,
                    turretAngle: 0
                });
            }
            enemies.push(enemyData);
        }

        function createBoss(level, isStationary = false, customX = null, customY = null, guardianIndex = null) {
            isBossActive = true;
            
            // Scaling logic for levels 3 and beyond
            let health, speed, xpValue;
            const size = 120; // Bütün bossların ölçüsü 120x120 olarak ayarlandı.
            const baseHealth = 2500;
            const baseSpeed = 1.6;
            const baseXp = 1250;

            if (level < 3) { // The first 3 bosses (levels 0, 1, 2)
                const bossHealths = [500, 1000, 2500];
                health = bossHealths[level];
                speed = 1.2 + level * 0.2;
                xpValue = health / 2;
            } else { // Scaling bosses
                const scalingFactor = 1.25;
                const levelDelta = level - 2;
                health = Math.floor(baseHealth * Math.pow(scalingFactor, levelDelta));
                speed = Math.min(2.5, baseSpeed + levelDelta * 0.1);
                xpValue = Math.floor(baseXp * Math.pow(scalingFactor, levelDelta));
            }

            if (isStationary) {
                // This is for the final guardians, which have specific stats.
                health = 4000;
                xpValue = 2000;
                speed = 0;
            }

            if (gameMode === 'easy') {
                health *= 0.5; // Boss'ların %50 daha az canı var
            }

            let x, y;
            if (customX !== null && customY !== null) {
                x = customX;
                y = customY;
            } else {
                // Spawn just outside the camera view
                const spawnAngle = Math.random() * Math.PI * 2;
                const spawnDist = Math.max(camera.width, camera.height) / 2 + size;
                x = player.x + Math.cos(spawnAngle) * spawnDist;
                y = player.y + Math.sin(spawnAngle) * spawnDist;
            }

            const bossData = {
                id: 'boss' + (isStationary ? `final-${guardianIndex}` : level),
                type: 'boss', x, y,
                width: size, height: size,
                color: '#444', turretColor: '#ff0000',
                speed: speed,
                isStationary: isStationary,
                isGuardian: isStationary, // Gardiyan olup olmadığını belirtmek için bayrak ekle
                isAwake: false, // Gardiyanlar uykuda başlar
                attackRange: 600,
                health: health, maxHealth: health, xpValue,
                isHit: false, hitTimer: 0, angle: 0, turretAngle: 0,
                isBurning: false, burnDamage: 0,
                burnDamageAccumulator: 0,
                burnDamageDisplayTimer: 60,
                weaponCooldowns: {
                    machineGun: 0,
                    missile: 0,
                    flamethrower: 0
                },
                level: level // Store the level for cooldown calculation
            };
            enemies.push(bossData);
        }
        
        function createExplosion(x, y, color) {
            // Existing explosion particles
            for (let i = 0; i < 20; i++) {
                particles.push({
                    type: 'explosion', x, y,
                    vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                    radius: Math.random() * 3 + 1, life: 1, color: color
                });
            }
            // New white smoke particles
            for (let i = 0; i < 15; i++) {
                particles.push({
                    type: 'smoke', x, y,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: (Math.random() - 0.5) * 1.5,
                    radius: Math.random() * 8 + 5,
                    life: 2,
                    color: 'white' // Specify white color for explosion smoke
                });
            }
        }
        
        function createImpactEffect(x, y, color = '#ffdd88') {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    type: 'impact', x, y,
                    vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                    radius: Math.random() * 2 + 1, life: 0.5, color: color
                });
            }
        }
        
        function spawnPowerup(type, x, y) {
            let config;
            switch(type) {
                case 'health':
                    config = { type: 'health', color: 'rgba(0, 255, 0, 0.7)', icon: '✚' };
                    break;
                case 'magnet':
                    config = { type: 'magnet', color: 'rgba(100, 100, 255, 0.8)', icon: '🧲' };
                    break;
                case 'lootBox':
                    config = { type: 'lootBox', color: 'rgba(255, 215, 0, 0.9)', icon: '🎁' };
                    break;
            }
            powerups.push({ x, y, size: 35, ...config });
        }
        
        function spawnAllPermanentUpgrades() {
            permanentUpgrades = [];
            const types = [
                { type: 'maxHealth', color: 'rgba(255, 0, 0, 0.8)', icon: '❤️', text: '+25 MAX HEALTH' },
                { type: 'speed', color: 'rgba(255, 255, 0, 0.8)', icon: '⚡', text: '+ SPEED' },
                { type: 'damageBonus', color: 'rgba(255, 100, 0, 0.8)', icon: '💥', text: '+5 ANA SİLAH HASARI' },
                { type: 'healthRegen', color: 'rgba(0, 255, 0, 0.8)', icon: '♻️', text: '+1 ZIRH/SANİYE' },
                { type: 'map', color: 'rgba(0, 150, 255, 0.8)', icon: '🗺️', text: 'HARİTA AÇILDI!' }
            ];

            const airportSafeZoneRadius = 2000; // Havaalanı etrafındaki korunaklı alan

            types.forEach(config => {
                let x, y, validPosition = false;
                let attempts = 0;
                while (!validPosition && attempts < 100) {
                    x = Math.random() * world.width;
                    y = Math.random() * world.height;
                    
                    validPosition = true; // Assume true

                    if (Math.hypot(x - player.x, y - player.y) < 1500) {
                         validPosition = false;
                    }

                    // Havaalanı güvenli alanını kontrol et
                    const runwayWidth = 250;
                    const runwayBuffer = 1000;
                    const safeZoneLeft = escapePlane.x - (runwayWidth / 2) - runwayBuffer;
                    const safeZoneRight = escapePlane.x + (runwayWidth / 2) + runwayBuffer;
                    if (x > safeZoneLeft && x < safeZoneRight) {
                        validPosition = false;
                    }

                    // Check against obstacles
                    if (validPosition) {
                        for (const obs of obstacles) {
                            const obsCenterX = obs.type === 'rect' ? obs.x + obs.width / 2 : obs.x;
                            const obsCenterY = obs.type === 'rect' ? obs.y + obs.height / 2 : obs.y;
                            const requiredDist = (config.size / 2) + ((obs.width || obs.radius * 2) / 2) + SPAWN_PADDING;
                            if (Math.hypot(x - obsCenterX, y - obsCenterY) < requiredDist) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    
                    // Check against other permanent upgrades
                    if (validPosition) {
                        for (const upg of permanentUpgrades) {
                             if (Math.hypot(x - upg.x, y - upg.y) < upg.size + SPAWN_PADDING) {
                                 validPosition = false;
                                 break;
                             }
                        }
                    }

                    attempts++;
                }
                
                if (validPosition) {
                     permanentUpgrades.push({ x, y, size: 35, ...config });
                }
            });
        }
        
        function spawnRandomPermanentUpgrade() {
            const types = [
                { type: 'maxHealth', color: 'rgba(255, 0, 0, 0.8)', icon: '❤️', text: '+25 MAX HEALTH' },
                { type: 'speed', color: 'rgba(255, 255, 0, 0.8)', icon: '⚡', text: '+ SPEED' },
                { type: 'damageBonus', color: 'rgba(255, 100, 0, 0.8)', icon: '💥', text: '+5 STANDART TOP HASARI' },
                { type: 'healthRegen', color: 'rgba(0, 255, 0, 0.8)', icon: '♻️', text: '+1 ZIRH/SANİYE' }
            ];

            const config = types[Math.floor(Math.random() * types.length)]; 

            let x, y, validPosition = false;
            let attempts = 0;
            while (!validPosition && attempts < 100) {
                x = Math.random() * world.width;
                y = Math.random() * world.height;

                validPosition = true; // Assume true

                if (Math.hypot(x - player.x, y - player.y) < 1000) {
                     validPosition = false;
                }

                // Check against obstacles, flags, and other upgrades
                const allObjects = [
                    ...obstacles.map(o => ({ ...o, centerX: o.type === 'rect' ? o.x + o.width / 2 : o.x, centerY: o.type === 'rect' ? o.y + o.height / 2 : o.y, radius: (o.width || o.radius*2)/2 })),
                    ...flags.map(f => ({ centerX: f.x, centerY: f.y, radius: f.captureRadius })),
                    ...permanentUpgrades.map(u => ({ centerX: u.x, centerY: u.y, radius: u.size/2 }))
                ];

                if (validPosition) {
                    for (const obj of allObjects) {
                        const requiredDist = (config.size / 2) + obj.radius + SPAWN_PADDING;
                        if (Math.hypot(x - obj.centerX, y - obj.centerY) < requiredDist) {
                            validPosition = false;
                            break;
                        }
                    }
                }

                attempts++;
            }
            
            if (validPosition) {
                 permanentUpgrades.push({ x, y, size: 35, ...config });
                 showObjectivePopup("YENİ GÜÇLENDİRME GELDİ!");
            }
        }
        
        function spawnAllFlags() {
            flags = [];
            const padding = 800; // Kenarlardan minimum uzaklık
            const cornerZoneSize = 500; // Köşelerdeki spawn alanının büyüklüğü (biraz çeşitlilik için)
            const minFlagDistance = 2000; // Bayraklar arası minimum mesafe

            // Sadece haritanın 4 köşe bölgesini tanımla
            const spawnZones = [
                // Sol Üst Köşe
                { generate: () => ({ x: padding + Math.random() * cornerZoneSize, y: padding + Math.random() * cornerZoneSize }) },
                // Sağ Üst Köşe
                { generate: () => ({ x: world.width - padding - Math.random() * cornerZoneSize, y: padding + Math.random() * cornerZoneSize }) },
                // Sol Alt Köşe
                { generate: () => ({ x: padding + Math.random() * cornerZoneSize, y: world.height - padding - Math.random() * cornerZoneSize }) },
                // Sağ Alt Köşe
                { generate: () => ({ x: world.width - padding - Math.random() * cornerZoneSize, y: world.height - padding - Math.random() * cornerZoneSize }) }
            ];

            spawnZones.forEach((zone, index) => {
                let x, y, validPosition = false;
                let attempts = 0;
                while (!validPosition && attempts < 100) {
                    const pos = zone.generate();
                    x = pos.x;
                    y = pos.y;
                    
                    validPosition = true;

                    // Engellerle çakışmayı kontrol et
                    for (const obs of obstacles) {
                        if (checkPointInObstacle(x, y, obs)) {
                            validPosition = false;
                            break;
                        }
                    }
                    if (!validPosition) { attempts++; continue; }

                    // Diğer bayraklarla mesafeyi kontrol et
                    for (const flag of flags) {
                        if (Math.hypot(x - flag.x, y - flag.y) < minFlagDistance) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }

                if (validPosition) {
                    flags.push({
                        id: index, x, y,
                        captureRadius: 200,
                        captureProgress: 0,
                        isCaptured: false,
                    });
                }
            });
        }

        function createConfetti(count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    type: 'confetti',
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    vx: (Math.random() - 0.5) * 5,
                    vy: Math.random() * 5 + 2,
                    radius: Math.random() * 5 + 3,
                    life: 3,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`
                });
            }
        }

        function createFirework(x, y) {
            particles.push({
                type: 'fireworkRocket', x, y,
                vx: (Math.random() - 0.5) * 4,
                vy: -Math.random() * 5 - 8,
                radius: 3, life: 1.5, color: '#ffffff'
            });
        }


        // --- Update Functions ---
        
        function updatePlayer() {
            // Timers and abilities
            if (player.trackSpawnTimer > 0) player.trackSpawnTimer--;
            if (player.hitTimer > 0) player.hitTimer--; else player.isHit = false;
            if (player.shieldCooldownTimer > 0) player.shieldCooldownTimer--;
            if (player.healthRegen > 0) player.health = Math.min(player.maxHealth, player.health + player.healthRegen / 60);
            if (player.type === 'helicopter') player.rotorAngle += player.rotorSpeed;
            
            if (player.isReloading) {
                player.reloadTimer--;
                if (player.reloadTimer <= 0) {
                    player.isReloading = false;
                    player.magazine = player.maxMagazine;
                }
            }

            const canStartBoost = player.dashFuel >= player.maxDashFuel;
            player.isBoosting = keys['shift'] && (player.isBoosting || canStartBoost) && player.dashFuel > 0;

            if (player.isBoosting) {
                // 2 saniyede boşalır (120 kare)
                player.dashFuel = Math.max(0, player.dashFuel - 1);
            } else {
                // Zırhlı araçların atılma yakıtı 2 kat daha hızlı dolar.
                const dashRegenRate = player.type === 'armored' ? 0.4 : 0.2;
                player.dashFuel = Math.min(player.maxDashFuel, player.dashFuel + dashRegenRate);
            }

             if (keys[' '] && player.shieldCooldownTimer <= 0 && !player.isShielded) {
                player.isShielded = true;
                player.shieldTimer = player.shieldDuration;
            }
            if (player.isShielded) {
                player.shieldTimer--;
                if (player.shieldTimer <= 0) {
                    player.isShielded = false;
                    player.shieldCooldownTimer = player.shieldCooldown;
                }
            }

            // Movement
            let currentSpeed = player.speed;
            if (player.isBoosting) {
                currentSpeed *= 2.5; // Boost hız çarpanı
                if (Math.random() < 0.4) {
                    const angle = player.angle - Math.PI; // Tankın arkası
                    const spawnX = player.x + Math.sin(angle) * (player.height/2);
                    const spawnY = player.y - Math.cos(angle) * (player.height/2);
                    particles.push({
                        type: 'boost',
                        x: spawnX + (Math.random() - 0.5) * 20,
                        y: spawnY + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        radius: Math.random() * 2 + 1,
                        life: 0.5
                    });
                }
            }
            
            let moveX = 0;
            let moveY = 0;

            if (player.type === 'helicopter') {
                // Helikopter her zaman nişan aldığı yöne bakar
                player.angle = player.turretAngle;

                const forwardInput = (keys['w'] ? 1 : 0) - (keys['s'] ? 1 : 0);
                const strafeInput = (keys['d'] ? 1 : 0) - (keys['a'] ? 1 : 0);

                player.isMoving = forwardInput !== 0 || strafeInput !== 0;

                if (player.isMoving) {
                    // İleri/Geri hareket
                    const forwardSpeed = forwardInput * currentSpeed;
                    moveX += Math.sin(player.angle) * forwardSpeed;
                    moveY -= Math.cos(player.angle) * forwardSpeed;
                    
                    // Sağa/Sola kayma (strafe) hareketi
                    const strafeAngle = player.angle + Math.PI / 2;
                    let effectiveStrafeInput = strafeInput;

                    // Helikopter ekranda aşağı doğru baktığında, oyuncu kontrollerin tersine döndüğünü hissediyor.
                    // Bu durumu düzeltmek için, helikopterin ileri vektörünün y bileşenini kontrol ediyoruz.
                    // Eğer aşağıyı gösteriyorsa (pozitif Y), yatay kayma girdisini tersine çeviriyoruz.
                    const forwardVectorY = -Math.cos(player.angle);
                    if (forwardVectorY > 0) {
                         effectiveStrafeInput *= -1;
                    }
                    
                    const strafeSpeed = effectiveStrafeInput * currentSpeed;
                    moveX += Math.sin(strafeAngle) * strafeSpeed;
                    moveY -= Math.cos(strafeAngle) * strafeSpeed;
                }

                // Helikopterler engellerin üzerinden uçar, bu yüzden basit bir hareket uygulaması yapılır
                player.x += moveX;
                player.y += moveY;
                
            } else { // Tank or Armored vehicle movement
                // Rotation
                if (keys['a']) player.angle -= 0.04;
                if (keys['d']) player.angle += 0.04;

                // Forward/Backward movement
                const forwardInput = (keys['w'] ? 1 : 0) - (keys['s'] ? 1 : 0);
                player.isMoving = forwardInput !== 0;
                
                if (player.isMoving) {
                    moveX = Math.sin(player.angle) * currentSpeed * forwardInput;
                    moveY = -Math.cos(player.angle) * currentSpeed * forwardInput;
                }

                // Apply X movement and check collision
                if (moveX !== 0) {
                    player.x += moveX;
                    let collidedObstacle = checkTankObstacleCollision(player);
                    if (collidedObstacle) {
                        if (player.isBoosting && player.type === 'tank') {
                            const obsIndex = obstacles.indexOf(collidedObstacle);
                            if (obsIndex > -1) {
                                const obs = obstacles[obsIndex];
                                const centerX = obs.type === 'rect' ? obs.x + obs.width / 2 : obs.x;
                                const centerY = obs.type === 'rect' ? obs.y + obs.height / 2 : obs.y;
                                createExplosion(centerX, centerY, obs.color);
                                triggerScreenShake(8, 15);
                                obstacles.splice(obsIndex, 1);
                                player.dashFuel = 0;
                            }
                        } else {
                            player.x -= moveX; // Revert movement if not boosting or not a tank
                        }
                    }
                }
                
                // Apply Y movement and check collision
                if (moveY !== 0) {
                    player.y += moveY;
                    let collidedObstacle = checkTankObstacleCollision(player);
                    if (collidedObstacle) {
                         if (player.isBoosting && player.type === 'tank') {
                            const obsIndex = obstacles.indexOf(collidedObstacle);
                            if (obsIndex > -1) {
                                const obs = obstacles[obsIndex];
                                const centerX = obs.type === 'rect' ? obs.x + obs.width / 2 : obs.x;
                                const centerY = obs.type === 'rect' ? obs.y + obs.height / 2 : obs.y;
                                createExplosion(centerX, centerY, obs.color);
                                triggerScreenShake(8, 15);
                                obstacles.splice(obsIndex, 1);
                                player.dashFuel = 0;
                            }
                        } else {
                            player.y -= moveY; // Revert movement
                        }
                    }
                }

                // Create tank tracks
                if (player.isMoving && player.type === 'tank' && player.trackSpawnTimer <= 0) {
                    const trackWidth = player.isBoosting ? 12 : 8;
                    const trackLength = 5;
                    const trackOffsetFromCenter = player.width / 2 * 0.7;

                    const rearX = player.x - Math.sin(player.angle) * (player.height / 2);
                    const rearY = player.y + Math.cos(player.angle) * (player.height / 2);

                    const perpAngle = player.angle + Math.PI / 2;
                    const offsetX = Math.sin(perpAngle) * trackOffsetFromCenter;
                    const offsetY = -Math.cos(perpAngle) * trackOffsetFromCenter;

                    particles.push({
                        type: 'track', x: rearX - offsetX, y: rearY - offsetY,
                        width: trackWidth, height: trackLength, angle: player.angle,
                        life: 2.5, vx: 0, vy: 0
                    });

                    particles.push({
                        type: 'track', x: rearX + offsetX, y: rearY + offsetY,
                        width: trackWidth, height: trackLength, angle: player.angle,
                        life: 2.5, vx: 0, vy: 0
                    });
                    
                    player.trackSpawnTimer = player.isBoosting ? 2 : 4;
                }
            }

            // Turret Aiming
            if (player.type === 'helicopter') {
                const playerScreenX = player.x - camera.x;
                const playerScreenY = player.y - camera.y;
                player.turretAngle = Math.atan2(mouse.y - playerScreenY, mouse.x - playerScreenX) + Math.PI / 2;
            } else { // Tank aiming
                const angleToEnemy = getAngleToClosestEnemy(world.width);
                if (angleToEnemy !== null) {
                    player.turretAngle = angleToEnemy;
                } else {
                    // If no enemy, aim where the tank is facing
                    player.turretAngle = player.angle;
                }
            }
            
            // World bounds
            player.x = Math.max(player.width / 2, Math.min(world.width - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(world.height - player.height / 2, player.y));

            // Ağır hasar duman ve ekran çatlaması efekti
            if (player.health / player.maxHealth < 1/3) {
                damageOverlay.classList.add('critical');
                if (Math.random() < 0.2) { // Saniyede birkaç kez duman çıkar
                    particles.push({
                        type: 'smoke',
                        x: player.x + (Math.random() - 0.5) * player.width * 0.5,
                        y: player.y + (Math.random() - 0.5) * player.height * 0.5,
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: -0.5 - Math.random() * 0.5,
                        radius: Math.random() * 4 + 3,
                        life: 1.5
                    });
                }
            } else {
                damageOverlay.classList.remove('critical');
            }
        }

        function updatePlayerNpcInteractions() {
            const RESCUE_TIME = 60; // 1 saniye (60 kare)
            const RESCUE_RADIUS = player.width + 20; // Tankın etrafındaki alan
            for (let i = npcs.length - 1; i >= 0; i--) {
                const npc = npcs[i];
                if (npc.type === 'prisoner') {
                    const dist = Math.hypot(player.x - npc.x, player.y - npc.y);
                    // Oyuncu mahkumun yakınındaysa VE HAREKET ETMİYORSA kurtarma işlemi başlar.
                    if (dist < RESCUE_RADIUS && !player.isMoving) { 
                        npc.rescueTimer++;
                        if (npc.rescueTimer >= RESCUE_TIME) {
                            // KURTARILDI!
                    floatingTexts.push({ x: npc.x, y: npc.y, text: `KURTARILDI! +${nextPrisonerScoreReward}`, color: '#ffd700', life: 1.5, vy: 1, size: 22 });
                    score += nextPrisonerScoreReward;
                    addXP(nextPrisonerXpReward);

                    prisonersRescuedCount++;

                    // Her 2 kurtarmada bir ödülü ikiye katla (1-2 aynı, 3-4 aynı, vb.)
                    // Bu, çift sayılı bir kurtarma tamamlandıktan sonra gerçekleşir.
                    if (prisonersRescuedCount > 0 && prisonersRescuedCount % 2 === 0) {
                        nextPrisonerScoreReward *= 2;
                        nextPrisonerXpReward *= 2;
                    }

                    npcs.splice(i, 1); // Mahkumu oyundan kaldır
                }
            } else {
                // Oyuncu uzaklaştı VEYA hareket ediyor, zamanlayıcıyı sıfırla
                npc.rescueTimer = 0;
                    }
                }
            }
        }

        function updateNPCs() {
            const detectionRadius = 300;
            const alertedSpeed = 2.5;

            npcs.forEach(npc => {
                if (npc.type === 'prisoner') {
                    // --- Konuşma Mantığı ---
                    if (npc.currentDialogue) {
                        npc.currentDialogue.life--;
                        if (npc.currentDialogue.life <= 0) {
                            npc.currentDialogue = null;
                        }
                    } else {
                        npc.dialogueTimer--;
                        if (npc.dialogueTimer <= 0) {
                            const phrase = PRISONER_DIALOGUE[Math.floor(Math.random() * PRISONER_DIALOGUE.length)];
                            npc.currentDialogue = { text: phrase, life: 120 }; // 2 saniye
                            npc.dialogueTimer = Math.random() * 600 + 300; // 5-15 saniye sonra tekrar konuş
                        }
                    }

                    const prison = npc.prisonArea;
                    if (!prison) return; // Güvenlik kontrolü

                    // Hapishane binasının konumunu ve boyutlarını NPC'nin kendi hapishane alanından al
                    const fenceWidth = 15;
                    const buildingHeight = 250;
                    const buildingWidth = 600;
                    const buildingY = prison.y + prison.height - buildingHeight - fenceWidth - 50;

                    const distToPlayer = Math.hypot(player.x - npc.x, player.y - npc.y);
                    let target;
                    let currentSpeed = npc.speed;

                    if (distToPlayer < detectionRadius) {
                        // Oyuncuyu gördü, ona doğru koş
                        target = player;
                        currentSpeed = alertedSpeed;
                    } else {
                        // Oyuncuyu görmüyor, gezinmeye devam et
                        npc.wanderTimer--;
                        if (npc.wanderTimer <= 0 || !npc.wanderTarget) {
                            // Sadece ön bahçede yeni bir gezinme hedefi belirle
                            const frontYardHeight = buildingY - prison.y;
                            const newX = prison.x + 50 + Math.random() * (prison.width - 100);
                            const newY = prison.y + 50 + Math.random() * (frontYardHeight - 100);
                            
                            npc.wanderTarget = { x: newX, y: newY };
                            npc.wanderTimer = Math.random() * 180 + 120; // 2 ila 5 saniye
                        }
                        target = npc.wanderTarget;
                    }
                    
                    if (!target) return;

                    const distToTarget = Math.hypot(target.x - npc.x, target.y - npc.y);

                    if (distToTarget > currentSpeed) {
                        const angleToTarget = Math.atan2(target.y - npc.y, target.x - npc.x);
                        npc.angle = angleToTarget + Math.PI / 2;
                        
                        const moveX = Math.cos(angleToTarget) * currentSpeed;
                        const moveY = Math.sin(angleToTarget) * currentSpeed;

                        npc.x += moveX;
                        if (checkTankObstacleCollision(npc)) {
                            npc.x -= moveX;
                            npc.wanderTarget = null; // Hedef ulaşılamazsa yeni bir hedef belirle
                        }
                        npc.y += moveY;
                        if (checkTankObstacleCollision(npc)) {
                            npc.y -= moveY;
                            npc.wanderTarget = null;
                        }
                    } else if (distToPlayer > detectionRadius) {
                        // Gezinme hedefine ulaşıldı, yeni hedef bekleniyor
                        npc.wanderTarget = null; 
                    }
                }
            });
        }

        function updateCamera() {
            camera.x = player.x - camera.width / 2;
            camera.y = player.y - camera.height / 2;
            camera.x = Math.max(0, Math.min(world.width - camera.width, camera.x));
            camera.y = Math.max(0, Math.min(world.height - camera.height, camera.y));
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy) continue;

                if(enemy.hitTimer > 0) enemy.hitTimer--; else enemy.isHit = false;
                
                // Burn logic
                if (enemy.isBurning) {
                    const burnDamagePerFrame = enemy.burnDamage / 60;
                    enemy.health -= burnDamagePerFrame;
                    enemy.burnDamageAccumulator = (enemy.burnDamageAccumulator || 0) + burnDamagePerFrame;
                    enemy.burnDamageDisplayTimer = (enemy.burnDamageDisplayTimer || 60) - 1;

                    if(weaponDamageStats.hasOwnProperty('kundakciBonus')) {
                         weaponDamageStats['kundakciBonus'] += burnDamagePerFrame;
                    } else {
                         weaponDamageStats['kundakciBonus'] = burnDamagePerFrame;
                    }

                    // Bir saniyede bir birikmiş hasarı göster
                    if (enemy.burnDamageDisplayTimer <= 0) {
                        if (enemy.burnDamageAccumulator > 0) {
                            floatingTexts.push({ 
                                x: enemy.x, 
                                y: enemy.y, 
                                text: `${Math.floor(enemy.burnDamageAccumulator)}`, 
                                color: '#ff6600', // Ateş için turuncu renk
                                life: 1, 
                                vy: 1, 
                                size: 20 
                            });
                        }
                        enemy.burnDamageAccumulator = 0;
                        enemy.burnDamageDisplayTimer = 60; // Zamanlayıcıyı sıfırla
                    }

                    // Yanan düşmanlar için belirgin alev efekti
                    if (Math.random() < 0.6) { // Her karede %60 ihtimalle parçacık oluştur
                        const particleCount = 2; // Her seferinde 2 parçacık oluştur
                        for (let k = 0; k < particleCount; k++) {
                            particles.push({
                                type: 'flame',
                                x: enemy.x + (Math.random() - 0.5) * enemy.width,
                                y: enemy.y + (Math.random() - 0.5) * enemy.height,
                                vx: (Math.random() - 0.5) * 0.5, // Hafif yatay hareket
                                vy: -Math.random() * 1.5,      // Yukarı doğru hareket
                                radius: Math.random() * 6 + 2,   // Biraz daha büyük ve çeşitli alevler
                                life: 0.6,                       // Biraz daha uzun ömür
                                color: `rgba(255, ${Math.floor(Math.random() * 100 + 100)}, 0, 0.8)` // Renk çeşitliliği
                            });
                        }
                    }
                }

                // Ağır hasar duman efekti
                if (enemy.health / enemy.maxHealth < 1/3) {
                    if (Math.random() < 0.15) { 
                        particles.push({
                            type: 'smoke',
                            x: enemy.x + (Math.random() - 0.5) * enemy.width * 0.5,
                            y: enemy.y + (Math.random() - 0.5) * enemy.height * 0.5,
                            vx: (Math.random() - 0.5) * 0.2,
                            vy: -0.5 - Math.random() * 0.5,
                            radius: Math.random() * 3 + 2,
                            life: 1.5
                        });
                    }
                }

                // *** BUG FIX: Added death check for burn damage and other DOTs ***
                        if (enemy.health <= 0) {
                    if (enemy.type === 'boss') {
                        isBossActive = false;
                        spawnPowerup('lootBox', enemy.x, enemy.y);
                        if (gameMode !== 'easy') {
                            player.money += 1;
                            floatingTexts.push({ x: enemy.x, y: enemy.y, text: `+1 TL`, color: '#ffd700', life: 1, vy: 1, size: 22 });
                        }
                    } else {
                        const dropRNG = Math.random();
                        if (dropRNG < 0.01) { 
                            spawnPowerup('magnet', enemy.x, enemy.y);
                        } else if (dropRNG < 0.06) { 
                            spawnPowerup('health', enemy.x, enemy.y);
                        } else {
                            if (enemy.maxHealth >= 300) { // Tier 3
                                xpOrbs.push({x: enemy.x, y: enemy.y, radius: 9, value: enemy.xpValue * 5, color: '#ffd700'});
                            } else if (enemy.maxHealth >= 120) { // Tier 2
                                xpOrbs.push({x: enemy.x, y: enemy.y, radius: 8, value: enemy.xpValue * 3, color: '#ff9900'});
                            } else { // Tier 1
                                xpOrbs.push({x: enemy.x, y: enemy.y, radius: 7, value: enemy.xpValue, color: '#00ff88'});
                            }
                        }
                        if (Math.random() < 0.05) { // 5% chance
                            if (gameMode !== 'easy') {
                                player.money += 1;
                                floatingTexts.push({ x: enemy.x, y: enemy.y, text: `+1 TL`, color: '#ffd700', life: 1, vy: 1, size: 22 });
                            }
                        }
                    }
                    
                    createExplosion(enemy.x, enemy.y, enemy.color);
                    enemies.splice(i, 1); 
                    score += 10; 
                    continue; // Skip the rest of the logic for the removed enemy
                }


                if (enemy.type !== 'boss' && enemy.type !== 'kule') {
                    const distToPlayerForTeleport = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    const minimapViewRadius = 900; // Based on minimapViewSize = 1800 in drawMinimap()

                    if (distToPlayerForTeleport > minimapViewRadius) {
                        enemy.offScreenTimer = (enemy.offScreenTimer || 0) + 1;
                    } else {
                        enemy.offScreenTimer = 0;
                    }
                    
                    // 5 seconds at 60fps is 300 frames
                    if (enemy.offScreenTimer > 300) {
                        let teleportAngle;
                        const isMovingForward = keys['w'];
                        const isMovingBackward = keys['s'];

                        if (isMovingForward) {
                            // Oyuncunun hareket açısını kullan, koordinat sistemi için 90 derece ayarla
                            teleportAngle = player.angle - Math.PI / 2;
                        } else if (isMovingBackward) {
                            // Oyuncunun hareket açısının tersini kullan
                            teleportAngle = player.angle - Math.PI / 2 + Math.PI;
                        } else {
                            // Oyuncu hareket etmiyorsa, taret açısını kullan (en yakın düşmana veya fareye bakar)
                            teleportAngle = player.turretAngle - Math.PI / 2;
                        }

                        const teleportDistance = Math.max(camera.width, camera.height) / 2 + 150; // just outside camera view
                        
                        let validPosition = false;
                        let attempts = 0;
                        let newX, newY;
                        
                        while(!validPosition && attempts < 10) {
                            const randomAngleOffset = (Math.random() - 0.5) * Math.PI / 2; // +/- 45 degrees spread
                            newX = player.x + Math.cos(teleportAngle + randomAngleOffset) * teleportDistance;
                            newY = player.y + Math.sin(teleportAngle + randomAngleOffset) * teleportDistance;
                            
                            newX = Math.max(enemy.width, Math.min(world.width - enemy.width, newX));
                            newY = Math.max(enemy.width, Math.min(world.height - enemy.width, newY));
                            
                            let inObstacle = false;
                            for (const obs of obstacles) { if (checkPointInObstacle(newX, newY, obs)) { inObstacle = true; break; } }
                            
                            if (!inObstacle) validPosition = true;
                            attempts++;
                        }
                        
                        if (validPosition) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                        
                        enemy.offScreenTimer = 0; // Reset timer regardless of success
                    }
                }

                const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                let angleToTarget = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                
                // Guardian wake-up logic
                if (enemy.isGuardian && !enemy.isAwake) {
                    if (distToPlayer < enemy.attackRange * 1.2) { // Wake up when player is 1.2x attack range
                        enemy.isAwake = true;
                        enemy.isStationary = false; // Allow movement
                        enemy.speed = 1.4; // Set their speed
                        floatingTexts.push({ x: enemy.x, y: enemy.y, text: `...UYANIYOR...`, color: '#ff0000', life: 1.5, vy: 1, size: 24 });
                    }
                }
                
                if (enemy.type === 'helicopter') {
                    enemy.rotorAngle += enemy.rotorSpeed;
                } else if (enemy.type === 'boss') {
                    for(let j=obstacles.length-1; j>=0; j--){
                        if (checkTankObstacleCollision(enemy, obstacles[j])) {
                            createExplosion(obstacles[j].x + (obstacles[j].width || 0)/2, obstacles[j].y + (obstacles[j].height || 0)/2, '#888');
                            obstacles.splice(j, 1);
                        }
                    }
                }

                enemy.angle = angleToTarget + Math.PI / 2;
                
                // Movement
                if (!enemy.isStationary) {
                    let currentSpeed = enemy.speed;

                    if (enemy.type === 'motorcycle') {
                        if (gameMode !== 'easy') {
                            const lightDistance = 100; // Işığın merkezinin ne kadar ileride olduğu
                            const lightRadius = 75;    // Tetiklenme dairesinin yarıçapı
    
                            // Işığın merkezinin dünya koordinatlarını hesapla
                            const forwardAngle = enemy.angle - Math.PI / 2;
                            const lightCenterX = enemy.x + Math.cos(forwardAngle) * lightDistance;
                            const lightCenterY = enemy.y + Math.sin(forwardAngle) * lightDistance;
    
                            const distToLightCenter = Math.hypot(player.x - lightCenterX, player.y - lightCenterY);
    
                            // Oyuncu ışık dairesinin içindeyse hızı ikiye katla
                            if (distToLightCenter < lightRadius) {
                                currentSpeed *= 2;
                            }
                        }
                    }

                    const moveX = Math.cos(angleToTarget) * currentSpeed;
                    const moveY = Math.sin(angleToTarget) * currentSpeed;
                    
                    if (enemy.type === 'tank' || enemy.type === 'motorcycle') {
                        enemy.x += moveX;
                        if(checkTankObstacleCollision(enemy)) {
                            enemy.x -= moveX;
                            enemy.y += Math.sign(moveY) * currentSpeed; // Slide
                        }
                        enemy.y += moveY;
                         if(checkTankObstacleCollision(enemy)) {
                            enemy.y -= moveY;
                            enemy.x += Math.sign(moveX) * currentSpeed; // Slide
                        }
                    } else { // Boss and Helicopter
                        enemy.x += moveX;
                        enemy.y += moveY;
                    }
                }
                
                // Shooting
                if (distToPlayer <= enemy.attackRange && enemy.type !== 'motorcycle') {
                    enemy.turretAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x) + Math.PI / 2;

                    if (enemy.type === 'boss') {
                        Object.keys(enemy.weaponCooldowns).forEach(weaponKey => {
                            if (enemy.weaponCooldowns[weaponKey] > 0) {
                                enemy.weaponCooldowns[weaponKey]--;
                            } else {
                                const shootX = enemy.x + Math.sin(enemy.turretAngle) * (enemy.width/2.2);
                                const shootY = enemy.y - Math.cos(enemy.turretAngle) * (enemy.width/2.2);
                                if (weaponKey === 'machineGun') {
                                    bullets.push({ x: shootX, y: shootY, angle: enemy.turretAngle, speed: 6, radius: 5, color: '#ff8888', owner: 'enemy' });
                                    enemy.weaponCooldowns[weaponKey] = Math.max(1, 5 - enemy.level);
                                } else if (weaponKey === 'missile') {
                                    bullets.push({ x: enemy.x, y: enemy.y, angle: enemy.turretAngle, speed: 3, radius: 8, color: '#ffcc00', owner: 'enemy', homing: true, turnSpeed: 0.04, life: 240, update: function() { this.life--; const targetAngle = Math.atan2(player.y - this.y, player.x - this.x) + Math.PI/2; let diff = targetAngle - this.angle; while(diff < -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2; this.angle += Math.max(-this.turnSpeed, Math.min(this.turnSpeed, diff)); } });
                                    enemy.weaponCooldowns[weaponKey] = Math.max(30, 100 - enemy.level * 10);
                                } else if (weaponKey === 'flamethrower') {
                                     for(let j = 0; j < 2; j++) {
                                        const dist = Math.random() * 200; const angleOffset = (Math.random() - 0.5) * 0.4;
                                        const fx = enemy.x + Math.cos(angleToTarget + angleOffset) * dist; const fy = enemy.y + Math.sin(angleToTarget + angleOffset) * dist;
                                        specialProjectiles.push({ type: 'flame', x:fx, y:fy, radius: Math.random() * 15, life: 0.8, color: `rgba(255, ${Math.random()*150}, 0, 0.8)`, update: function() { this.life -= 0.02; if(!player.isShielded && Math.hypot(this.x - player.x, this.y - player.y) < player.width/2 + this.radius) { player.health = Math.max(0, player.health - (0.1 * player.damageReduction)); if (player.health <= 0) gameOver(); } } });
                                     }
                                     enemy.weaponCooldowns[weaponKey] = Math.max(1, 5 - enemy.level);
                                }
                            }
                        });
                    } else { // Regular enemies
                        enemy.shootTimer--;
                        if(enemy.shootTimer <= 0 && !isGameOver) {
                             const shootX = enemy.x + Math.sin(enemy.turretAngle) * (enemy.width/2);
                             const shootY = enemy.y - Math.cos(enemy.turretAngle) * (enemy.width/2);
                             muzzleFlashes.push({ x: shootX, y: shootY, angle: enemy.turretAngle, life: 0.2 });
                             bullets.push({ x: shootX, y: shootY, angle: enemy.turretAngle, speed: 4, radius: 4, color: '#ff4444', owner: 'enemy' });
                            enemy.shootTimer = enemy.shootCooldown;
                        }
                    }
                }
            }
        }
        
        function updateBullets() {
            for(let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                if (b.update) {
                    b.update(); // For homing missiles
                } else if (b.life) {
                    b.life--; // For timed bullets like shrapnel
                }
                b.x += Math.sin(b.angle) * b.speed; b.y -= Math.cos(b.angle) * b.speed;
                if ((b.life !== undefined && b.life <= 0) || b.x < -b.radius || b.x > world.width + b.radius || b.y < -b.radius || b.y > world.height + b.radius || checkBulletObstacleCollision(b)) {
                    if (!isGameOver) createImpactEffect(b.x, b.y);
                    bullets.splice(i, 1);
                }
            }
        }
        
        function updateSpecialProjectiles() {
            for(let i = specialProjectiles.length - 1; i >= 0; i--) {
                const p = specialProjectiles[i];
                if(p.update) p.update();
                if (p.life <= 0) {
                    specialProjectiles.splice(i, 1);
                }
            }
        }

        function updateParticles() {
             for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;

                switch(p.type) {
                    case 'smoke':
                        p.radius += 0.1;
                        p.life -= 0.015;
                        break;
                    case 'track':
                        p.life -= 0.01;
                        break;
                    case 'confetti':
                        p.vy += 0.1; // Gravity
                        p.life -= 0.01;
                        break;
                    case 'fireworkRocket':
                        p.vy += 0.1;
                        p.life -= 0.02;
                        if (p.life <= 0) {
                            const explosionColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
                            for (let j = 0; j < 50; j++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = Math.random() * 5 + 1;
                                particles.push({
                                    type: 'fireworkParticle', x: p.x, y: p.y,
                                    vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                                    radius: Math.random() * 2 + 1, life: 1, color: explosionColor
                                });
                            }
                            particles.splice(i, 1);
                            continue;
                        }
                        break;
                    case 'fireworkParticle':
                        p.vy += 0.05;
                        p.life -= 0.015;
                        break;
                    case 'impact':
                    case 'explosion':
                    default:
                        p.life -= 0.05;
                        break;
                }

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
                muzzleFlashes[i].life -= 0.05;
                if (muzzleFlashes[i].life <= 0) muzzleFlashes.splice(i, 1);
            }
        }

        function updateFloatingTexts() {
            for(let i = floatingTexts.length - 1; i >= 0; i--) {
                const text = floatingTexts[i];
                text.y -= text.vy;
                text.life -= 0.02;
                if (text.life <= 0) floatingTexts.splice(i, 1);
            }
        }
        
        function updateXpOrbs() {
            const magnetRange = 100;
            const magnetSpeed = 8;
            for (let i = xpOrbs.length - 1; i >= 0; i--) {
                const orb = xpOrbs[i];
                let dist = Math.hypot(player.x - orb.x, player.y - orb.y);

                if (dist < magnetRange || orb.isAttracted) {
                    orb.isAttracted = true;
                    const angle = Math.atan2(player.y - orb.y, player.x - orb.x);
                    orb.x += Math.cos(angle) * magnetSpeed;
                    orb.y += Math.sin(angle) * magnetSpeed;
                    dist = Math.hypot(player.x - orb.x, player.y - orb.y); // Update dist after moving
                }

                if (dist < player.width / 2) {
                    addXP(orb.value);
                    xpOrbs.splice(i, 1);
                }
            }
        }
        
        function updateFlags() {
            // Determine capture time based on how many flags are already captured
            let captureTimeInSeconds = 10; // Default
            if (capturedFlags === 1) {
                captureTimeInSeconds = 20;
            } else if (capturedFlags === 2) {
                captureTimeInSeconds = 30;
            } else if (capturedFlags === 3) {
                captureTimeInSeconds = 40;
            }

            const captureSpeed = 1 / (captureTimeInSeconds * 60);
            const decaySpeed = captureSpeed / 2; // Half speed decay

            flags.forEach(flag => {
                if (flag.isCaptured) return;

                const dist = Math.hypot(player.x - flag.x, player.y - flag.y);
                if (dist < flag.captureRadius) {
                    flag.captureProgress = Math.min(1, flag.captureProgress + captureSpeed);
                    if (flag.captureProgress >= 1) {
                        flag.isCaptured = true;
                        capturedFlags++;
                        floatingTexts.push({ x: flag.x, y: flag.y, text: `KARARGAH ELE GEÇİRİLDİ!`, color: '#00ff88', life: 2, vy: 1, size: 24 });
                        showDiscardWeaponScreen(flag);
                        if (capturedFlags === 4 && !isFinalPhase) {
                            startFinalPhase();
                        }
                    }
                } else {
                    // Decay progress if player is outside the zone
                    flag.captureProgress = Math.max(0, flag.captureProgress - decaySpeed);
                }
            });
        }

        function updateFinalPhase() {
            if (!isFinalPhase || isGameOver) return;

            // Update firewall
            fireWallRadius -= 1.5 * player.damageReduction; // Adjust speed as needed
            const distFromCenter = Math.hypot(player.x - world.width/2, player.y - world.height/2);
            if (distFromCenter > fireWallRadius && !player.isShielded) {
                const firewallDamage = 0.5 * player.damageReduction;
                player.health = Math.max(0, player.health - firewallDamage);
                if (Math.random() < 0.1) {
                    triggerScreenShake(2, 5);
                    const damageText = gameMode === 'easy' ? Math.floor(firewallDamage) : firewallDamage.toFixed(1);
                    floatingTexts.push({ x: player.x, y: player.y, text: `-${damageText}`, color: '#ff6600', life: 0.5, vy: 1, size: 21 });
                }
                if (player.health <= 0) gameOver(false);
            }

            // Update escape plane capture
            const distToPlane = Math.hypot(player.x - escapePlane.x, player.y - escapePlane.y);
            if (distToPlane < escapePlane.captureRadius) {
                escapePlane.captureProgress += 1 / (10 * 60); // 10 seconds to capture
                if (escapePlane.captureProgress >= 1) {
                    gameWon();
                }
            }
        }
        
        function updateUI() {
            if(scoreEl) scoreEl.textContent = score;
            if(moneyEl) moneyEl.textContent = player.money;
            if (healthTextEl) healthTextEl.textContent = `${Math.ceil(player.health)} / ${player.maxHealth}`;
            
            const healthBar = document.getElementById('health-bar');
            if (healthBar) healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;

            if (levelValueEl) {
                levelValueEl.textContent = player.level;
            }
            if(flagCounterEl) flagCounterEl.textContent = `${capturedFlags}/4`;
            
            if (xpBarEl) xpBarEl.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
            
            if(dashSkillEl) {
                if(player.dashFuel >= player.maxDashFuel) dashSkillEl.classList.add('ready');
                else dashSkillEl.classList.remove('ready');
            }

            const fuelSegments = document.querySelectorAll('#dash-fuel-bar-container .fuel-segment');
            if (fuelSegments.length > 0) {
                const numSegments = fuelSegments.length;
                const fuelPerSegment = player.maxDashFuel / numSegments;
                // Use a slight tolerance to show the last bar when full
                const chargedSegments = Math.ceil(player.dashFuel / fuelPerSegment - 0.01);

                fuelSegments.forEach((segment, index) => {
                    if (index < chargedSegments) {
                        segment.classList.add('charged');
                    } else {
                        segment.classList.remove('charged');
                    }
                });
            }

            const shieldSegments = document.querySelectorAll('#shield-duration-bar-container .shield-segment');
            if (shieldSegments.length > 0) {
                const numSegments = shieldSegments.length;
                let chargedSegments = 0;

                if (player.isShielded) {
                    // Kalkan aktifken kalan süreyi göster
                    const progress = player.shieldTimer / player.shieldDuration;
                    chargedSegments = Math.ceil(progress * numSegments);
                } else if (player.shieldCooldownTimer <= 0) {
                    // Kalkan hazır
                    chargedSegments = numSegments;
                }
                // Bekleme süresindeyse, chargedSegments 0 kalır ve tüm çubuklar kapalı olur.

                shieldSegments.forEach((segment, index) => {
                    if (index < chargedSegments) {
                        segment.classList.add('charged');
                    } else {
                        segment.classList.remove('charged');
                    }
                });
            }

            if(shieldSkillEl) {
                if(player.shieldCooldownTimer > 0 || player.isShielded) shieldSkillEl.classList.remove('ready');
                else shieldSkillEl.classList.add('ready');
            }

            const minutes = Math.floor(gameTimeInSeconds / 60).toString().padStart(2, '0');
            const seconds = Math.floor(gameTimeInSeconds % 60).toString().padStart(2, '0');
            if(gameTimerEl) gameTimerEl.textContent = `${minutes}:${seconds}`;

            // Boss Bar Logic
            const activeBosses = enemies.filter(e => e.type === 'boss');
            isBossActive = activeBosses.length > 0;

            // UI Renk Değiştirme Sistemi
            if (isBossActive && uiColorState !== 'boss') {
                document.documentElement.style.setProperty('--crt-color', '#ff3333');
                document.documentElement.style.setProperty('--crt-glow', '0 0 5px #ff3333, 0 0 10px #ff3333, 0 0 15px #ff3333');
                document.documentElement.style.setProperty('--bar-bg', 'rgba(30, 10, 10, 0.5)');
                document.documentElement.style.setProperty('--dashboard-bg-start', '#14050a');
                document.documentElement.style.setProperty('--dashboard-bg-end', '#2a1016');
                document.documentElement.style.setProperty('--dashboard-border', '#2a000f');
                document.documentElement.style.setProperty('--info-display-bg', '#2a1a1a');
                document.documentElement.style.setProperty('--info-display-border', '#5a3c3c');
                document.documentElement.style.setProperty('--shield-color', '#ff3333');
                document.documentElement.style.setProperty('--shield-glow', '0 0 5px #ff3333, 0 0 10px #ff3333, 0 0 15px #ff3333');
                uiColorState = 'boss';
            } else if (!isBossActive && uiColorState !== 'normal') {
                document.documentElement.style.setProperty('--crt-color', '#00ff88');
                document.documentElement.style.setProperty('--crt-glow', '0 0 5px #00ff88, 0 0 10px #00ff88, 0 0 15px #00ff88');
                document.documentElement.style.setProperty('--bar-bg', 'rgba(10, 30, 10, 0.5)');
                document.documentElement.style.setProperty('--dashboard-bg-start', '#05140a');
                document.documentElement.style.setProperty('--dashboard-bg-end', '#102a16');
                document.documentElement.style.setProperty('--dashboard-border', '#002a0f');
                document.documentElement.style.setProperty('--info-display-bg', '#1a2a1a');
                document.documentElement.style.setProperty('--info-display-border', '#3c5a3c');
                document.documentElement.style.setProperty('--shield-color', '#00aaff');
                document.documentElement.style.setProperty('--shield-glow', '0 0 5px #00aaff, 0 0 10px #00aaff, 0 0 15px #00aaff');
                uiColorState = 'normal';
            }

            const displayedBars = Array.from(bossBarsWrapper.children);
            const activeBossIds = activeBosses.map(b => b.id);

            displayedBars.forEach(bar => {
                if (!activeBossIds.includes(bar.dataset.bossId)) bar.remove();
            });

            activeBosses.forEach(boss => {
                let barContainer = document.querySelector(`[data-boss-id="${boss.id}"]`);
                if (!barContainer) {
                    barContainer = document.createElement('div');
                    barContainer.className = 'boss-health-container';
                    barContainer.dataset.bossId = boss.id;
                    const bar = document.createElement('div');
                    bar.className = 'boss-health-bar';
                    const name = document.createElement('div');
                    name.className = 'boss-name';
                    const bossName = boss.id.toString().includes('final') ? `GUARDIAN #${boss.id.replace('bossfinal-', '')}` : `MECHA BOT #${boss.id.replace('boss', '')}`;
                    name.textContent = bossName;
                    barContainer.appendChild(bar);
                    barContainer.appendChild(name);
                    bossBarsWrapper.appendChild(barContainer);
                }
                const healthPercentage = (boss.health / boss.maxHealth) * 100;
                const bar = barContainer.querySelector('.boss-health-bar');
                if (bar) bar.style.width = `${healthPercentage}%`;
            });
            
            // --- UI Opacity based on Player Position ---
            const fadeDistance = 400;
            const minOpacity = 0.2;

            // Top Panel
            if (topHeadBandEl) {
                const distanceFromTop = player.y;
                let topOpacity = 1.0;
                if (distanceFromTop < fadeDistance) {
                    topOpacity = minOpacity + (distanceFromTop / fadeDistance) * (1.0 - minOpacity);
                }
                topHeadBandEl.style.opacity = Math.max(minOpacity, Math.min(1.0, topOpacity));
            }

            // Bottom Panel
            if (dashboardEl) {
                const distanceFromBottom = world.height - player.y;
                let bottomOpacity = 1.0;
                if (distanceFromBottom < fadeDistance) {
                    bottomOpacity = minOpacity + (distanceFromBottom / fadeDistance) * (1.0 - minOpacity);
                }
                dashboardEl.style.opacity = Math.max(minOpacity, Math.min(1.0, bottomOpacity));
            }

            if (player.type === 'armored') {
                magazineDisplayEl.style.display = 'flex';
                if (player.isReloading) {
                    magazineDisplayEl.innerHTML = `DOLDURULUYOR...`;
                } else {
                    magazineDisplayEl.innerHTML = `ŞARJÖR: <span>${player.magazine} / ${player.maxMagazine}</span>`;
                }
            } else {
                magazineDisplayEl.style.display = 'none';
            }
        }
        
        function updateWeaponUI() {
            weaponUIContainer.innerHTML = '';
            for (const id in player.weapons) {
                const weapon = WEAPONS[id];
                if (!weapon) continue;
                const level = player.weapons[id];
                const slot = document.createElement('div');
                slot.className = 'weapon-slot';

                const groupClass = WEAPON_GROUP_CLASS[id];
                if (groupClass) {
                    slot.classList.add(groupClass);
                }

                slot.innerHTML = `<span class="weapon-icon">${weapon.icon}</span><span class="weapon-level">Lvl ${level}</span><span class="weapon-damage" data-weapon-id="${id}">0</span>`;
                weaponUIContainer.appendChild(slot);
            }
        }
        
        function updateWeaponDamageUI() {
            if (gamePaused || isGameOver) return;
            for (const weaponId in weaponDamageStats) {
                const damageEl = document.querySelector(`.weapon-damage[data-weapon-id="${weaponId}"]`);
                if (damageEl) {
                    damageEl.textContent = Math.floor(weaponDamageStats[weaponId]);
                }
            }

            // Special case for Tamirci to show healing instead of damage
            if (player.weapons['vampire']) {
                const tamirciEl = document.querySelector(`.weapon-damage[data-weapon-id="vampire"]`);
                if (tamirciEl) {
                    const totalHealed = weaponDamageStats['vampire'] || 0;
                    tamirciEl.textContent = `+${Math.floor(totalHealed)}`;
                    tamirciEl.style.color = '#00ff88';
                }
            }

            // Special case for Robo-Spider to show XP collected
            if (player.weapons['roboSpider']) {
                const spiderEl = document.querySelector(`.weapon-damage[data-weapon-id="roboSpider"]`);
                if (spiderEl) {
                    const totalXp = weaponDamageStats['roboSpider'] || 0;
                    spiderEl.textContent = `${Math.floor(totalXp)} XP`;
                    spiderEl.style.color = '#00aaff';
                }
            }
        }

        // --- WEAPON SYSTEM ---
        const WEAPON_GROUP_CLASS = {
            'defaultGun': 'mermi-manyagi', 'railgun': 'mermi-manyagi', 'shotgun': 'mermi-manyagi', 'barrage': 'mermi-manyagi', 'shrapnel': 'mermi-manyagi',
            'mortar': 'kundakci', 'flamethrower': 'kundakci', 'flameTrail': 'kundakci', 'flameDance': 'kundakci',
            'laser': 'teknoloji-meraklisi', 'chain': 'teknoloji-meraklisi', 'missile': 'teknoloji-meraklisi', 'pulseCannon': 'teknoloji-meraklisi',
            'mines': 'oyuncak-sever', 'turret': 'oyuncak-sever', 'drone': 'oyuncak-sever', 'roboSpider': 'oyuncak-sever'
        };
        const WEAPONS = {};
        const STAT_UPGRADES = {
            'moveSpeed': { name: 'Hareket Hızı', icon: '🏃', description: 'Hızı kalıcı olarak %10 arttırır.', apply: () => { player.speed = Math.min(6, player.speed * 1.10); } },
            'maxHealth': { name: 'Ekstra Zırh', icon: '❤️', description: 'Maksimum zırhı 25 arttırır.', apply: () => { const oldMaxHealth = player.maxHealth; player.maxHealth = Math.min(500, player.maxHealth + 25); player.health += (player.maxHealth - oldMaxHealth); } },
            'shieldDuration': { name: 'Kalkan Süresi', icon: '🛡️', description: 'Kalkan süresini %20 arttırır (maks 7 san.).', apply: () => { player.shieldDuration = Math.min(420, player.shieldDuration * 1.20); } },
            'xpGain': { name: 'TP Çarpanı', icon: '⬆️', description: 'Tecrübe puanı kazanımını %15 arttırır.', apply: () => { player.xpGainMultiplier *= 1.15; } }
        };
        
        function findClosestEnemy(range, from = player, excludedIds = new Set()) {
             let closestEnemy = null;
            let minDistance = Infinity;
            enemies.forEach(enemy => {
                if (excludedIds.has(enemy.id)) return;
                const dist = Math.hypot(from.x - enemy.x, from.y - enemy.y);
                if (dist < minDistance && dist <= range) {
                    minDistance = dist;
                    closestEnemy = enemy;
                }
            });
            return closestEnemy;
        }

        function getAngleToClosestEnemy(range) {
            const closestEnemy = findClosestEnemy(range);
            if (closestEnemy) {
                return Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x) + Math.PI / 2;
            }
            return null;
        }

        function fireDefaultGun(level) {
            if (player.type === 'helicopter') {
                // Helikopter için yeni seri atış mantığı
                const closestEnemy = findClosestEnemy(600); // Helikopterlerin menzili biraz daha fazla
                if (!closestEnemy) return;

                const fireAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x) + Math.PI / 2;
                const shootX = player.x + Math.sin(player.turretAngle) * 30;
                const shootY = player.y - Math.cos(player.turretAngle) * 30;
                const bulletSpeed = 15; // Hızlı mermiler
                const bulletDamage = (VEHICLE_BASE_DAMAGE[player.vehicleType] || 3) + (level - 1) * 1;   // Her mermi için hasar
                const burstCount = 5;     // 5'li atış
                const delayBetweenShots = 50; // Atışlar arası 50ms gecikme

                const finalDamage = bulletDamage * player.damageBonusMultiplier;

                for (let i = 0; i < burstCount; i++) {
                    setTimeout(() => {
                        if (isGameOver || gamePaused) return;
                        muzzleFlashes.push({ x: shootX, y: shootY, angle: player.turretAngle, life: 0.2 });
                        // Seri atışa hafif bir yayılım ekle
                        const spreadAngle = fireAngle + (Math.random() - 0.5) * 0.1;
                        bullets.push({ x: shootX, y: shootY, angle: spreadAngle, speed: bulletSpeed, radius: 4, color: '#ffffff', owner: 'player', damage: finalDamage, hitEnemies: [], weaponId: 'defaultGun' });
                    }, i * delayBetweenShots);
                }

                const cooldown = player.isMoving ? 90 : 60; // Tüm seri atış için bekleme süresi
                player.weaponCooldowns.defaultGun = (cooldown - (player.defaultGunCooldownBonus || 0)) * player.fireRateBonus;

            } else if (player.type === 'armored') {
                // Check if reloading
                if (player.isReloading) return;

                // Check if magazine is empty
                if (player.magazine <= 0) {
                    player.isReloading = true;
                    player.reloadTimer = player.reloadTime; // 2 seconds
                    floatingTexts.push({ x: player.x, y: player.y - 40, text: `DOLDURULUYOR...`, color: '#ffff00', life: 2, vy: 0, size: 20 });
                    return;
                }

                // Zırhlı araç için makineli tüfek
                const closestEnemy = findClosestEnemy(500);
                if (!closestEnemy) return;

                player.magazine--;

                const fireAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x) + Math.PI / 2;
                const shootX = player.x + Math.sin(player.turretAngle) * 30;
                const shootY = player.y - Math.cos(player.turretAngle) * 30;
                const bulletSpeed = 18;
                const bulletDamage = (VEHICLE_BASE_DAMAGE[player.vehicleType] || 1) + (level - 1) * 0.5; // Her mermi hasarı

                const finalDamage = bulletDamage * player.damageBonusMultiplier;

                muzzleFlashes.push({ x: shootX, y: shootY, angle: player.turretAngle, life: 0.1 });
                const spreadAngle = fireAngle + (Math.random() - 0.5) * 0.15; // Hafif bir yayılım
                bullets.push({ x: shootX, y: shootY, angle: spreadAngle, speed: bulletSpeed, radius: 3, color: '#ffeb3b', owner: 'player', damage: finalDamage, hitEnemies: [], weaponId: 'defaultGun' });

                // Hızlı ateş için kısa bekleme süresi
                const cooldown = 5; // 5 frame bekleme süresi
                player.weaponCooldowns.defaultGun = (cooldown - (player.defaultGunCooldownBonus || 0)) * player.fireRateBonus;

            } else {
                // Tanklar için mevcut mantık
                const stats_arr = [
                    { damage: 15, cooldown: 100, speed: 6, size: 5, range: 320 },
                    { damage: 24, cooldown: 100, speed: 6, size: 5, range: 340 },
                    { damage: 34, cooldown: 100, speed: 7, size: 6, range: 360 },
                    { damage: 43, cooldown: 100, speed: 7, size: 6, range: 380 },
                    { damage: 53, cooldown: 100, speed: 8, size: 7, range: 400 },
                    { damage: 62, cooldown: 100, speed: 8, size: 7, range: 420 },
                    { damage: 72, cooldown: 100, speed: 9, size: 8, range: 440 },
                    { damage: 81, cooldown: 100, speed: 9, size: 8, range: 460 },
                    { damage: 91, cooldown: 100, speed: 10, size: 9, range: 480 },
                    { damage: 100, cooldown: 100, speed: 10, size: 10, range: 500 },
                ];
                
                const stats = level <= 10 ? stats_arr[level - 1] : { ...stats_arr[9], cooldown: 100, range: 500 };
                
                const closestEnemy = findClosestEnemy(stats.range);
                if (!closestEnemy) return;
    
                let fireAngle = player.turretAngle;
    
                const shootX = player.x + Math.sin(player.turretAngle) * 30;
                const shootY = player.y - Math.cos(player.turretAngle) * 30;
                muzzleFlashes.push({ x: shootX, y: shootY, angle: player.turretAngle, life: 0.2 });
                
                const isStationaryBonus = !player.isMoving;

                // Aracın temel hasarını al, seviye hasarını ekle
                const originalBaseDamage = 15; // Orijinal Seviye 1 hasarı
                const vehicleModifier = (VEHICLE_BASE_DAMAGE[player.vehicleType] || 15) - originalBaseDamage;
                let baseDamageFromLevel = (level <= 10 ? stats.damage : 100 + (level - 10) * 5);
                let baseDamage = baseDamageFromLevel + vehicleModifier;
    
                let finalDamage = (baseDamage + player.damageBonus) * player.damageBonusMultiplier;
    
                if (isStationaryBonus) {
                    finalDamage *= 2;
                }
    
                bullets.push({ x: shootX, y: shootY, angle: fireAngle, speed: stats.speed, radius: stats.size, color: '#00ff88', owner: 'player', damage: finalDamage, hitEnemies: [], isStationaryBonus: isStationaryBonus, weaponId: 'defaultGun' });
                player.weaponCooldowns.defaultGun = (stats.cooldown - (player.defaultGunCooldownBonus || 0)) * player.fireRateBonus;
            }
        }

        function fireMortar(level) {
            const stats = [
                { damage: 15, cooldown: 120, radius: 40, range: 500 }, // Level 1
                { damage: 20, cooldown: 110, radius: 45, range: 550 }, // Level 2
                { damage: 25, cooldown: 100, radius: 50, range: 600 }, // Level 3
                { damage: 30, cooldown: 90, radius: 55, range: 650 }, // Level 4
                { damage: 40, cooldown: 80, radius: 60, range: 700 }, // Level 5
                { damage: 50, cooldown: 75, radius: 65, range: 725 }, // Level 6
                { damage: 60, cooldown: 70, radius: 70, range: 750 }, // Level 7
                { damage: 75, cooldown: 65, radius: 75, range: 775 }, // Level 8
                { damage: 90, cooldown: 60, radius: 80, range: 800 }, // Level 9
                { damage: 110, cooldown: 55, radius: 90, range: 850 }, // Level 10
            ][level - 1];
            if (player.weaponCooldowns.mortar > 0) return;

            const target = findClosestEnemy(stats.range);
            if (!target) return;
            
            const finalDamage = stats.damage * player.damageBonusMultiplier;

            specialProjectiles.push({
                type: 'mortarTarget',
                x: target.x, y: target.y,
                life: 60, maxLife: 60,
                initialRadius: stats.radius,
                damage: finalDamage,
                fireDuration: 180, // 3 seconds
                weaponId: 'mortar',
                update: function() {
                    this.life--;
                    if (this.life <= 0) {
                        createExplosion(this.x, this.y, 'orange');
                        specialProjectiles.push({
                            type: 'firePatch',
                            x: this.x, y: this.y,
                            radius: this.initialRadius,
                            life: this.fireDuration, maxLife: this.fireDuration,
                            damage: this.damage, // Pass the total damage to the firePatch object
                            damagePerFrame: this.damage / this.fireDuration, // HATA DÜZELTİLDİ: / 2 kaldırıldı
                            weaponId: this.weaponId,
                            update: function() {
                                this.life--;
                                enemies.forEach(e => {
                                    if (Math.hypot(this.x - e.x, this.y - e.y) < this.radius + e.width/2) {
                                        e.health -= this.damagePerFrame;
                                        if (weaponDamageStats.hasOwnProperty(this.weaponId)) {
                                            weaponDamageStats[this.weaponId] += this.damagePerFrame;
                                        }
                                        if (ACHIEVEMENT_SETS.kundakci.isApplied) {
                                            e.isBurning = true;
                                            e.burnDamage = this.damage * 0.5;
                                        }
                                        if (Math.random() < 0.1) {
                                             floatingTexts.push({ x: e.x + (Math.random()-0.5)*20, y: e.y + (Math.random()-0.5)*20, text: `${this.damagePerFrame.toFixed(1)}`, color: '#ff6600', life: 0.5, vy: 1, size: 18 });
                                        }
                                    }
                                });
                            }
                        });
                        
                        enemies.forEach(enemy => {
                            if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < this.initialRadius) {
                                const burstDamage = this.damage; // HATA DÜZELTİLDİ: / 2 kaldırıldı
                                enemy.health -= burstDamage;
                                if (weaponDamageStats.hasOwnProperty(this.weaponId)) {
                                    weaponDamageStats[this.weaponId] += burstDamage;
                                }
                                floatingTexts.push({ x: enemy.x, y: enemy.y, text: `${Math.floor(burstDamage)}`, color: '#ff9900', life: 1, vy: 1, size: 24 });
                            }
                        });
                        this.life = -1; // Mark for deletion
                    }
                }
            });

            player.weaponCooldowns.mortar = stats.cooldown * player.fireRateBonus;
        }
        
        function fireLaser(level) {
            const stats = [
                { damage: 0.5, cooldown: 1, width: 3, range: 450 },
                { damage: 0.7, cooldown: 1, width: 3, range: 475 },
                { damage: 0.9, cooldown: 1, width: 4, range: 500 },
                { damage: 1.1, cooldown: 1, width: 4, range: 525 },
                { damage: 1.4, cooldown: 1, width: 5, range: 550 },
                { damage: 1.7, cooldown: 1, width: 5, range: 575 },
                { damage: 2.0, cooldown: 1, width: 6, range: 600 },
                { damage: 2.4, cooldown: 1, width: 6, range: 625 },
                { damage: 2.8, cooldown: 1, width: 7, range: 650 },
                { damage: 3.5, cooldown: 1, width: 8, range: 700 },
            ][level - 1];

            const target = findClosestEnemy(stats.range);
            
            if (!target) {
                laserTargetId = null;
                laserFocusTime = 0;
                laserCumulativeDamage = 0;
                return;
            }
            
            if (target.id === laserTargetId) {
                laserFocusTime++;
            } else {
                laserTargetId = target.id;
                laserFocusTime = 0;
                laserCumulativeDamage = 0;
            }

            // Hasar çarpanı saniyede %100 artar, maksimum 8 kat hasar.
            const focusMultiplier = Math.min(8, 1 + (laserFocusTime / 60) * 1); 
            
            const finalDamage = stats.damage * player.damageBonusMultiplier * focusMultiplier;
            laserCumulativeDamage += finalDamage;

            specialProjectiles.push({
                type: 'laser', x: player.x, y: player.y, targetX: target.x, targetY: target.y,
                width: stats.width + (focusMultiplier - 1) * 2,
                color: `rgb(255, ${Math.max(0, 255 - Math.floor((focusMultiplier-1)*80))}, 255)`,
                life: 0.1, 
                update: function() { this.life -= 0.05; }
            });

            target.health -= finalDamage;
            if (weaponDamageStats.hasOwnProperty('laser')) {
                weaponDamageStats['laser'] += finalDamage;
            }
            
            // Remove previous laser damage text for the same target to avoid overlap
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                if (floatingTexts[i].weaponId === 'laser_cumulative') {
                    floatingTexts.splice(i, 1);
                }
            }
            
            const textColor = `rgb(255, ${Math.max(0, 255 - Math.floor((focusMultiplier-1)*80))}, 255)`;
            floatingTexts.push({ 
                x: target.x, 
                y: target.y - target.width / 2, 
                text: `${Math.floor(laserCumulativeDamage)}`, 
                color: textColor, 
                life: 0.2, 
                vy: 0, 
                size: 20 + (focusMultiplier - 1) * 4,
                weaponId: 'laser_cumulative',
                isOpaque: true
             });
            player.weaponCooldowns.laser = stats.cooldown * player.fireRateBonus;
        }

        function fireMines(level) {
             const stats = [
                { damage: 40, cooldown: 150, radius: 60 },
                { damage: 50, cooldown: 135, radius: 70 },
                { damage: 60, cooldown: 120, radius: 80 },
                { damage: 70, cooldown: 105, radius: 90 },
                { damage: 80, cooldown: 90, radius: 100 },
                { damage: 90, cooldown: 85, radius: 110 },
                { damage: 100, cooldown: 80, radius: 120 },
                { damage: 110, cooldown: 75, radius: 130 },
                { damage: 120, cooldown: 70, radius: 140 },
                { damage: 150, cooldown: 60, radius: 150 },
            ][level - 1];

            const offsetAngle = Math.random() * Math.PI * 2;
            const offsetDist = Math.random() * 40 + 20;
            const spawnX = player.x + Math.cos(offsetAngle) * offsetDist;
            const spawnY = player.y + Math.sin(offsetAngle) * offsetDist;

            specialProjectiles.push({
                type: 'mine', x: spawnX, y: spawnY, radius: 8, life: Infinity, armTimer: 60, armed: false, explosionRadius: stats.radius,
                weaponId: 'mines',
                update: function() {
                    if (!this.armed) {
                        this.armTimer--;
                        if(this.armTimer <= 0) this.armed = true;
                    }
                    if (this.armed) {
                        let triggered = false;
                        enemies.forEach(enemy => {
                            // Sadece mayının merkeziyle düşmanın gövdesi temas ederse tetikle
                            if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < this.radius + enemy.width / 2) {
                                triggered = true;
                            }
                        });

                        if (triggered) {
                            createExplosion(this.x, this.y, '#ff5500');
                            const finalDamage = stats.damage * player.damageBonusMultiplier;
                            enemies.forEach(e => {
                                if(Math.hypot(this.x - e.x, this.y - e.y) < this.explosionRadius) {
                                     e.health -= finalDamage;
                                     if (weaponDamageStats.hasOwnProperty(this.weaponId)) {
                                        weaponDamageStats[this.weaponId] += finalDamage;
                                     }
                                     floatingTexts.push({ x: e.x, y: e.y, text: `${Math.floor(finalDamage)}`, color: '#ff5500', life: 1, vy: 1, size: 24 });
                                }
                            });
                            this.life = 0; // Set life to 0 to be removed
                        }
                    }
                }
            });
            player.weaponCooldowns.mines = stats.cooldown * player.fireRateBonus;
        }
        
        function fireTurret(level) {
             const stats = [
                { damage: 10, cooldown: 200, life: 300, shotCooldown: 40, range: 350 },
                { damage: 12, cooldown: 180, life: 350, shotCooldown: 35, range: 400 },
                { damage: 15, cooldown: 160, life: 400, shotCooldown: 30, range: 450 },
                { damage: 18, cooldown: 140, life: 450, shotCooldown: 25, range: 500 },
                { damage: 22, cooldown: 120, life: 500, shotCooldown: 20, range: 550 },
                { damage: 25, cooldown: 110, life: 550, shotCooldown: 18, range: 575 },
                { damage: 28, cooldown: 100, life: 600, shotCooldown: 16, range: 600 },
                { damage: 32, cooldown: 90, life: 650, shotCooldown: 14, range: 625 },
                { damage: 36, cooldown: 80, life: 700, shotCooldown: 12, range: 650 },
                { damage: 40, cooldown: 70, life: 800, shotCooldown: 10, range: 700 },
            ][level - 1];

            const offsetAngle = Math.random() * Math.PI * 2;
            const offsetDist = Math.random() * 40 + 20;
            const spawnX = player.x + Math.cos(offsetAngle) * offsetDist;
            const spawnY = player.y + Math.sin(offsetAngle) * offsetDist;

             specialProjectiles.push({
                type: 'turret', x: spawnX, y: spawnY, radius: 10, life: stats.life,
                shotTimer: 0,
                weaponId: 'turret',
                update: function() {
                    this.life--;
                    this.shotTimer--;
                    if (this.shotTimer <= 0) {
                        let closestEnemy = null;
                        let minDistance = Infinity;
                        enemies.forEach(enemy => {
                            const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                            if (dist < minDistance && dist <= stats.range) {
                                minDistance = dist;
                                closestEnemy = enemy;
                            }
                        });
                        if (closestEnemy) {
                            const angle = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x);
                            const finalDamage = stats.damage * player.damageBonusMultiplier;
                            bullets.push({ x: this.x, y: this.y, angle: angle + Math.PI/2, speed: 9, radius: 4, color: '#ddd', owner: 'player', damage: finalDamage, hitEnemies: [], weaponId: this.weaponId, life: 120 });
                            this.shotTimer = stats.shotCooldown * player.fireRateBonus;
                        }
                    }
                }
            });
            player.weaponCooldowns.turret = stats.cooldown * player.fireRateBonus;
        }

        function fireChain(level) {
            const stats = [
                { damage: 10, cooldown: 40, chains: 2, range: 500, ricochetRange: 250 },
                { damage: 12, cooldown: 38, chains: 2, range: 525, ricochetRange: 275 },
                { damage: 14, cooldown: 36, chains: 3, range: 550, ricochetRange: 300 },
                { damage: 16, cooldown: 34, chains: 3, range: 575, ricochetRange: 325 },
                { damage: 18, cooldown: 32, chains: 4, range: 600, ricochetRange: 350 },
                { damage: 20, cooldown: 30, chains: 4, range: 625, ricochetRange: 375 },
                { damage: 22, cooldown: 28, chains: 5, range: 650, ricochetRange: 400 },
                { damage: 25, cooldown: 26, chains: 5, range: 675, ricochetRange: 425 },
                { damage: 28, cooldown: 24, chains: 6, range: 700, ricochetRange: 450 },
                { damage: 32, cooldown: 20, chains: 7, range: 750, ricochetRange: 500 },
            ][level - 1];

            const initialTarget = findClosestEnemy(stats.range);
            if (!initialTarget) return;

            const hitTargets = [initialTarget];
            const hitEnemyIds = new Set([initialTarget.id]);
            let lastTarget = initialTarget;
            
            for (let i = 0; i < stats.chains; i++) {
                const nextTarget = findClosestEnemy(stats.ricochetRange, lastTarget, hitEnemyIds);
                if (nextTarget) {
                    hitTargets.push(nextTarget);
                    hitEnemyIds.add(nextTarget.id);
                    lastTarget = nextTarget;
                } else {
                    break;
                }
            }

            const finalDamage = stats.damage * player.damageBonusMultiplier;
            const pathPoints = [{ x: player.x, y: player.y }]; // Start from player
            
            hitTargets.forEach(target => {
                target.health -= finalDamage;
                if (weaponDamageStats.hasOwnProperty('chain')) {
                    weaponDamageStats['chain'] += finalDamage;
                }
                floatingTexts.push({ x: target.x, y: target.y, text: `${Math.floor(finalDamage)}`, color: '#00aaff', life: 1, vy: 1, size: 24 });
                pathPoints.push({ x: target.x, y: target.y });
            });

            // Create a single special projectile for the entire chain
            specialProjectiles.push({
                type: 'chainLightningEffect',
                points: pathPoints,
                life: 0.2, // Short duration for the visual effect
                update: function() { this.life -= 0.05; }
            });

            player.weaponCooldowns.chain = stats.cooldown * player.fireRateBonus;
        }

        function fireRailgun(level) {
             const stats = [ 
                 { damage: 40, cooldown: 100, speed: 20, size: 4, range: 550 }, 
                 { damage: 50, cooldown: 90, speed: 22, size: 4, range: 600 }, 
                 { damage: 60, cooldown: 80, speed: 24, size: 5, range: 650 }, 
                 { damage: 70, cooldown: 70, speed: 26, size: 5, range: 700 }, 
                 { damage: 80, cooldown: 60, speed: 28, size: 6, range: 750 },
                 { damage: 90, cooldown: 55, speed: 30, size: 6, range: 800 },
                 { damage: 100, cooldown: 50, speed: 32, size: 7, range: 850 },
                 { damage: 115, cooldown: 45, speed: 34, size: 7, range: 900 },
                 { damage: 130, cooldown: 40, speed: 36, size: 8, range: 950 },
                 { damage: 150, cooldown: 35, speed: 40, size: 9, range: 1000 },
            ][level - 1];

            const closestEnemy = findClosestEnemy(stats.range);
            if(!closestEnemy) return;

            let fireAngle;
            if (player.type === 'helicopter') {
                fireAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x) + Math.PI / 2;
            } else {
                fireAngle = player.turretAngle;
            }

             const shootX = player.x + Math.sin(player.turretAngle) * 30; const shootY = player.y - Math.cos(player.turretAngle) * 30;
             muzzleFlashes.push({ x: shootX, y: shootY, angle: player.turretAngle, life: 0.2 });
             const finalDamage = stats.damage * player.damageBonusMultiplier;
             bullets.push({ x: shootX, y: shootY, angle: fireAngle, speed: stats.speed, radius: stats.size, color: '#cc33ff', owner: 'player', damage: finalDamage, canPierce: true, maxHits: level + 1, hitEnemies: [], weaponId: 'railgun' });
             player.weaponCooldowns.railgun = stats.cooldown * player.fireRateBonus;
        }
        function fireMissile(level) {
             // Düşman yoksa ateş etmeyi engellemek için doğrudan düşman dizisini kontrol et.
             if (enemies.length === 0) {
                 player.weaponCooldowns.missile = 10; // Tekrar denemeden önce kısa bir süre bekle.
                 return;
             }

             const stats = [ 
                 { damage: 25, cooldown: 90, count: 1, speed: 6.0 }, 
                 { damage: 25, cooldown: 80, count: 2, speed: 6.4 }, 
                 { damage: 30, cooldown: 70, count: 2, speed: 6.8 }, 
                 { damage: 30, cooldown: 60, count: 3, speed: 7.2 }, 
                 { damage: 35, cooldown: 50, count: 4, speed: 7.6 },
                 { damage: 35, cooldown: 45, count: 5, speed: 8.0 },
                 { damage: 40, cooldown: 40, count: 6, speed: 8.4 },
                 { damage: 40, cooldown: 35, count: 7, speed: 8.8 },
                 { damage: 45, cooldown: 30, count: 8, speed: 9.2 },
                 { damage: 50, cooldown: 25, count: 9, speed: 9.6 },
            ][level - 1];
             
             const finalDamage = stats.damage * player.damageBonusMultiplier;
             for (let i = 0; i < stats.count; i++) {
                 const angle = Math.random() * Math.PI * 2; const x = player.x + Math.sin(angle) * 20; const y = player.y - Math.cos(angle) * 20;
                 bullets.push({ 
                    x, y, angle, speed: stats.speed, 
                    radius: 6, // for collision
                    width: 6, // for drawing
                    height: 14, // for drawing
                    color: '#ffffff', // Beyaz renk
                    owner: 'player', 
                    damage: finalDamage, 
                    homing: true, 
                    turnSpeed: 0.05, 
                    life: 180, 
                    weaponId: 'missile', 
                    shape: 'missile', // Özel çizim için
                    update: function() { 
                        this.life--; 
                        const target = findClosestEnemy(1000); 
                        if(target) { 
                            const targetAngle = Math.atan2(target.y - this.y, target.x - this.x) + Math.PI/2; 
                            let diff = targetAngle - this.angle; 
                            while(diff < -Math.PI) diff += Math.PI*2; 
                            while(diff > Math.PI) diff -= Math.PI*2; 
                            this.angle += Math.max(-this.turnSpeed, Math.min(this.turnSpeed, diff)); 
                        }
                        // Duman efekti
                        if (Math.random() < 0.9) { // Daha sık parçacık oluştur
                            particles.push({
                                type: 'smoke',
                                x: this.x - Math.sin(this.angle) * 8,
                                y: this.y + Math.cos(this.angle) * 8,
                                vx: (Math.random() - 0.5) * 0.2,
                                vy: (Math.random() - 0.5) * 0.2,
                                radius: Math.random() * 3 + 2, // Biraz daha büyük parçacıklar
                                life: 1.5 // Daha uzun ömür
                            });
                        }
                    } 
                });
             }
             player.weaponCooldowns.missile = stats.cooldown * player.fireRateBonus;
        }
        function fireShotgun(level) {
             const stats = [ 
                 { damage: 5, cooldown: 50, count: 3 }, 
                 { damage: 6, cooldown: 45, count: 4 }, 
                 { damage: 7, cooldown: 40, count: 4 }, 
                 { damage: 8, cooldown: 35, count: 5 }, 
                 { damage: 9, cooldown: 30, count: 6 },
                 { damage: 10, cooldown: 28, count: 6 },
                 { damage: 11, cooldown: 26, count: 7 },
                 { damage: 12, cooldown: 24, count: 7 },
                 { damage: 13, cooldown: 22, count: 8 },
                 { damage: 15, cooldown: 20, count: 9 },
            ][level - 1];
             const closestEnemy = findClosestEnemy(250);
             if(!closestEnemy) return;

             let fireAngle;
             if (player.type === 'helicopter') {
                fireAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x) + Math.PI / 2;
             } else {
                fireAngle = player.turretAngle;
             }

             const shootX = player.x + Math.sin(player.turretAngle) * 30; const shootY = player.y - Math.cos(player.turretAngle) * 30; muzzleFlashes.push({ x: shootX, y: shootY, angle: player.turretAngle, life: 0.2 });
             const spread = 0.4;
             const finalDamage = stats.damage * player.damageBonusMultiplier;
             for (let i = 0; i < stats.count; i++) {
                 const angle = fireAngle + (Math.random() - 0.5) * spread;
                 bullets.push({ x: shootX, y: shootY, angle, speed: 7, radius: 3, color: '#ff6600', owner: 'player', damage: finalDamage, hitEnemies: [], weaponId: 'shotgun' });
             }
             player.weaponCooldowns.shotgun = stats.cooldown * player.fireRateBonus;
        }
        function fireFlamethrower(level) {
             const stats = [ 
                 { damage: 0.2, cooldown: 3, range: 150, size: 8 }, 
                 { damage: 0.3, cooldown: 3, range: 160, size: 10 }, 
                 { damage: 0.4, cooldown: 2, range: 170, size: 12 }, 
                 { damage: 0.5, cooldown: 2, range: 180, size: 14 }, 
                 { damage: 0.6, cooldown: 1, range: 200, size: 16 },
                 { damage: 0.7, cooldown: 1, range: 210, size: 18 },
                 { damage: 0.8, cooldown: 1, range: 220, size: 20 },
                 { damage: 1.0, cooldown: 1, range: 230, size: 22 },
                 { damage: 1.2, cooldown: 1, range: 240, size: 24 },
                 { damage: 1.5, cooldown: 1, range: 250, size: 28 },
            ][level - 1];
             const finalDamage = stats.damage * player.damageBonusMultiplier;

             let fireAngle;
             if (player.type === 'helicopter') {
                const closestEnemy = findClosestEnemy(stats.range);
                if (!closestEnemy) return;
                fireAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
             } else {
                fireAngle = player.turretAngle - Math.PI/2;
             }

             for(let i = 0; i < 3; i++) {
                 const dist = Math.random() * stats.range; const angleOffset = (Math.random() - 0.5) * 0.5;
                 const x = player.x + Math.cos(fireAngle + angleOffset) * dist; const y = player.y + Math.sin(fireAngle + angleOffset) * dist;
                 specialProjectiles.push({ type: 'flame', x, y, radius: Math.random() * stats.size, life: 0.5, color: `rgba(255, ${Math.random()*150}, 0, 0.8)`, weaponId: 'flamethrower', update: function() { this.life -= 0.02; enemies.forEach(e => { if(Math.hypot(this.x - e.x, this.y - e.y) < e.width/2 + this.radius) { e.health -= finalDamage; if(weaponDamageStats.hasOwnProperty(this.weaponId)) weaponDamageStats[this.weaponId] += finalDamage; if(ACHIEVEMENT_SETS.kundakci.isApplied) { e.isBurning = true; e.burnDamage = finalDamage * 60 * 0.5; } } }); } });
             }
             player.weaponCooldowns.flamethrower = stats.cooldown * player.fireRateBonus;
        }
        function fireVampire(level) {
            const stats = [
                { healPerSecond: 0.5, cooldown: 1 },
                { healPerSecond: 0.7, cooldown: 1 },
                { healPerSecond: 0.9, cooldown: 1 },
                { healPerSecond: 1.1, cooldown: 1 },
                { healPerSecond: 1.4, cooldown: 1 },
                { healPerSecond: 1.7, cooldown: 1 },
                { healPerSecond: 2.0, cooldown: 1 },
                { healPerSecond: 2.4, cooldown: 1 },
                { healPerSecond: 2.8, cooldown: 1 },
                { healPerSecond: 3.5, cooldown: 1 },
            ][level - 1];
            
            const healPerFrame = stats.healPerSecond / 60;
            const healthBeforeHeal = player.health;
            player.health = Math.min(player.maxHealth, healthBeforeHeal + healPerFrame);
            const actualHeal = player.health - healthBeforeHeal;

            if (weaponDamageStats.hasOwnProperty('vampire')) {
                weaponDamageStats['vampire'] += actualHeal;
            }
            player.weaponCooldowns.vampire = stats.cooldown;
        }
        
        function fireShrapnel(level) {
             const stats = [ 
                 { damage: 30, cooldown: 60, pieces: 4, pieceDamage: 10 },
                 { damage: 35, cooldown: 55, pieces: 5, pieceDamage: 12 },
                 { damage: 40, cooldown: 50, pieces: 5, pieceDamage: 14 },
                 { damage: 45, cooldown: 45, pieces: 6, pieceDamage: 16 },
                 { damage: 50, cooldown: 40, pieces: 6, pieceDamage: 18 },
                 { damage: 55, cooldown: 38, pieces: 7, pieceDamage: 20 },
                 { damage: 60, cooldown: 36, pieces: 7, pieceDamage: 22 },
                 { damage: 65, cooldown: 34, pieces: 8, pieceDamage: 24 },
                 { damage: 70, cooldown: 32, pieces: 8, pieceDamage: 26 },
                 { damage: 80, cooldown: 30, pieces: 10, pieceDamage: 30 },
            ][level - 1];
             const closestEnemy = findClosestEnemy(450);
             if(!closestEnemy) return;

             let fireAngle;
             if (player.type === 'helicopter') {
                fireAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x) + Math.PI / 2;
             } else {
                fireAngle = player.turretAngle;
             }

             const shootX = player.x + Math.sin(player.turretAngle) * 30; const shootY = player.y - Math.cos(player.turretAngle) * 30;
             const finalDamage = stats.damage * player.damageBonusMultiplier;
             const finalPieceDamage = stats.pieceDamage * player.damageBonusMultiplier;

             bullets.push({ 
                 x: shootX, y: shootY, angle: fireAngle, speed: 5, radius: 7, color: '#ff9900', owner: 'player', damage: finalDamage, weaponId: 'shrapnel',
                 onHit: (enemy, dmg) => { 
                     for(let i=0; i<stats.pieces; i++) { 
                         bullets.push({
                             x: enemy.x, y: enemy.y, angle: Math.random() * Math.PI * 2, speed: 4 + Math.random() * 2, radius: 3, 
                             color: '#ffcc00', owner: 'player', damage: finalPieceDamage, life: 30, hitEnemies:[enemy.id], weaponId: 'shrapnel'
                         });
                     }
                 } 
             });
             player.weaponCooldowns.shrapnel = stats.cooldown * player.fireRateBonus;
        }

        function fireDrone(level) {
            const stats = [
                // shotDamage, explosionDamage, cooldown, life, shotCooldown, range, explosionRadius
                { shotDamage: 8, explosionDamage: 40, cooldown: 500, life: 300, shotCooldown: 60, range: 400, explosionRadius: 60 },
                { shotDamage: 10, explosionDamage: 50, cooldown: 480, life: 350, shotCooldown: 55, range: 425, explosionRadius: 65 },
                { shotDamage: 12, explosionDamage: 60, cooldown: 460, life: 400, shotCooldown: 50, range: 450, explosionRadius: 70 },
                { shotDamage: 14, explosionDamage: 75, cooldown: 440, life: 450, shotCooldown: 45, range: 475, explosionRadius: 75 },
                { shotDamage: 16, explosionDamage: 90, cooldown: 420, life: 500, shotCooldown: 40, range: 500, explosionRadius: 80 },
                { shotDamage: 18, explosionDamage: 110, cooldown: 400, life: 550, shotCooldown: 38, range: 525, explosionRadius: 85 },
                { shotDamage: 20, explosionDamage: 130, cooldown: 380, life: 600, shotCooldown: 36, range: 550, explosionRadius: 90 },
                { shotDamage: 22, explosionDamage: 150, cooldown: 360, life: 650, shotCooldown: 34, range: 575, explosionRadius: 100 },
                { shotDamage: 25, explosionDamage: 175, cooldown: 340, life: 700, shotCooldown: 32, range: 600, explosionRadius: 110 },
                { shotDamage: 30, explosionDamage: 200, cooldown: 300, life: 800, shotCooldown: 30, range: 625, explosionRadius: 120 },
            ][level - 1];
            
            const droneCounts = [1, 2, 2, 3, 3, 4, 4, 5, 5, 5];
            const droneCount = droneCounts[level - 1];

            for(let i=0; i < droneCount; i++) {
                specialProjectiles.push({
                    type: 'drone', x: player.x, y: player.y, radius: 12, life: stats.life,
                    orbitAngle: Math.random() * Math.PI * 2, orbitDistance: 80 + (i * 20), // Yörünge mesafesini kademele
                    shotTimer: i * 10, // İlk atışlarını kademele
                    weaponId: 'drone',
                    
                    // İstatistikleri mermiye aktar
                    shotDamage: stats.shotDamage,
                    shotCooldown: stats.shotCooldown,
                    range: stats.range,
                    explosionDamage: stats.explosionDamage * player.damageBonusMultiplier, // Bonusu oluşturulurken uygula
                    explosionRadius: stats.explosionRadius,

                    update: function() {
                        this.life--;

                        // --- Yörünge Mantığı ---
                        this.orbitAngle += 0.02;
                        const targetX = player.x + Math.cos(this.orbitAngle) * this.orbitDistance;
                        const targetY = player.y + Math.sin(this.orbitAngle) * this.orbitDistance;
                        // Yörünge konumuna doğru yumuşak hareket
                        this.x += (targetX - this.x) * 0.1;
                        this.y += (targetY - this.y) * 0.1;

                        // --- Ateş Etme Mantığı ---
                        this.shotTimer--;
                        if (this.shotTimer <= 0) {
                            let closestEnemy = null; let minDistance = Infinity;
                            enemies.forEach(enemy => {
                                const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                                if (dist < minDistance && dist <= this.range) { minDistance = dist; closestEnemy = enemy; }
                            });
                            if (closestEnemy) {
                                const angle = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x);
                                const finalDamage = this.shotDamage * player.damageBonusMultiplier;
                                bullets.push({ x: this.x, y: this.y, angle: angle + Math.PI/2, speed: 10, radius: 4, color: '#00ffff', owner: 'player', damage: finalDamage, hitEnemies: [], weaponId: this.weaponId });
                                this.shotTimer = this.shotCooldown * player.fireRateBonus;
                            }
                        }

                        // --- Çarpışma Patlaması Mantığı ---
                        for (const enemy of enemies) {
                            const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                            if (dist < this.radius + enemy.width / 2) {
                                // Patla!
                                this.life = 0; // Silinmek üzere işaretle
                                createExplosion(this.x, this.y, '#00ffff');
                                triggerScreenShake(4, 8);

                                enemies.forEach(e => {
                                    if (Math.hypot(this.x - e.x, this.y - e.y) < this.explosionRadius) {
                                        e.health -= this.explosionDamage;
                                        e.isHit = true; e.hitTimer = 5;
                                        if (weaponDamageStats.hasOwnProperty(this.weaponId)) {
                                            weaponDamageStats[this.weaponId] += this.explosionDamage;
                                        }
                                        floatingTexts.push({ x: e.x, y: e.y, text: `${Math.floor(this.explosionDamage)}`, color: '#00ffff', life: 1, vy: 1, size: 22 });
                                    }
                                });
                                return; // Bu dron yok edildiği için güncellemeyi durdur
                            }
                        }
                    }
                });
            }
            player.weaponCooldowns.drone = stats.cooldown * player.fireRateBonus;
        }

        function fireBarrage(level) {
            const stats = [
                { damage: 8, cooldown: 80, count: 3, spread: 0.3 },
                { damage: 9, cooldown: 75, count: 4, spread: 0.3 },
                { damage: 10, cooldown: 70, count: 4, spread: 0.4 },
                { damage: 11, cooldown: 65, count: 5, spread: 0.4 },
                { damage: 12, cooldown: 60, count: 5, spread: 0.5 },
                { damage: 13, cooldown: 55, count: 6, spread: 0.5 },
                { damage: 14, cooldown: 50, count: 6, spread: 0.6 },
                { damage: 15, cooldown: 45, count: 7, spread: 0.6 },
                { damage: 16, cooldown: 40, count: 7, spread: 0.7 },
                { damage: 18, cooldown: 35, count: 8, spread: 0.7 },
            ][level - 1];
            
            const closestEnemy = findClosestEnemy(450);
            if (!closestEnemy) return;

            let fireAngle;
            if (player.type === 'helicopter') {
                fireAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x) + Math.PI / 2;
            } else {
                fireAngle = player.turretAngle;
            }

            const shootX = player.x + Math.sin(player.turretAngle) * 30;
            const shootY = player.y - Math.cos(player.turretAngle) * 30;
            muzzleFlashes.push({ x: shootX, y: shootY, angle: player.turretAngle, life: 0.2 });
            const finalDamage = stats.damage * player.damageBonusMultiplier;
            for (let i = 0; i < stats.count; i++) {
                setTimeout(() => {
                    if(isGameOver || gamePaused) return;
                    const angle = fireAngle + (Math.random() - 0.5) * stats.spread;
                    bullets.push({ x: shootX, y: shootY, angle, speed: 6, radius: 4, color: '#cccccc', owner: 'player', damage: finalDamage, hitEnemies: [], weaponId: 'barrage' });
                }, i * 50); // Staggered fire
            }
            player.weaponCooldowns.barrage = stats.cooldown * player.fireRateBonus;
        }

        function fireFlameTrail(level) {
            if (!player.isMoving) return;
            const stats = [
                { damage: 0.2, cooldown: 20, duration: 120, radius: 15 },
                { damage: 0.2, cooldown: 18, duration: 140, radius: 16 },
                { damage: 0.3, cooldown: 16, duration: 160, radius: 17 },
                { damage: 0.3, cooldown: 14, duration: 180, radius: 18 },
                { damage: 0.4, cooldown: 12, duration: 200, radius: 20 },
                { damage: 0.4, cooldown: 11, duration: 220, radius: 21 },
                { damage: 0.5, cooldown: 10, duration: 240, radius: 22 },
                { damage: 0.5, cooldown: 9, duration: 260, radius: 23 },
                 { damage: 0.6, cooldown: 8, duration: 280, radius: 24 },
                 { damage: 0.7, cooldown: 7, duration: 300, radius: 25 },
            ][level - 1];
            
            const finalDamagePerFrame = stats.damage * player.damageBonusMultiplier;

            const angle = player.angle - Math.PI;
            const spawnX = player.x + Math.sin(angle) * (player.height/2);
            const spawnY = player.y - Math.cos(angle) * (player.height/2);
            
            specialProjectiles.push({
                type: 'firePatch',
                x: spawnX, y: spawnY,
                radius: stats.radius,
                life: stats.duration, maxLife: stats.duration,
                damagePerFrame: finalDamagePerFrame,
                weaponId: 'flameTrail',
                update: function() {
                    this.life--;
                    enemies.forEach(e => {
                        if (Math.hypot(this.x - e.x, this.y - e.y) < this.radius + e.width/2) {
                            e.health -= this.damagePerFrame;
                            if (weaponDamageStats.hasOwnProperty(this.weaponId)) {
                                weaponDamageStats[this.weaponId] += this.damagePerFrame;
                            }
                            if(ACHIEVEMENT_SETS.kundakci.isApplied) {
                                e.isBurning = true;
                                e.burnDamage = this.damagePerFrame * 60 * 0.5;
                            }
                        }
                    });
                }
            });
            player.weaponCooldowns.flameTrail = stats.cooldown * player.fireRateBonus;
        }

        function fireFlameDance(level) {
            const stats = [
                { damagePerSecond: 15, cooldown: 1, radius: 70 },
                { damagePerSecond: 20, cooldown: 1, radius: 80 },
                { damagePerSecond: 25, cooldown: 1, radius: 90 },
                { damagePerSecond: 30, cooldown: 1, radius: 100 },
                { damagePerSecond: 40, cooldown: 1, radius: 110 },
                { damagePerSecond: 50, cooldown: 1, radius: 120 },
                { damagePerSecond: 60, cooldown: 1, radius: 130 },
                { damagePerSecond: 75, cooldown: 1, radius: 140 },
                 { damagePerSecond: 90, cooldown: 1, radius: 150 },
                 { damagePerSecond: 110, cooldown: 1, radius: 160 },
            ][level - 1];
            
            const finalDamagePerFrame = (stats.damagePerSecond / 60) * player.damageBonusMultiplier;

            // Damage aura logic
            enemies.forEach(e => {
                if (Math.hypot(player.x - e.x, player.y - e.y) < stats.radius + e.width / 2) {
                    e.health -= finalDamagePerFrame;
                    if (weaponDamageStats.hasOwnProperty('flameDance')) {
                        weaponDamageStats['flameDance'] += finalDamagePerFrame;
                    }
                    if(ACHIEVEMENT_SETS.kundakci.isApplied) {
                        e.isBurning = true;
                        e.burnDamage = finalDamagePerFrame * 60 * 0.5; // Burn for 50% of the dps
                    }
                    if (Math.random() < 0.1) { // Show damage numbers occasionally to avoid clutter
                         floatingTexts.push({ x: e.x + (Math.random()-0.5)*20, y: e.y + (Math.random()-0.5)*20, text: `${(finalDamagePerFrame * 10).toFixed(1)}`, color: '#ff6600', life: 0.5, vy: 1, size: 18 });
                    }
                }
            });

            // Visual effect logic: spawn flame particles in a circle
            if(Math.random() < 0.6) { // Spawn visuals often
                const angle = Math.random() * Math.PI * 2;
                const distance = stats.radius * (0.5 + Math.random() * 0.5); // spawn within the radius
                const particleX = player.x + Math.cos(angle) * distance;
                const particleY = player.y + Math.sin(angle) * distance;
                
                specialProjectiles.push({ 
                    type: 'flame', 
                    x: particleX, 
                    y: particleY, 
                    radius: Math.random() * 8 + 4, 
                    life: 0.4, // short life for particles
                    color: `rgba(255, ${Math.floor(Math.random() * 100 + 100)}, 0, 0.7)`, 
                    update: function() { this.life -= 0.02; } // just fade out, no damage logic here
                });
            }

            player.weaponCooldowns.flameDance = stats.cooldown * player.fireRateBonus;
        }

        function firePulseCannon(level) {
            const stats = [
                { damage: 15, cooldown: 50, knockback: 15, range: 500 },
                { damage: 18, cooldown: 48, knockback: 18, range: 510 },
                { damage: 21, cooldown: 46, knockback: 21, range: 520 },
                { damage: 24, cooldown: 44, knockback: 24, range: 530 },
                { damage: 27, cooldown: 42, knockback: 27, range: 540 },
                { damage: 30, cooldown: 40, knockback: 30, range: 550 },
                { damage: 33, cooldown: 38, knockback: 33, range: 560 },
                { damage: 36, cooldown: 36, knockback: 36, range: 570 },
                { damage: 40, cooldown: 34, knockback: 40, range: 580 },
                 { damage: 45, cooldown: 30, knockback: 45, range: 600 },
            ][level - 1];

            const closestEnemy = findClosestEnemy(stats.range);
            if (!closestEnemy) return;

            let fireAngle;
            if (player.type === 'helicopter') {
                fireAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x) + Math.PI / 2;
            } else {
                fireAngle = player.turretAngle;
            }
            
            const shootX = player.x + Math.sin(player.turretAngle) * 30;
            const shootY = player.y - Math.cos(player.turretAngle) * 30;
            const finalDamage = stats.damage * player.damageBonusMultiplier;
            bullets.push({
                x: shootX, y: shootY, angle: fireAngle, speed: 10, radius: 8, color: '#add8e6', owner: 'player', 
                damage: finalDamage, weaponId: 'pulseCannon', hitEnemies:[],
                onHit: (enemy, dmg) => {
                    if (enemy.type !== 'boss') {
                        const angle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                        enemy.x += Math.cos(angle) * stats.knockback;
                        enemy.y += Math.sin(angle) * stats.knockback;
                    }
                }
            });
            player.weaponCooldowns.pulseCannon = stats.cooldown * player.fireRateBonus;
        }

        function fireRoboSpider(level) {
            const stats = [
                { cooldown: 250, life: 400, speed: 2.5 }, // ~6.7s
                { cooldown: 240, life: 450, speed: 2.7 },
                { cooldown: 230, life: 500, speed: 2.9 }, // ~8.3s
                { cooldown: 220, life: 550, speed: 3.1 },
                { cooldown: 210, life: 600, speed: 3.3 }, // 10s
                { cooldown: 200, life: 650, speed: 3.5 },
                { cooldown: 190, life: 700, speed: 3.7 }, // ~11.7s
                { cooldown: 180, life: 750, speed: 3.9 },
                { cooldown: 170, life: 800, speed: 4.1 },
                { cooldown: 150, life: 900, speed: 4.5 }, // 15s
            ][level - 1];

            const offsetAngle = Math.random() * Math.PI * 2;
            const offsetDist = Math.random() * 40 + 20;
            const spawnX = player.x + Math.cos(offsetAngle) * offsetDist;
            const spawnY = player.y + Math.sin(offsetAngle) * offsetDist;

            specialProjectiles.push({
                type: 'roboSpider', x: spawnX, y: spawnY, radius: 10, life: stats.life, angle: Math.random() * Math.PI * 2,
                weaponId: 'roboSpider',
                update: function() {
                    this.life--;
                    
                    // Find the closest non-attracted XP orb
                    let closestOrb = null;
                    let minDistance = Infinity;
                    xpOrbs.forEach(orb => {
                        if (!orb.isAttracted) {
                            const dist = Math.hypot(this.x - orb.x, this.y - orb.y);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestOrb = orb;
                            }
                        }
                    });

                    if (closestOrb) {
                        // Move towards the orb
                        const targetAngle = Math.atan2(closestOrb.y - this.y, closestOrb.x - this.x);
                        this.angle = targetAngle;
                        this.x += Math.cos(targetAngle) * stats.speed;
                        this.y += Math.sin(targetAngle) * stats.speed;

                        // Check for collection
                        if (minDistance < this.radius + closestOrb.radius) {
                           closestOrb.isAttracted = true;
                           weaponDamageStats['roboSpider'] = (weaponDamageStats['roboSpider'] || 0) + closestOrb.value;
                        }
                    } else {
                        // Wander if no orbs are available
                        this.x += Math.cos(this.angle) * stats.speed * 0.5;
                        this.y += Math.sin(this.angle) * stats.speed * 0.5;
                        if (Math.random() < 0.05) { // Change direction occasionally
                            this.angle += (Math.random() - 0.5) * 2;
                        }
                        // Bounce off walls
                        if (this.x < 0 || this.x > world.width) this.angle = Math.PI - this.angle;
                        if (this.y < 0 || this.y > world.height) this.angle = -this.angle;
                    }
                }
            });
            player.weaponCooldowns.roboSpider = stats.cooldown * player.fireRateBonus;
        }

        Object.assign(WEAPONS, {
            'defaultGun': {
                name: 'Ana Silah',
                icon: '🔫',
                get description() { // Use a getter to make it dynamic
                    const vehicleType = VEHICLES[selectedVehicle]?.type;
                    switch (vehicleType) {
                        case 'tank':
                            return 'Güçlü ana top. Hareketsizken hasarı ikiye katlanır. Sonsuz seviye atlayabilir.';
                        case 'armored':
                            return 'Hızlı ateş eden makineli tüfek. Şarjörle çalışır ve seviye atladıkça hasarı artar.';
                        case 'helicopter':
                            return 'Beşli seri atış yapan otomatik top. Seviye atladıkça atış başına hasarı artar.';
                        default:
                            return 'Güvenilir standart silah. Sonsuza kadar seviye atlayabilir.';
                    }
                },
                fire: fireDefaultGun,
                getUpgradeText: (level) => {
                    const vehicleData = VEHICLES[selectedVehicle];
                    if (!vehicleData) return 'Hasar: Bilinmiyor'; // Fallback
                    
                    const vehicleType = vehicleData.type;
                    const vehicleDamage = VEHICLE_BASE_DAMAGE[selectedVehicle] || 0;

                    switch (vehicleType) {
                        case 'tank': {
                            const damageLevels = [15, 24, 34, 43, 53, 62, 72, 81, 91, 100];
                            // Araç temel hasarını seviye hasarına ekle
                            const originalBaseDamage = 15;
                            const vehicleModifier = vehicleDamage - originalBaseDamage;
                            let baseDamage;
                            if (level <= 10) {
                                baseDamage = damageLevels[level-1] + vehicleModifier;
                            } else {
                                baseDamage = (100 + (level - 10) * 5) + vehicleModifier;
                            }
                            return `Hasar: ${baseDamage.toFixed(0)} (Sabitken: ${(baseDamage * 2).toFixed(0)})`;
                        }
                        case 'armored': {
                            const damage = (vehicleDamage || 1) + (level - 1) * 0.5;
                            return `Hasar: ${damage.toFixed(1)}/mermi, Şarjör: 30`;
                        }
                        case 'helicopter': {
                            const damage = (vehicleDamage || 3) + (level - 1) * 1;
                            return `Hasar: ${damage.toFixed(0)}x5, Seri Atış`;
                        }
                        default: { // Fallback for safety
                            const damageLevels = [15, 24, 34, 43, 53, 62, 72, 81, 91, 100];
                            let baseDamage;
                             if (level <= 10) {
                                baseDamage = damageLevels[level-1];
                            } else {
                                baseDamage = 100 + (level - 10) * 5;
                            }
                            return `Hasar: ${baseDamage}`;
                        }
                    }
                }
            },
            'mortar':       { name: 'Bomba Atar',       icon: '💣', maxLevel: 10, description: 'Alan etkili patlayıcı mermiler fırlatır.', fire: fireMortar, getUpgradeText: (level) => `Hasar: ${[20,25,30,35,40,45,50,55,60,70][level-1]}, Alan: ${[40,45,50,55,60,65,70,75,80,90][level-1]}` },
            'laser':        { name: 'Lazer Işını',      icon: '〰', maxLevel: 10, description: 'Aynı hedefe odaklandıkça hasarı artan bir ışın ateşler.', fire: fireLaser, getUpgradeText: (level) => `Saniye Başına Hasar: ${(1000/1 * [0.5,0.7,0.9,1.1,1.4,1.7,2.0,2.4,2.8,3.5][level-1]).toFixed(0)}` },
            'mines':        { name: 'Mayın Döşeyici',   icon: '💥', maxLevel: 10, description: 'Arkanıza patlayıcı mayınlar bırakır.', fire: fireMines, getUpgradeText: (level) => `Hasar: ${[40,50,60,70,80,90,100,110,120,150][level-1]}, Alan: ${[60,70,80,90,100,110,120,130,140,150][level-1]}` },
            'turret':       { name: 'Taret',            icon: '🗼', maxLevel: 10, description: 'Sabit, otomatik bir taret yerleştirir.', fire: fireTurret, getUpgradeText: (level) => `Hasar: ${[10,12,15,18,22,25,28,32,36,40][level-1]}, Süre: ${[300,350,400,450,500,550,600,650,700,800][level-1]/60}s` },
            'chain':        { name: 'Zincir Şimşek',    icon: '⚡', maxLevel: 10, description: 'Düşmanlar arasında seken bir şimşek.', fire: fireChain, getUpgradeText: (level) => `Sekme: ${[2,2,3,3,4,4,5,5,6,7][level-1]}, Hasar: ${[10,12,14,16,18,20,22,25,28,32][level-1]}, Sekme Menzili: ${[250,275,300,325,350,375,400,425,450,500][level-1]}` },
            'railgun':      { name: 'Zırh Delici',      icon: '➡️', maxLevel: 10, description: 'Düşmanları delip geçen güçlü bir atış yapar.', fire: fireRailgun, getUpgradeText: (level) => `Hasar: ${[40,50,60,70,80,90,100,115,130,150][level-1]}, Delme: ${level + 1}, Menzil: ${[700,750,800,850,900,950,1000,1050,1100,1200][level-1]}` },
            'missile':      { name: 'Güdümlü Füze',     icon: '🚀', maxLevel: 10, description: 'En yakın düşmanı arayan füzeler fırlatır.', fire: fireMissile, getUpgradeText: (level) => `Sayı: ${[1,2,2,3,3,4,4,5,5,6][level-1]}, Hasar: ${[25,25,30,30,35,35,40,40,45,50][level-1]}` },
            'shotgun':      { name: 'Saçmalı Tüfek',    icon: '🔥', maxLevel: 10, description: 'Yakın mesafede geniş bir saçma yayılımı ateşler.', fire: fireShotgun, getUpgradeText: (level) => `Saçma: ${[3,4,4,5,6,6,7,7,8,9][level-1]}, Hasar: ${[5,6,7,8,9,10,11,12,13,15][level-1]}/saçma` },
            'flamethrower': { name: 'Alev Püskürtücü',  icon: '♨️', maxLevel: 10, description: 'Sürekli alev püskürterek yanma hasarı verir.', fire: fireFlamethrower, getUpgradeText: (level) => `Saniye Başına Hasar: ${(1000/3 * [0.2,0.3,0.4,0.5,0.6,0.7,0.8,1.0,1.2,1.5][level-1]).toFixed(0)}` },
            'shrapnel':     { name: 'Şarapnel Topu',    icon: '☄️', maxLevel: 10, description: 'Vurduğunda parçalara ayrılan bir mermi atar.', fire: fireShrapnel, getUpgradeText: (level) => `Parça: ${[4,5,5,6,6,7,7,8,8,10][level-1]}, Parça Hasarı: ${[10,12,14,16,18,20,22,24,26,30][level-1]}` },
            'drone':        { name: 'Savaş Dronu',      icon: '🤖', maxLevel: 10, description: 'Sizin etrafınızda dönüp ateş eder. Düşmanla temas ederse patlar.', fire: fireDrone, getUpgradeText: (level) => { const droneCounts = [1, 2, 2, 3, 3, 4, 4, 5, 5, 5]; const shotDamageLevels = [8, 10, 12, 14, 16, 18, 20, 22, 25, 30]; const explosionDamageLevels = [40, 50, 60, 75, 90, 110, 130, 150, 175, 200]; return `Sayı: ${droneCounts[level - 1]}, Atış Hasarı: ${shotDamageLevels[level - 1]}, Patlama Hasarı: ${explosionDamageLevels[level - 1]}`; } },
            'barrage':      { name: 'Yaylım Ateşi',      icon: '▓', maxLevel: 10, description: 'Kısa aralıklarla bir roket salvosu ateşler.', fire: fireBarrage, getUpgradeText: (level) => `Roket: ${[3,4,4,5,5,6,6,7,7,8][level-1]}, Hasar: ${[8,9,10,11,12,13,14,15,16,18][level-1]}` },
            'flameTrail':   { name: 'Alev İzi',         icon: '👣', maxLevel: 10, description: 'Hareket ederken arkanızda yanan bir iz bırakır.', fire: fireFlameTrail, getUpgradeText: (level) => `Süre: ${(120 + (level-1)*20)/60}s, Hasar: ${(0.2 + (level-1)*0.05).toFixed(1)}/kare` },
            'flameDance':   { name: 'Alev Dansı',       icon: '✨', maxLevel: 10, description: 'Tankın etrafında sürekli hasar veren bir alev alanı oluşturur.', fire: fireFlameDance, getUpgradeText: (level) => `Saniye Başına Hasar: ${[15,20,25,30,40,50,60,75,90,110][level-1]}, Alan: ${[70,80,90,100,110,120,130,140,150,160][level-1]}` },
            'pulseCannon':  { name: 'İtici Top',       icon: '💨', maxLevel: 10, description: 'Düşmanları geri iten bir enerji dalgası ateşler.', fire: firePulseCannon, getUpgradeText: (level) => `İtme: ${[15,18,21,24,27,30,33,36,40,45][level-1]}, Hasar: ${[15,18,21,24,27,30,33,36,40,45][level-1]}` },
            'roboSpider':   { name: 'Robo-Örümcek',     icon: '🕷️', maxLevel: 10, description: 'Yakındaki tecrübe puanlarını toplayan bir örümcek bırakır.', fire: fireRoboSpider, getUpgradeText: (level) => `Süre: ${([400,450,500,550,600,650,700,750,800,900][level-1]/60).toFixed(1)}s, Hız: ${[2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.5][level-1]}` },
            'vampire':      { name: 'Tamirci',          icon: '🔧', maxLevel: 10, description: 'Sürekli olarak zırhı yeniler. Ateş etmez.', fire: fireVampire, getUpgradeText: (level) => `Saniyede Yenileme: ${[0.5, 0.7, 0.9, 1.1, 1.4, 1.7, 2.0, 2.4, 2.8, 3.5][level-1].toFixed(1)}` },
        });

        function updateWeapons() {
            for (const id in player.weapons) {
                if (player.weaponCooldowns[id] > 0) {
                    player.weaponCooldowns[id]--;
                } else {
                    WEAPONS[id].fire(player.weapons[id]);
                }
            }
        }
        

        // --- Level System ---
        function addXP(amount) {
            if (isGameOver) return;
            player.xp += amount * player.xpGainMultiplier;
            // Seviye atlamayı kontrol et. while döngüsü aynı anda birden fazla seviye atlamayı yönetir.
            while (player.xp >= player.xpToNextLevel) {
                // ÖNEMLİ: Animasyonlu modalı çağırmadan önce oyuncu istatistiklerini güncelle.
                // Bu, animasyon bitmeden ve XP düşülmeden önce addXP'nin tekrar tekrar
                // çağrıldığı bir sonsuz döngüyü önler.
                player.xp -= player.xpToNextLevel;
                player.level++;

                if (player.level % 5 === 0) {
                    spawnRandomPermanentUpgrade();
                }

                player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
                
                // Seviye atlama olayının kendisi için görsel/sesli geri bildirim
                specialProjectiles.push({
                    type: 'forceRing', x: player.x, y: player.y, radius: 0, life: 0.5,
                    update: function() {
                        this.radius += 20;
                        this.life -= 0.02;
                        enemies.forEach(e => {
                            if (e.type !== 'boss') {
                                const dist = Math.hypot(this.x - e.x, this.y - e.y);
                                if (dist < this.radius) {
                                    const angle = Math.atan2(e.y - this.y, e.x - this.x);
                                    e.x += Math.cos(angle) * 15;
                                    e.y += Math.sin(angle) * 15;
                                }
                            }
                        });
                    }
                });
                
                // Şimdi, seviye atlama modalını göstermek için fonksiyonu çağır.
                handleLevelUp(false);
            }
        }
        
        function handleLevelUp(isFromLootBox = false, isReroll = false) {
            if (isModalActive && !isReroll) {
                modalQueue.push(() => handleLevelUp(isFromLootBox, false));
                return;
            }

            // Rerolls should skip the animation and just refresh the options.
            if (isReroll) {
                showLevelUpOptions(isFromLootBox, true);
                return;
            }
            
            // --- Start unified animation sequence for both Level Up and Loot Box ---
            gamePaused = true;
            isModalActive = true;
            
            // Use the loot box icon for both, but different colors for effects
            const explosionColor = isFromLootBox ? '#ffd700' : '#00ff88';
            const confettiColorStart = isFromLootBox ? 20 : 100; // Gold vs Green/Blue
            const confettiColorRange = isFromLootBox ? 60 : 120;
            
            lootBoxAnimationContainer.style.display = 'block';
            
            // Clear old classes and start the new animation sequence
            lootBoxChest.classList.remove('shake', 'grow');
            lootBoxChest.classList.add('grow');

            // After the 0.5s grow animation, start shaking for the remaining 1.5 seconds
            setTimeout(() => {
                lootBoxChest.classList.add('shake');
            }, 500);
            
            // Total animation duration is 2 seconds
            setTimeout(() => {
                lootBoxChest.classList.remove('shake', 'grow');
                
                const worldX = camera.x + canvas.width / 2;
                const worldY = camera.y + canvas.height / 2;
                
                createExplosion(worldX, worldY, explosionColor);
                for(let i=0; i<50; i++) {
                     particles.push({
                         type: 'confetti',
                         x: worldX, y: worldY,
                         vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15,
                         radius: Math.random() * 5 + 3, life: 1.5,
                         color: `hsl(${Math.random() * confettiColorRange + confettiColorStart}, 100%, 70%)`
                     });
                 }
                triggerScreenShake(8, 15);
                
                lootBoxAnimationContainer.style.display = 'none';

                // Proceed to show the level up options screen
                showLevelUpOptions(isFromLootBox, false); // isReroll is always false here
            }, 2000); // Total duration 2 seconds
        }

        function showLevelUpOptions(isFromLootBox = false, isReroll = false) {
            if (isModalActive && !isReroll) {
                modalQueue.push(() => handleLevelUp(isFromLootBox, false));
                return;
            }

            // Rerolls should skip the animation and just refresh the options.
            if (isReroll) {
                showLevelUpOptions(isFromLootBox, true);
                return;
            }
            
            // --- Start unified animation sequence for both Level Up and Loot Box ---
            gamePaused = true;
            isModalActive = true;
            
            // Use the loot box icon for both, but different colors for effects
            const explosionColor = isFromLootBox ? '#ffd700' : '#00ff88';
            const confettiColorStart = isFromLootBox ? 20 : 100; // Gold vs Green/Blue
            const confettiColorRange = isFromLootBox ? 60 : 120;
            
            lootBoxAnimationContainer.style.display = 'block';
            
            // Clear old classes and start the new animation sequence
            lootBoxChest.classList.remove('shake', 'grow');
            lootBoxChest.classList.add('grow');

            // After the 0.5s grow animation, start shaking for the remaining 1.5 seconds
            setTimeout(() => {
                lootBoxChest.classList.add('shake');
            }, 500);
            
            // Total animation duration is 2 seconds
            setTimeout(() => {
                lootBoxChest.classList.remove('shake', 'grow');
                
                const worldX = camera.x + canvas.width / 2;
                const worldY = camera.y + canvas.height / 2;
                
                createExplosion(worldX, worldY, explosionColor);
                for(let i=0; i<50; i++) {
                     particles.push({
                         type: 'confetti',
                         x: worldX, y: worldY,
                         vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15,
                         radius: Math.random() * 5 + 3, life: 1.5,
                         color: `hsl(${Math.random() * confettiColorRange + confettiColorStart}, 100%, 70%)`
                     });
                 }
                triggerScreenShake(8, 15);
                
                lootBoxAnimationContainer.style.display = 'none';

                // Proceed to show the level up options screen
                showLevelUpOptions(isFromLootBox, false); // isReroll is always false here
            }, 2000); // Total duration 2 seconds
        }

        function showLevelUpOptions(isFromLootBox = false, isReroll = false) {
            isModalActive = true;
            gamePaused = true;
            upgradeOptionsContainer.innerHTML = '';
            rerollButton.onclick = null; // Clear previous listener

            // --- GLOW LOGIC START ---
            const glowingWeapons = new Set();
            const finalChoiceWeapons = new Set();
            const ownedWeaponsSet = new Set(Object.keys(player.weapons));

            for (const key in ACHIEVEMENT_SETS) {
                const achievement = ACHIEVEMENT_SETS[key];
                const missingWeapons = achievement.weapons.filter(w => !ownedWeaponsSet.has(w));
                
                if (missingWeapons.length === 2) { 
                    missingWeapons.forEach(w => glowingWeapons.add(w));
                } else if (missingWeapons.length === 1) {
                    finalChoiceWeapons.add(missingWeapons[0]);
                }
            }
            // --- GLOW LOGIC END ---

            // Skip button setup
            skipButton.disabled = false;
            skipButton.style.opacity = '1';
            skipButton.onclick = () => {
                selectUpgrade(null, true);
            };

            // Reroll button logic
            if (rerollCharges > 0) {
                rerollButton.style.display = 'block';
                rerollButton.textContent = `Yenile (${rerollCharges})`;
                rerollButton.disabled = false;
                rerollButton.style.opacity = '1';
                rerollButton.onclick = () => {
                    if (rerollCharges > 0) {
                        rerollCharges--;
                        // Call again, marking it as a reroll and preserving the lootbox status
                        handleLevelUp(isFromLootBox, true);
                    }
                };
            } else {
                rerollButton.style.display = 'none';
            }

            /*
            // Bu mantık, bir sonsuz döngüyü önlemek için addXP fonksiyonuna taşındı.
            if (!isReroll) {
                if (!isFromLootBox) {
                    player.xp -= player.xpToNextLevel;
                    player.level++;

                    if (player.level % 5 === 0) {
                        spawnRandomPermanentUpgrade();
                    }

                    player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
                     specialProjectiles.push({
                        type: 'forceRing', x: player.x, y: player.y, radius: 0, life: 0.5,
                        update: function() {
                            this.radius += 20;
                            this.life -= 0.02;
                            enemies.forEach(e => {
                                if (e.type !== 'boss') {
                                    const dist = Math.hypot(this.x - e.x, this.y - e.y);
                                    if (dist < this.radius) {
                                        const angle = Math.atan2(e.y - this.y, e.x - this.x);
                                        e.x += Math.cos(angle) * 15;
                                        e.y += Math.sin(angle) * 15;
                                    }
                                }
                            });
                        }
                    });
                }
            }
            */
            
            let isBonus = false;
            if (player.level === 6) {
                isBonus = true;
            } else if (player.level >= 7) {
                isBonus = Math.random() < 0.25;
            }
            // For levels 2-5, isBonus remains false, resulting in a standard reward.
            const choiceCount = isBonus ? 5 : 3;
            const selectionsAllowed = isBonus ? 3 : 1;
            
            levelUpInfoEl.textContent = isFromLootBox 
                ? `GANİMET KUTUSU! ${choiceCount} seçenekten ${selectionsAllowed} tane seç:`
                : (isBonus ? `Bonus! ${choiceCount} seçenekten ${selectionsAllowed} tane seç:` : `Bir silah seç veya yükselt:`);

            const ownedWeaponCount = Object.keys(player.weapons).length;
            // Offer all possible upgrades. The UI will disable selecting new weapons if the player has 5.
            const availableWeaponUpgrades = Object.keys(WEAPONS).filter(id => {
                const weapon = WEAPONS[id];
                const currentLevel = player.weapons[id] || 0;
                
                // If player has 5 or more weapons, prevent offering a NEW weapon
                if (ownedWeaponCount >= 5 && !player.weapons[id]) {
                    return false;
                }

                return !weapon.maxLevel || currentLevel < weapon.maxLevel;
            });
            
            const finalChoices = [];
            while(finalChoices.length < choiceCount && availableWeaponUpgrades.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableWeaponUpgrades.length);
                finalChoices.push(availableWeaponUpgrades.splice(randomIndex, 1)[0]);
            }

            // Fill missing options with stat upgrades
            if (finalChoices.length < choiceCount) {
                let availableStatUpgrades = Object.keys(STAT_UPGRADES);
                
                if (player.speed >= 6) availableStatUpgrades = availableStatUpgrades.filter(id => id !== 'moveSpeed');
                if (player.maxHealth >= 500) availableStatUpgrades = availableStatUpgrades.filter(id => id !== 'maxHealth');

                while(finalChoices.length < choiceCount && availableStatUpgrades.length > 0) {
                    const randomIndex = Math.floor(Math.random() * availableStatUpgrades.length);
                    finalChoices.push(availableStatUpgrades.splice(randomIndex, 1)[0]);
                }
            }
            
            // If no options (very rare), give health and close
            if (finalChoices.length === 0) {
                player.health = Math.min(player.maxHealth, player.health + 10);
                floatingTexts.push({ x: player.x, y: player.y, text: `+10 ZIRH`, color: '#00ff00', life: 1, vy: 1, size: 20 });
                selectUpgrade(null, true);
                return;
            }

            levelUpScreen.style.zIndex = modalBaseZIndex++;
            levelUpScreen.style.display = 'block';
            if (!isReroll) {
                createConfetti(150);
                for(let i=0; i<5; i++){
                    createFirework(Math.random() * canvas.width, canvas.height);
                }
            }
            animateSlotMachine(finalChoices, selectionsAllowed, glowingWeapons, finalChoiceWeapons);
        }

        function animateSlotMachine(finalChoices, selectionsAllowed, glowingWeapons, finalChoiceWeapons) {
            let selectionsMade = 0;
            const allUpgradeKeys = [...Object.keys(WEAPONS), ...Object.keys(STAT_UPGRADES)];
            
            // Create placeholder buttons
            for (let i = 0; i < finalChoices.length; i++) {
                const button = document.createElement('button');
                button.className = 'upgrade-button';
                button.style.animationDelay = `${i * 100}ms`;
                button.innerHTML = `<span class="upgrade-icon">❓</span><div class="upgrade-text"><strong>...</strong><span>...</span></div>`;
                upgradeOptionsContainer.appendChild(button);
            }

            const buttons = Array.from(upgradeOptionsContainer.children);
            let spinning = buttons.map(() => true);
            
            const spinInterval = setInterval(() => {
                buttons.forEach((button, i) => {
                    if (spinning[i]) {
                        const randomKey = allUpgradeKeys[Math.floor(Math.random() * allUpgradeKeys.length)];
                        const randomUpgrade = WEAPONS[randomKey] || STAT_UPGRADES[randomKey];
                        button.querySelector('.upgrade-icon').textContent = randomUpgrade.icon;
                        button.querySelector('strong').textContent = randomUpgrade.name;
                    }
                });
            }, 50);

            let stopIndex = 0;
            const stopSpinning = () => {
                if (stopIndex < finalChoices.length) {
                    const key = finalChoices[stopIndex];
                    const weapon = WEAPONS[key];
                    const stat = STAT_UPGRADES[key];
                    const button = buttons[stopIndex];

                    spinning[stopIndex] = false;

                    if (weapon) {
                        const currentLevel = player.weapons[key] || 0;
                        const isNew = currentLevel === 0;
                        const isNewDiscovery = !discoveredWeapons.includes(key);
                        const newTagHTML = isNewDiscovery ? '<div class="new-tag">YENİ</div>' : '';

                        button.innerHTML = `
                        ${newTagHTML}
                        <span class="upgrade-icon">${weapon.icon}</span>
                        <div class="upgrade-text">
                            <strong>${weapon.name} ${isNew ? '' : `(Level ${currentLevel + 1})`}</strong>
                            <span>${weapon.getUpgradeText(currentLevel + 1)}</span>
                        </div>`;
                        const groupClass = WEAPON_GROUP_CLASS[key];
                        if (groupClass) {
                            button.classList.add(groupClass);
                        }
                        // --- GLOW & SCALE LOGIC ---
                        if (finalChoiceWeapons && finalChoiceWeapons.has(key)) {
                            button.classList.add('glowing', 'final-choice');
                        } else if (glowingWeapons && glowingWeapons.has(key)) {
                            button.classList.add('glowing');
                        }
                        // --- GLOW & SCALE LOGIC END ---
                    } else if (stat) {
                         button.innerHTML = `
                        <span class="upgrade-icon">${stat.icon}</span>
                        <div class="upgrade-text">
                            <strong>${stat.name}</strong>
                            <span>${stat.description}</span>
                        </div>`;
                    }
                    
                    const ownedWeaponCount = Object.keys(player.weapons).length;
                    const isNewWeapon = weapon && !player.weapons[key];

                    if (isNewWeapon && ownedWeaponCount >= 5) {
                        button.disabled = true;
                        button.classList.add('max-level');
                        const descSpan = button.querySelector('.upgrade-text span');
                        if (descSpan) {
                            descSpan.textContent = 'Maksimum silah sayısına ulaşıldı.';
                            descSpan.style.color = '#ff8888';
                        }
                    } else {
                        button.onclick = () => {
                            rerollButton.disabled = true;
                            rerollButton.style.opacity = '0.5';
                            skipButton.disabled = true;
                            skipButton.style.opacity = '0.5';
                            selectUpgrade(key, false);
                            selectionsMade++;
                            button.disabled = true;

                            if (selectionsAllowed > 1) {
                                button.style.backgroundColor = '#ffd700';
                                button.style.color = '#1a1a1a';
                                button.style.borderColor = '#fff';
                            }
                            
                            // After a selection, re-check other buttons in case the weapon limit was reached.
                            const newOwnedWeaponCount = Object.keys(player.weapons).length;
                            if (newOwnedWeaponCount >= 5) {
                                buttons.forEach((otherButton, i) => {
                                    if (otherButton.disabled) return;
                                    const otherKey = finalChoices[i];
                                    const otherIsWeapon = WEAPONS[otherKey];
                                    const otherIsNew = otherIsWeapon && !player.weapons[otherKey];
                                    if(otherIsNew) {
                                        otherButton.disabled = true;
                                        otherButton.classList.add('max-level');
                                        const desc = otherButton.querySelector('.upgrade-text span');
                                        if(desc) {
                                            desc.textContent = 'Maksimum silah sayısına ulaşıldı.';
                                            desc.style.color = '#ff8888';
                                        }
                                    }
                                });
                            }

                            const remainingEnabledButtons = buttons.filter(b => !b.disabled).length;

                            // Close the menu if the player has made all allowed selections OR if there are no more valid selections left.
                            if (selectionsMade >= selectionsAllowed || remainingEnabledButtons === 0) {
                                 buttons.forEach(b => {
                                    if (!b.disabled) {
                                        b.disabled = true;
                                        b.style.opacity = 0.5;
                                    }
                                });
                                setTimeout(() => {
                                   levelUpScreen.style.display = 'none';
                                   gamePaused = false;
                                   isModalActive = false;
                                   processModalQueue();
                                }, selectionsAllowed > 1 ? 500 : 200);
                            }
                        };
                    }

                    stopIndex++;
                    setTimeout(stopSpinning, 300);
                } else {
                    clearInterval(spinInterval);
                    // Check if all buttons are disabled after the animation
                    const allButtonsDisabled = Array.from(upgradeOptionsContainer.children).every(btn => btn.disabled);
                    if (allButtonsDisabled && finalChoices.length > 0) {
                        levelUpInfoEl.textContent = "Seçilecek uygun yükseltme yok!";
                        setTimeout(() => {
                            selectUpgrade(null, true); // This closes the screen and unpauses
                        }, 2000); // Give user time to read the message
                    }
                }
            };
            
            setTimeout(stopSpinning, 2000);
        }


        function selectUpgrade(key, closeImmediately = false) {
            if (key) {
                if (WEAPONS[key]) {
                    if (!player.weapons[key]) {
                        player.weapons[key] = 1;
                        player.weaponCooldowns[key] = 0;
                        weaponDamageStats[key] = 0;
                        if (!discoveredWeapons.includes(key)) {
                            discoveredWeapons.push(key);
                            saveDiscoveredWeapons();
                        }
                    } else {
                        player.weapons[key]++;
                    }
                    updateWeaponUI();
                    checkAchievements(); // Check for achievements after getting a weapon
                } else if (STAT_UPGRADES[key]) {
                    STAT_UPGRADES[key].apply();
                    floatingTexts.push({ x: player.x, y: player.y, text: STAT_UPGRADES[key].name, color: '#00ffff', life: 1.5, vy: 1, size: 22 });
                }
            }

            if (closeImmediately) {
                levelUpScreen.style.display = 'none';
                gamePaused = false;
                isModalActive = false;
                processModalQueue();
            }
        }

        function showDiscardWeaponScreen(capturedFlag = null) {
            if (isModalActive) {
                modalQueue.push(() => showDiscardWeaponScreen(capturedFlag));
                return;
            }
            isModalActive = true;
            gamePaused = true;
            discardWeaponOptions.innerHTML = '';

            const ownedWeapons = Object.keys(player.weapons);
            
            const titleEl = discardWeaponScreen.querySelector('h2');
            const pEl = discardWeaponScreen.querySelector('p');

            // Eğer manuel olarak açıldıysa ve 1'den az silah varsa, menüyü açma.
            if (!capturedFlag && ownedWeapons.length <= 1) {
                gamePaused = false;
                return;
            }

            // Eğer bayrak ele geçirildi ama 1'den az silah varsa, direkt ödülü ver.
            if (capturedFlag && ownedWeapons.length <= 1) {
                spawnPowerup('lootBox', capturedFlag.x, capturedFlag.y);
                gamePaused = false;
                isModalActive = false;
                processModalQueue();
                return;
            }
            
            if (capturedFlag) {
                titleEl.textContent = "KARARGAH GÜVENDE!";
                pEl.textContent = "Ödül olarak bir silahı bırakıp yerine Ganimet Kutusu alabilirsin.";
            } else {
                titleEl.textContent = "SİLAH BIRAK";
                pEl.textContent = "Yer açmak için bir silah seç.";
            }


            ownedWeapons.forEach(weaponId => {
                const weapon = WEAPONS[weaponId];
                const level = player.weapons[weaponId];
                const button = document.createElement('button');
                button.className = 'upgrade-button';
                button.style.opacity = 1; 
                button.innerHTML = `
                    <span class="upgrade-icon">${weapon.icon}</span>
                    <div class="upgrade-text">
                        <strong>${weapon.name}</strong>
                        <span>Seviye ${level}</span>
                    </div>
                `;
                button.onclick = () => {
                    delete player.weapons[weaponId];
                    delete weaponDamageStats[weaponId];
                    updateWeaponUI();
                    if (capturedFlag) {
                        spawnPowerup('lootBox', capturedFlag.x, capturedFlag.y);
                    }
                    closeDiscardWeaponScreen();
                };
                discardWeaponOptions.appendChild(button);
            });
            
            discardWeaponScreen.style.zIndex = modalBaseZIndex++;
            discardWeaponScreen.style.display = 'block';
            
            cancelDiscardButton.onclick = () => {
                 if (capturedFlag) {
                    spawnPowerup('lootBox', capturedFlag.x, capturedFlag.y);
                 }
                closeDiscardWeaponScreen();
            };
        }

        function closeDiscardWeaponScreen() {
            discardWeaponScreen.style.display = 'none';
            gamePaused = false;
            isModalActive = false;
            processModalQueue();
        }

        // --- Collision and Game Logic ---
        function checkCollisions() {
            // Bullet - Tank Collisions
            for(let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (!bullet) continue;
                if (bullet.owner === 'player') {
                    for(let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (bullet.hitEnemies && bullet.hitEnemies.includes(enemy.id)) continue;
                        if(Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y) < enemy.width / 2 + bullet.radius) {
                            const damage = bullet.damage;
                            const weaponId = bullet.weaponId;
                            enemy.health -= damage; 
                            if (weaponId && weaponDamageStats.hasOwnProperty(weaponId)) {
                                weaponDamageStats[weaponId] += damage;
                            }
                            enemy.isHit = true; 
                            enemy.hitTimer = 5;
                            
                            if (bullet.weaponId === 'flameDance' && ACHIEVEMENT_SETS.kundakci.isApplied) {
                                enemy.isBurning = true;
                                enemy.burnDamage = bullet.damage * 0.5; // Burn for 50% of the impact damage, per second.
                            }

                            const textColor = bullet.isStationaryBonus ? '#ffff00' : '#ffdd88';
                            const textSize = bullet.isStationaryBonus ? 30 : 24;
                            floatingTexts.push({ x: enemy.x, y: enemy.y, text: `${Math.floor(damage)}`, color: textColor, life: 1, vy: 1, size: textSize });

                            if (bullet.weaponId === 'missile') {
                                createExplosion(bullet.x, bullet.y, '#ffcc00'); // Füze patlama rengi
                            } else {
                                createImpactEffect(bullet.x, bullet.y);
                            }
                            
                            if (bullet.onHit) {
                                bullet.onHit(enemy, damage);
                            }

                            // Bullets with onHit (except Vampire) should be single-use and disappear after hitting.
                            if (bullet.onHit && bullet.weaponId !== 'vampire') {
                                bullets.splice(i, 1);
                                break;
                            }
                            
                            if (!bullet.hitEnemies) bullet.hitEnemies = [];
                            bullet.hitEnemies.push(enemy.id);
                            if(enemy.health <= 0) { 
                                if (enemy.type === 'boss') {
                                     isBossActive = false;
                                     spawnPowerup('lootBox', enemy.x, enemy.y);
                                     if (gameMode !== 'easy') {
                                        player.money += 1;
                                        floatingTexts.push({ x: enemy.x, y: enemy.y, text: `+1 TL`, color: '#ffd700', life: 1, vy: 1, size: 22 });
                                     }
                                } else {
                                    const dropRNG = Math.random();
                                    if (dropRNG < 0.01) { 
                                        spawnPowerup('magnet', enemy.x, enemy.y);
                                    } else if (dropRNG < 0.06) { 
                                        spawnPowerup('health', enemy.x, enemy.y);
                                    } else {
                                        if (enemy.maxHealth >= 300) { // Tier 3
                                            xpOrbs.push({x: enemy.x, y: enemy.y, radius: 9, value: enemy.xpValue * 5, color: '#ffd700'});
                                        } else if (enemy.maxHealth >= 120) { // Tier 2
                                            xpOrbs.push({x: enemy.x, y: enemy.y, radius: 8, value: enemy.xpValue * 3, color: '#ff9900'});
                                        } else { // Tier 1
                                            xpOrbs.push({x: enemy.x, y: enemy.y, radius: 7, value: enemy.xpValue, color: '#00ff88'});
                                        }
                                    }
                                    if (Math.random() < 0.05) { // 5% chance
                                        if (gameMode !== 'easy') {
                                            player.money += 1;
                                            floatingTexts.push({ x: enemy.x, y: enemy.y, text: `+1 TL`, color: '#ffd700', life: 1, vy: 1, size: 22 });
                                        }
                                    }
                                }
                                
                                createExplosion(enemy.x, enemy.y, enemy.color);
                                enemies.splice(j, 1); 
                                if (enemy.type !== 'miniBossDrone') {
                                    score += 10; 
                                }
                            }
                            if (bullet.ricochetsLeft > 0) {
                                bullet.ricochetsLeft--;
                                let closestEnemy = null, minDistance = Infinity;
                                enemies.forEach(other => {
                                    if (!bullet.hitEnemies.includes(other.id)) {
                                        const d = Math.hypot(bullet.x - other.x, bullet.y - other.y);
                                        if (d < minDistance) { minDistance = d; closestEnemy = other; }
                                    }
                                });
                                if (closestEnemy) { bullet.angle = Math.atan2(closestEnemy.y - bullet.y, closestEnemy.x - bullet.x) + Math.PI / 2; }
                                else if (!bullet.canPierce) { bullets.splice(i, 1); break; }
                            } else if (!bullet.canPierce || (bullet.maxHits && bullet.hitEnemies.length >= bullet.maxHits)) { 
                                bullets.splice(i, 1); 
                                break; 
                            }
                        }
                    }
                } else if(bullet.owner === 'enemy' && !player.isShielded) {
                     if(Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.width / 2 + bullet.radius) {
                         const baseDamage = 5;
                         const finalDamage = (gameMode === 'easy' ? 3 : baseDamage * player.damageReduction);
                         player.health = Math.max(0, player.health - finalDamage);
                         bullets.splice(i, 1);
                         player.isHit = true;
                         player.hitTimer = 5;
                         triggerScreenShake(4, 10);
                         const damageText = gameMode === 'easy' ? Math.floor(finalDamage) : finalDamage.toFixed(1);
                         floatingTexts.push({ x: player.x, y: player.y, text: `-${damageText}`, color: '#ff4444', life: 1, vy: 1, size: 30 });
                         createImpactEffect(player.x, player.y, player.color);
                         if(player.health <= 0) { gameOver(); }
                     }
                }
            }
            // Player - Powerup
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                if (Math.hypot(player.x - powerup.x, player.y - powerup.y) < player.width / 2 + powerup.size / 2) {
                    if (powerup.type === 'health') {
                        player.health = Math.min(player.maxHealth, player.health + 25);
                    } else if (powerup.type === 'magnet') {
                        xpOrbs.forEach(orb => orb.isAttracted = true);
                    } else if (powerup.type === 'lootBox') {
                        handleLevelUp(true);
                    }
                    powerups.splice(i, 1);
                }
            }
            // Player - Permanent Upgrade
            for (let i = permanentUpgrades.length - 1; i >= 0; i--) {
                const upg = permanentUpgrades[i];
                if (Math.hypot(player.x - upg.x, player.y - upg.y) < player.width / 2 + upg.size / 2) {
                    switch(upg.type) {
                        case 'maxHealth':
                            const oldMaxHealth = player.maxHealth;
                            player.maxHealth = Math.min(500, player.maxHealth + 25);
                            player.health += (player.maxHealth - oldMaxHealth);
                            break;
                        case 'speed':
                            player.speed = Math.min(6, player.speed * 1.15);
                            break;
                        case 'damageBonus':
                            player.damageBonus += 5;
                            break;
                        case 'healthRegen':
                            player.healthRegen += 1;
                            break;
                        case 'map':
                            hasMapUpgrade = true;
                            showObjectivePopup('HARİTA AÇILDI!');
                            if (mapHintEl) mapHintEl.style.display = 'block';
                            break;
                    }
                    // floatingTexts.push({ x: player.x, y: player.y, text: upg.text, color: upg.color, life: 1.5, vy: 1, size: 22 });
                    permanentUpgrades.splice(i, 1);
                }
            }
            // Player - Enemy Collision (for Kamikaze)
            if (!player.isShielded) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (enemy.type === 'motorcycle') {
                        if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.width / 2 + enemy.width / 2) {
                            const baseDamage = 15;
                            const finalDamage = (gameMode === 'easy' ? baseDamage * 0.5 : baseDamage) * player.damageReduction;
                            player.health = Math.max(0, player.health - finalDamage);
                            player.isHit = true;
                            player.hitTimer = 5;
                            triggerScreenShake(8, 15);
                            const damageText = gameMode === 'easy' ? Math.floor(finalDamage) : finalDamage.toFixed(1);
                            floatingTexts.push({ x: player.x, y: player.y, text: `-${damageText}`, color: '#ff9900', life: 1, vy: 1, size: 33 });
                            
                            createExplosion(enemy.x, enemy.y, enemy.color);
                            enemies.splice(i, 1);
                            if(player.health <= 0) { gameOver(); }
                        }
                    }
                }
            }
        }
        
        function checkTankObstacleCollision(tank, obsToTest) {
            const checkList = obsToTest ? [obsToTest] : obstacles;
            for (const obs of checkList) {
                if (obs.type === 'rect') {
                    if (tank.x + tank.width / 2 > obs.x && tank.x - tank.width / 2 < obs.x + obs.width &&
                        tank.y + tank.height / 2 > obs.y && tank.y - tank.height / 2 < obs.y + obs.height) {
                        return obs;
                    }
                } else if (obs.type === 'circle') {
                    if (Math.hypot(tank.x - obs.x, tank.y - obs.y) < obs.radius + tank.width / 2) {
                        return obs;
                    }
                }
            }
            return null;
        }

        function checkBulletObstacleCollision(bullet) {
             for (const obs of obstacles) {
                if (obs.type === 'rect') {
                    if (bullet.x > obs.x && bullet.x < obs.x + obs.width &&
                        bullet.y > obs.y && bullet.y < obs.y + obs.height) {
                        return true;
                    }
                } else if (obs.type === 'circle') {
                    if (Math.hypot(bullet.x - obs.x, bullet.y - obs.y) < obs.radius) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function checkPointInObstacle(x, y, obs) {
            if (obs.type === 'rect') {
                return x > obs.x && x < obs.x + obs.width && y > obs.y && y < obs.y + obs.height;
            } else if (obs.type === 'circle') {
                return Math.hypot(x - obs.x, y - obs.y) < obs.radius;
            }
            return false;
        }

        function triggerScreenShake(intensity, duration) {
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function resetUIColors() {
            if (uiColorState !== 'normal') {
                document.documentElement.style.setProperty('--crt-color', '#00ff88');
                document.documentElement.style.setProperty('--crt-glow', '0 0 5px #00ff88, 0 0 10px #00ff88, 0 0 15px #00ff88');
                document.documentElement.style.setProperty('--bar-bg', 'rgba(10, 30, 10, 0.5)');
                document.documentElement.style.setProperty('--dashboard-bg-start', '#05140a');
                document.documentElement.style.setProperty('--dashboard-bg-end', '#102a16');
                document.documentElement.style.setProperty('--dashboard-border', '#002a0f');
                document.documentElement.style.setProperty('--info-display-bg', '#1a2a1a');
                document.documentElement.style.setProperty('--info-display-border', '#3c5a3c');
                document.documentElement.style.setProperty('--shield-color', '#00aaff');
                document.documentElement.style.setProperty('--shield-glow', '0 0 5px #00aaff, 0 0 10px #00aaff, 0 0 15px #00aaff');
                uiColorState = 'normal';
            }
        }

        function gameOver(isVictory = false) {
            if (isGameOver) return;
            isGameOver = true;
            cancelAnimationFrame(animationFrameId);
            updateActiveQuestUI(''); // Clear quest text
            
            // Add current round's money to total and save
            if(gameMode !== 'easy') {
                totalMoney += player.money;
                saveTotalMoney();
            }
            player.money = 0; // Reset round money to prevent double-adding

            clearInterval(damageUpdateInterval);
            updateScoreboard(score);
            displayWeaponDamageScoreboard();
            
            // Setup and display the game over screen
            if(isVictory){
                gameOverTitle.textContent = "ZAFER!";
                gameOverScreen.classList.add('win');
                finalScoreEl.textContent = `Nihai Skor: ${score}`;
            } else {
                gameOverTitle.textContent = "OYUN BİTTİ";
                gameOverScreen.classList.remove('win');
                finalScoreEl.textContent = `Skor: ${score}`;
            }
            gameOverScreen.style.display = 'block';
            
            // Remove previous listener to avoid duplicates
            mainMenuFromGameOverButton.removeEventListener('click', returnToMainMenu);
            mainMenuFromGameOverButton.addEventListener('click', returnToMainMenu);
        }

        function returnToMainMenu() {
            cancelAnimationFrame(animationFrameId);
            isGameOver = true; // Stop the game state
            gamePaused = false;
            
            // Save money if returning from pause menu mid-game
            if (gameContainer.style.display === 'block' && player.money > 0) {
                 totalMoney += player.money;
                 saveTotalMoney();
                 player.money = 0; // Reset for next potential game start
            }

            // Hide all game-related elements
            gameOverScreen.style.display = 'none';
            pauseMenuEl.style.display = 'none';
            gameContainer.style.display = 'none';
            
            // Reset UI colors to default green for the main menu
            resetUIColors();

            // Update and show the main menu
            updateMainMenuUI();
            mainMenuEl.style.display = 'flex';
            
        }

        function gameWon() {
            if(isGameOver) return;
            gameOver(true);
        }
        
        function handleUnitCollisions() {
            const groundUnits = [player, ...enemies.filter(e => e.type !== 'helicopter' && e.type !== 'boss')];

            for (let i = 0; i < groundUnits.length; i++) {
                for (let j = i + 1; j < groundUnits.length; j++) {
                    const unit1 = groundUnits[i];
                    const unit2 = groundUnits[j];
                    if (!unit1 || !unit2) continue;

                    const dist = Math.hypot(unit1.x - unit2.x, unit1.y - unit2.y);
                    const combinedRadius = (unit1.width / 2) + (unit2.width / 2);

                    if (dist < combinedRadius && dist > 0) {
                        const overlap = combinedRadius - dist;
                        const angle = Math.atan2(unit2.y - unit1.y, unit2.x - unit1.x);
                        
                        const pushX = Math.cos(angle) * overlap / 2;
                        const pushY = Math.sin(angle) * overlap / 2;

                        // Store original positions
                        const u1_old_x = unit1.x, u1_old_y = unit1.y;
                        const u2_old_x = unit2.x, u2_old_y = unit2.y;

                        // Tentatively apply push to both
                        unit1.x -= pushX;
                        unit1.y -= pushY;
                        unit2.x += pushX;
                        unit2.y += pushY;

                        // Check for collisions with static obstacles
                        const u1_collides = checkTankObstacleCollision(unit1);
                        const u2_collides = checkTankObstacleCollision(unit2);

                        if (u1_collides && !u2_collides) {
                            // Unit1 is blocked, revert it and push unit2 by the full overlap amount.
                            unit1.x = u1_old_x;
                            unit1.y = u1_old_y;
                            unit2.x = u2_old_x + pushX * 2;
                            unit2.y = u2_old_y + pushY * 2;
                            // Re-check unit2's full-pushed position. If it also collides, revert everything.
                            if (checkTankObstacleCollision(unit2)) {
                                unit2.x = u2_old_x;
                                unit2.y = u2_old_y;
                            }
                        } else if (!u1_collides && u2_collides) {
                            // Unit2 is blocked, revert it and push unit1 by the full overlap.
                            unit2.x = u2_old_x;
                            unit2.y = u2_old_y;
                            unit1.x = u1_old_x - pushX * 2;
                            unit1.y = u1_old_y - pushY * 2;
                            // Re-check unit1's full-pushed position.
                            if (checkTankObstacleCollision(unit1)) {
                                unit1.x = u1_old_x;
                                unit1.y = u1_old_y;
                            }
                        } else if (u1_collides && u2_collides) {
                            // Both are blocked. Revert both. They will overlap this frame.
                            unit1.x = u1_old_x;
                            unit1.y = u1_old_y;
                            unit2.x = u2_old_x;
                            unit2.y = u2_old_y;
                        }
                        // If neither collides (!u1_collides && !u2_collides), they remain in their new pushed-apart positions.
                    }
                }
            }
        }

        function showObjectivePopup(message) {
            const popupEl = document.getElementById('objectivePopup');
            if (!popupEl) return;
            popupEl.textContent = message;
            popupEl.classList.remove('show');
            void popupEl.offsetWidth; 
            popupEl.classList.add('show');
        }

        function startFinalPhase() {
            isFinalPhase = true;
            fireWallRadius = Math.hypot(world.width, world.height) / 2;
            showObjectivePopup("UÇAĞA ULAŞ VE KAÇ!");
            updateActiveQuestUI('Uçağa Ulaş ve Kaç!');

            // Spawn 4 stationary bosses around the escape plane
            const plane = escapePlane;
            const dist = 400;
            createBoss(3, true, plane.x + dist, plane.y, 1);
            createBoss(3, true, plane.x - dist, plane.y, 2);
            createBoss(3, true, plane.x, plane.y + dist, 3);
            createBoss(3, true, plane.x, plane.y - dist, 4);
        }

        function restartGame() {
            resetUIColors();
            cancelAnimationFrame(animationFrameId);
            score = 0; isGameOver = false; gamePaused = false, isMapView = false, isBossActive = false;
            rerollCharges = 3;
            hasMapUpgrade = false;
            if (mapHintEl) mapHintEl.style.display = 'none';
            isModalActive = false;
            modalBaseZIndex = 1000; // Z-endeksi sıfırla
            laserTargetId = null;
            laserFocusTime = 0;
            laserCumulativeDamage = 0;
            bullets = [], enemies = [], particles = [], powerups = [], xpOrbs = [], muzzleFlashes = [], floatingTexts = [], specialProjectiles = [], permanentUpgrades = [], flags = [];
            
            if (damageUpdateInterval) clearInterval(damageUpdateInterval);
            weaponDamageStats = {};

            nextPrisonerScoreReward = 100;
            nextPrisonerXpReward = 50;
            prisonersRescuedCount = 0;

            damageOverlay.classList.remove('critical');

            const vehicleData = VEHICLES[selectedVehicle] || VEHICLES['ALTAY'];

            Object.assign(player, {
                x: world.width / 2, y: world.height / 2 + 300,
                angle: Math.PI, turretAngle: Math.PI,
                vehicleType: vehicleData.name,
                type: vehicleData.type,
                width: vehicleData.width,
                height: vehicleData.height,
                color: vehicleData.color,
                turretColor: vehicleData.turretColor,
                speed: vehicleData.speed,
                maxHealth: vehicleData.health,
                health: vehicleData.health,
                level: 1, xp: 0, xpToNextLevel: 100,
                weapons: {}, weaponCooldowns: {},
                magazine: 30,
                isReloading: false,
                reloadTimer: 0,
                dashFuel: 120, maxDashFuel: 120, // Varsayılan değere sıfırla
                isBoosting: false,
                shieldCooldownTimer: 0, shieldDuration: 180, // Varsayılan değere sıfırla
                isShielded: false, isMoving: false,
                headlightsOn: false, // Işıkları sıfırla
                trackSpawnTimer: 0,
                money: 0,
                damageBonusMultiplier: 1, fireRateBonus: 1, damageReduction: 1,
            });

            // Başarı bonuslarını sıfırla
            player.damageBonusMultiplier = 1;
            player.fireRateBonus = 1;
            player.damageReduction = 1;

            if (gameMode === 'easy') {
                player.maxHealth *= 1.5;
                player.damageBonusMultiplier = 1.5; // %50 daha fazla hasar
                player.damageReduction = 0.75; // %25 daha az hasar al
            } else {
                // Sadece normal modda kalıcı yükseltmeleri uygula
                const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
                const armorBonus = (currentVehicleUpgrades.maxArmor || 0) * ARMOR_BONUS_PER_LEVEL;
                player.maxHealth += armorBonus;

                const shieldBonus = (currentVehicleUpgrades.shieldDuration || 0) * SHIELD_BONUS_PER_LEVEL;
                player.shieldDuration += shieldBonus;

                const dashBonus = (currentVehicleUpgrades.dashDuration || 0) * DASH_BONUS_PER_LEVEL;
                player.maxDashFuel += dashBonus;

                const attackSpeedBonus = (currentVehicleUpgrades.attackSpeed || 0) * ATTACK_SPEED_BONUS_PER_LEVEL;
                player.defaultGunCooldownBonus = attackSpeedBonus;
            }
        
        player.health = player.maxHealth;
        player.dashFuel = player.maxDashFuel;


        for(const key in ACHIEVEMENT_SETS) {
            ACHIEVEMENT_SETS[key].isApplied = false;
        }
        
            enemySpawnTimer = 0;
            gameTimeInSeconds = 0;
            bossesSpawned = 0;
            capturedFlags = 0;
            isFinalPhase = false;
            nextScalingBossTime = 420 + 180; // 7min + 3min for the first scaling boss
            scalingBossSpawnCount = 1;
            nextBossCountIncreaseTime = 600;
            
            player.weapons['defaultGun'] = 1;
            player.weaponCooldowns['defaultGun'] = 0;
            weaponDamageStats['defaultGun'] = 0;

            escapePlane = {
                x: world.width / 2, y: world.height / 2,
                captureRadius: 250,
                captureProgress: 0,
                isCaptured: false,
            };

            generateMap();
            
            // Oyunun başında 10 motorsikletli spawn et
            for (let i = 0; i < 10; i++) {
                createEnemy('motorcycle');
            }

            spawnAllPermanentUpgrades();
            spawnAllFlags();
            updateWeaponUI();
            gameOverScreen.style.display = 'none';
            levelUpScreen.style.display = 'none';
            pauseMenuEl.style.display = 'none';
            damageUpdateInterval = setInterval(updateWeaponDamageUI, 1000);
            showObjectivePopup('4 Karargahı Ele Geçir');
            updateActiveQuestUI('4 Karargahı Ele Geçir');
        }

        // --- SCOREBOARD ---
        function updateScoreboard(newScore) {
            let scores = JSON.parse(localStorage.getItem('tankScores')) || [];
            scores.push({ name: playerName, score: newScore, date: new Date().toLocaleDateString('en-US') });
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('tankScores', JSON.stringify(scores));
            displayScoreboard(scores);
        }

        function displayScoreboard(scores) {
            if (!scoreboardEl) return;
            scoreboardEl.innerHTML = '<h3>YÜKSEK SKORLAR</h3>';
            const list = document.createElement('ol');
            if (scores.length === 0) {
                list.innerHTML = '<li>Henüz skor yok.</li>';
            } else {
                scores.forEach(scoreItem => {
                    const item = document.createElement('li');
                    item.innerHTML = `<span>${scoreItem.name} <small>(${scoreItem.date})</small></span> <span>${scoreItem.score}</span>`;
                    list.appendChild(item);
                });
            }
            scoreboardEl.appendChild(list);
        }

        function displayWeaponDamageScoreboard() {
            const weaponScoreboardEl = document.getElementById('weaponDamageScoreboard');
            if (!weaponScoreboardEl) return;

            weaponScoreboardEl.innerHTML = '<h3>SİLAH HASARI</h3>';
            const list = document.createElement('ol');

            const sortedWeapons = Object.entries(weaponDamageStats)
                .filter(([id, damage]) => damage > 0)
                .sort(([, a], [, b]) => b - a);

            if (sortedWeapons.length === 0) {
                list.innerHTML = '<li>Hiç hasar verilmedi...</li>';
            } else {
                sortedWeapons.forEach(([id, damage]) => {
                    const weapon = WEAPONS[id];
                    if (weapon) {
                        const item = document.createElement('li');
                        item.innerHTML = `<span>${weapon.icon} ${weapon.name}</span> <span>${Math.floor(damage)}</span>`;
                        list.appendChild(item);
                    }
                });
            }
            weaponScoreboardEl.appendChild(list);
        }

        // --- PERSISTENCE (Money, Upgrades, Vehicles) ---
        function saveTotalMoney() {
            localStorage.setItem('tankTotalMoney', totalMoney);
        }

        function loadTotalMoney() {
            totalMoney = parseInt(localStorage.getItem('tankTotalMoney')) || 0;
        }

        function savePermanentUpgrades() {
            localStorage.setItem('tankAllVehicleUpgrades', JSON.stringify(allVehicleUpgrades));
        }

        function loadPermanentUpgrades() {
            const saved = localStorage.getItem('tankAllVehicleUpgrades');
            // First, initialize upgrades for all vehicles to their default (0) state.
            for (const vehicleName in VEHICLES) {
                allVehicleUpgrades[vehicleName] = { maxArmor: 0, shieldDuration: 0, dashDuration: 0, attackSpeed: 0 };
            }

            // Then, load and merge the saved data.
            if (saved) {
                const loadedUpgrades = JSON.parse(saved);
                for (const vehicleName in loadedUpgrades) {
                    if (allVehicleUpgrades[vehicleName]) {
                        Object.assign(allVehicleUpgrades[vehicleName], loadedUpgrades[vehicleName]);
                    }
                }
            }
        }

        function saveUnlockedVehicles() {
            localStorage.setItem('tankUnlockedVehicles', JSON.stringify(unlockedVehicles));
            localStorage.setItem('tankSelectedVehicle', selectedVehicle);
        }

        function loadUnlockedVehicles() {
            const savedVehicles = localStorage.getItem('tankUnlockedVehicles');
            if (savedVehicles) {
                unlockedVehicles = JSON.parse(savedVehicles);
            }
            const savedSelection = localStorage.getItem('tankSelectedVehicle');
            if (savedSelection && unlockedVehicles.includes(savedSelection)) {
                selectedVehicle = savedSelection;
            }
        }

        function saveDiscoveredWeapons() {
            localStorage.setItem('tankDiscoveredWeapons', JSON.stringify(Array.from(discoveredWeapons)));
        }

        function loadDiscoveredWeapons() {
            const saved = localStorage.getItem('tankDiscoveredWeapons');
            if (saved) {
                discoveredWeapons = JSON.parse(saved);
                if (!Array.isArray(discoveredWeapons) || discoveredWeapons.length === 0) {
                     discoveredWeapons = ['defaultGun'];
                }
            } else {
                discoveredWeapons = ['defaultGun'];
            }
        }

        function saveUnlockedAchievements() {
            localStorage.setItem('tankUnlockedAchievements', JSON.stringify(unlockedAchievements));
        }

        function loadUnlockedAchievements() {
            const saved = localStorage.getItem('tankUnlockedAchievements');
            if (saved) {
                unlockedAchievements = JSON.parse(saved);
                if (!Array.isArray(unlockedAchievements)) {
                     unlockedAchievements = [];
                }
            } else {
                unlockedAchievements = [];
            }
        }

        function updateUpgradesPanelHeader() {
            const displayContainer = document.getElementById('selected-vehicle-display-upgrades');
            if (!displayContainer) return;

            const vehicle = VEHICLES[selectedVehicle];
            if (!vehicle) {
                displayContainer.innerHTML = '';
                return;
            };

            displayContainer.innerHTML = `
                <span class="vehicle-icon" style="font-size: 2.5em;">${vehicle.icon}</span>
                <span class="vehicle-name" style="font-size: var(--ui-font-size-base);">${vehicle.name}</span>
            `;
        }


        function updateMainMenuUI() {
            if (totalMoneyDisplayEl) {
                totalMoneyDisplayEl.textContent = totalMoney;
            }
            updateArmorUpgradeUI();
            updateShieldUpgradeUI();
            updateDashUpgradeUI();
            updateAttackSpeedUpgradeUI();
            updateVehicleSelectionUI();
            updateUpgradesPanelHeader();
            updateDiscoveredWeaponsUI();
            updateUnlockedAchievementsUI();
        }

        function updateUnlockedAchievementsUI() {
            const achievementTitles = document.querySelectorAll('#weapons-panel h3[data-achievement-id]');
            achievementTitles.forEach(h3 => {
                const achievementId = h3.dataset.achievementId;
                const achievementData = ACHIEVEMENT_SETS[achievementId];
                if (!achievementData) return;

                if (unlockedAchievements.includes(achievementId)) {
                    h3.textContent = achievementData.name;
                    h3.classList.remove('locked');
                } else {
                    h3.textContent = '???';
                    h3.classList.add('locked');
                }
            });
        }

        function updateDiscoveredWeaponsUI() {
            const weaponListItems = document.querySelectorAll('#weapons-panel .weapon-list li');
            weaponListItems.forEach(li => {
                const weaponId = li.dataset.weaponId;
                const weapon = WEAPONS[weaponId];
                if (!weapon) return; // Silah verisi yoksa atla

                if (!discoveredWeapons.includes(weaponId)) {
                    li.classList.add('locked');
                    li.innerHTML = `<span class="weapon-icon">?</span> ???`;
                } else {
                    li.classList.remove('locked');
                    li.innerHTML = `<span class="weapon-icon">${weapon.icon}</span> ${weapon.name}`;
                }
            });
        }

        function updateVehicleSelectionUI() {
            const armoredContainer = document.getElementById('armoredVehicleContainer');
            const tankContainer = document.getElementById('tankVehicleContainer');
            const helicopterContainer = document.getElementById('helicopterVehicleContainer');
            const tooltip = document.getElementById('vehicleTooltip');
            if (!armoredContainer || !tankContainer || !helicopterContainer || !tooltip) return;

            armoredContainer.innerHTML = '';
            tankContainer.innerHTML = '';
            helicopterContainer.innerHTML = '';

            // Araçları tiplerine göre grupla
            const vehicleGroups = {
                armored: [],
                tank: [],
                helicopter: []
            };
            for (const vehicleName in VEHICLES) {
                const vehicle = VEHICLES[vehicleName];
                if (vehicleGroups[vehicle.type]) {
                    vehicleGroups[vehicle.type].push(vehicle);
                }
            }

            // Her grubu fiyata göre sırala ve öğeleri oluştur
            for (const type in vehicleGroups) {
                const container = type === 'armored' ? armoredContainer : type === 'tank' ? tankContainer : helicopterContainer;
                
                vehicleGroups[type]
                    .sort((a, b) => a.price - b.price)
                    .forEach(vehicle => {
                        const item = document.createElement('div');
                        item.className = 'vehicle-item';

                        const isUnlocked = unlockedVehicles.includes(vehicle.name);

                        if (isUnlocked) {
                            item.innerHTML = `
                                <span class="vehicle-icon">${vehicle.icon}</span>
                                <span class="vehicle-name">${vehicle.name}</span>
                            `;
                            if (vehicle.name === selectedVehicle) {
                                item.classList.add('selected');
                            } else {
                                item.onclick = () => {
                                    selectedVehicle = vehicle.name;
                                    saveUnlockedVehicles();
                                    updateMainMenuUI();
                                };
                            }
                        } else {
                            item.classList.add('locked');

                            let canBeBought = true;
                            const dependencies = TIER_3_VEHICLES[vehicle.name];
                            let dependenciesMet = true;

                            if (dependencies) {
                                dependenciesMet = dependencies.every(dep => unlockedVehicles.includes(dep));
                            }

                            if (!dependenciesMet) {
                                canBeBought = false;
                                item.innerHTML = `
                                    <span class="vehicle-price">🔒</span>
                                    <span class="vehicle-name">${vehicle.name}</span>
                                `;
                            } else {
                                item.innerHTML = `
                                    <span class="vehicle-price">${vehicle.price} TL</span>
                                    <span class="vehicle-name">${vehicle.name}</span>
                                `;
                            }

                            if (canBeBought && totalMoney >= vehicle.price) {
                                item.classList.add('buyable');
                                item.onclick = () => {
                                    totalMoney -= vehicle.price;
                                    unlockedVehicles.push(vehicle.name);
                                    selectedVehicle = vehicle.name;
                                    saveTotalMoney();
                                    saveUnlockedVehicles();
                                    updateMainMenuUI();
                                };
                            }
                        }

                        item.addEventListener('mouseenter', (e) => {
                            // Get the stats for the current vehicle
                            const damageStat = VEHICLE_BASE_DAMAGE[vehicle.name] || 0;
                            const armorStat = vehicle.health;
                            const speedStat = vehicle.speed;

                            // Potansiyel SNH'yi (Saniye Başına Hasar) hesapla
                            let dpsStat = 0;
                            if (vehicle.type === 'tank') {
                                // Tanklar için bekleme süresi 100 frame (60 FPS'de ~1.67 saniye).
                                // Bu, Ana Silah'ın seviye 1 istatistiklerine dayanmaktadır.
                                const cooldownInSeconds = 100 / 60; 
                                dpsStat = damageStat / cooldownInSeconds;
                            } else if (vehicle.type === 'armored') {
                                // Zırhlı araçlar 30 mermi atar (her biri 5 frame sürer), sonra 120 frame doldurur.
                                const fireTime = 30 * 5; 
                                const reloadTime = 120; 
                                const cycleTimeInSeconds = (fireTime + reloadTime) / 60;
                                const totalDamagePerCycle = 30 * damageStat;
                                dpsStat = totalDamagePerCycle / cycleTimeInSeconds;
                            } else if (vehicle.type === 'helicopter') {
                                // Helikopterler 5'li atış yapar ve 90 frame bekler.
                                const burstDamage = 5 * damageStat;
                                const cooldownInSeconds = 90 / 60;
                                dpsStat = burstDamage / cooldownInSeconds;
                            }

                            // Calculate ratings from 1 to 10
                            const armorRating = Math.max(1, 1 + Math.floor(((armorStat - STAT_SCALES.armor.min) / (STAT_SCALES.armor.max - STAT_SCALES.armor.min)) * 9));
                            const speedRating = Math.max(1, 1 + Math.floor(((speedStat - STAT_SCALES.speed.min) / (STAT_SCALES.speed.max - STAT_SCALES.speed.min)) * 9));
                            const dpsRating = Math.max(1, 1 + Math.floor(((dpsStat - STAT_SCALES.dps.min) / (STAT_SCALES.dps.max - STAT_SCALES.dps.min)) * 9));


                            // Create the rating bar HTML
                            const createStatBar = (label, rating) => {
                                const fillWidth = Math.min(100, rating * 10);
                                return `
                                    <div class="stat-bar-container">
                                        <strong class="stat-bar-label">${label}</strong>
                                        <div class="stat-bar-wrapper">
                                            <div class="stat-bar-fill" style="width: ${fillWidth}%;"></div>
                                        </div>
                                    </div>
                                `;
                            };
                            
                            let requirementHTML = '';
                            const isUnlocked = unlockedVehicles.includes(vehicle.name);
                            if (!isUnlocked) {
                                const dependencies = TIER_3_VEHICLES[vehicle.name];
                                if (dependencies) {
                                    const hasDependencies = dependencies.every(dep => unlockedVehicles.includes(dep));
                                    if (!hasDependencies) {
                                        requirementHTML = `<p style="color: #ff9900; font-weight: bold; margin-top: 10px;">Gereken: ${dependencies.join(' ve ')}</p>`;
                                    }
                                }
                            }
                            
                            tooltip.innerHTML = `
                                <h4>${vehicle.name}</h4>
                                <div class="stats">
                                    ${createStatBar('Hasar', dpsRating)}
                                    ${createStatBar('Zırh', armorRating)}
                                    ${createStatBar('Hız', speedRating)}
                                </div>
                                <p>${vehicle.description}</p>
                                ${requirementHTML}
                            `;
                            tooltip.style.display = 'block';
                            
                            const rect = item.getBoundingClientRect();
                            
                            // Ekranın sağına çok yakınsa, tooltip'i sola yerleştir
                            if (rect.right + 320 > window.innerWidth) {
                                 tooltip.style.left = `${rect.left - 310}px`;
                            } else {
                                 tooltip.style.left = `${rect.right + 10}px`;
                            }
                           
                            tooltip.style.top = `${rect.top}px`;
                        });

                        item.addEventListener('mouseleave', () => {
                            tooltip.style.display = 'none';
                        });
                        
                        container.appendChild(item);
                    });
            }
        }

        function updateArmorUpgradeUI() {
            const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
            if (!currentVehicleUpgrades) return;

            maxArmorSlotsContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const slot = document.createElement('div');
                slot.className = 'upgrade-slot';
                if (i < currentVehicleUpgrades.maxArmor) {
                    slot.classList.add('purchased');
                }
                maxArmorSlotsContainer.appendChild(slot);
            }

            if (currentVehicleUpgrades.maxArmor >= 5) {
                buyArmorUpgradeButton.disabled = true;
                armorUpgradeCostEl.textContent = 'MAKS. SEVİYE';
            } else {
                const cost = ARMOR_UPGRADE_COSTS[currentVehicleUpgrades.maxArmor];
                armorUpgradeCostEl.textContent = `${cost} TL`;
                buyArmorUpgradeButton.disabled = totalMoney < cost;
            }
        }

        function updateShieldUpgradeUI() {
            const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
            if (!currentVehicleUpgrades) return;

            maxShieldSlotsContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const slot = document.createElement('div');
                slot.className = 'upgrade-slot';
                if (i < currentVehicleUpgrades.shieldDuration) {
                    slot.classList.add('purchased');
                }
                maxShieldSlotsContainer.appendChild(slot);
            }

            if (currentVehicleUpgrades.shieldDuration >= 5) {
                buyShieldUpgradeButton.disabled = true;
                shieldUpgradeCostEl.textContent = 'MAKS. SEVİYE';
            } else {
                const cost = SHIELD_UPGRADE_COSTS[currentVehicleUpgrades.shieldDuration];
                shieldUpgradeCostEl.textContent = `${cost} TL`;
                buyShieldUpgradeButton.disabled = totalMoney < cost;
            }
        }

        function updateDashUpgradeUI() {
            const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
            if (!currentVehicleUpgrades) return;

            maxDashSlotsContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const slot = document.createElement('div');
                slot.className = 'upgrade-slot';
                if (i < currentVehicleUpgrades.dashDuration) {
                    slot.classList.add('purchased');
                }
                maxDashSlotsContainer.appendChild(slot);
            }

            if (currentVehicleUpgrades.dashDuration >= 5) {
                buyDashUpgradeButton.disabled = true;
                dashUpgradeCostEl.textContent = 'MAKS. SEVİYE';
            } else {
                const cost = DASH_UPGRADE_COSTS[currentVehicleUpgrades.dashDuration];
                dashUpgradeCostEl.textContent = `${cost} TL`;
            buyDashUpgradeButton.disabled = totalMoney < cost;
        }
    }

    function updateAttackSpeedUpgradeUI() {
        const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
        if (!currentVehicleUpgrades) return;

        maxAttackSpeedSlotsContainer.innerHTML = '';
        for (let i = 0; i < 5; i++) {
            const slot = document.createElement('div');
            slot.className = 'upgrade-slot';
            if (i < currentVehicleUpgrades.attackSpeed) {
                slot.classList.add('purchased');
            }
            maxAttackSpeedSlotsContainer.appendChild(slot);
        }

        if (currentVehicleUpgrades.attackSpeed >= 5) {
            buyAttackSpeedUpgradeButton.disabled = true;
            attackSpeedUpgradeCostEl.textContent = 'MAKS. SEVİYE';
        } else {
            const cost = ATTACK_SPEED_UPGRADE_COSTS[currentVehicleUpgrades.attackSpeed];
            attackSpeedUpgradeCostEl.textContent = `${cost} TL`;
            buyAttackSpeedUpgradeButton.disabled = totalMoney < cost;
        }
    }

    // --- PATHFINDING (A* ALGORITHM) ---
    
    function updateActiveQuestUI(text) {
        if (questTextEl && activeQuestUI) {
            if (text) {
                questTextEl.textContent = text;
                activeQuestUI.style.display = 'flex';
            } else {
                activeQuestUI.style.display = 'none';
            }
        }
    }

    function processModalQueue() {
        if (modalQueue.length > 0) {
                const nextModal = modalQueue.shift();
                // Olası yarış koşullarını önlemek ve arayüzün güncellenmesine izin vermek için kısa bir zaman aşımı kullanın
                setTimeout(nextModal, 100); 
            }
        }

        function updateGrid() {
            const cols = Math.floor(world.width / GRID_SIZE);
            const rows = Math.floor(world.height / GRID_SIZE);
            grid = Array(cols).fill(null).map(() => Array(rows).fill(0));

            obstacles.forEach(obs => {
                const startCol = Math.floor(obs.x / GRID_SIZE);
                const endCol = Math.floor((obs.x + (obs.width || obs.radius * 2)) / GRID_SIZE);
                const startRow = Math.floor(obs.y / GRID_SIZE);
                const endRow = Math.floor((obs.y + (obs.height || obs.radius * 2)) / GRID_SIZE);

                for (let c = startCol; c <= endCol; c++) {
                    for (let r = startRow; r <= endRow; r++) {
                        if (c >= 0 && c < cols && r >= 0 && r < rows) {
                            grid[c][r] = 1;
                        }
                    }
                }
            });
        }

        function findPath(startEntity, endEntity) {
            const startNode = { x: Math.floor(startEntity.x / GRID_SIZE), y: Math.floor(startEntity.y / GRID_SIZE) };
            const endNode = { x: Math.floor(endEntity.x / GRID_SIZE), y: Math.floor(endEntity.y / GRID_SIZE) };
            
            if (!grid || grid.length === 0 || !grid[0]) return null;
            const cols = grid.length;
            const rows = grid[0].length;

            if (startNode.x < 0 || startNode.x >= cols || startNode.y < 0 || startNode.y >= rows ||
                endNode.x < 0 || endNode.x >= cols || endNode.y < 0 || endNode.y >= rows ||
                grid[endNode.x][endNode.y] === 1) {
                return null;
            }
            
            let openList = [];
            let closedList = new Set();
            let start = { ...startNode, g: 0, h: 0, f: 0, parent: null };
            openList.push(start);
            
            while(openList.length > 0) {
                let lowestIndex = 0;
                for(let i=1; i<openList.length; i++) if(openList[i].f < openList[lowestIndex].f) lowestIndex = i;
                let currentNode = openList.splice(lowestIndex, 1)[0];
                closedList.add(`${currentNode.x},${currentNode.y}`);
                if(currentNode.x === endNode.x && currentNode.y === endNode.y) {
                    let path = []; let temp = currentNode;
                    while(temp) { path.push(temp); temp = temp.parent; }
                    return path.reverse();
                }
                const neighbors = [ {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}, {x: -1, y: -1}, {x: -1, y: 1}, {x: 1, y: -1}, {x: 1, y: 1} ];
                for(const n of neighbors) {
                    const neighborX = currentNode.x + n.x;
                    const neighborY = currentNode.y + n.y;
                    if(neighborX < 0 || neighborX >= cols || neighborY < 0 || neighborY >= rows || grid[neighborX][neighborY] === 1 || closedList.has(`${neighborX},${neighborY}`)) continue;
                    const gScore = currentNode.g + 1;
                    let gScoreIsBest = false;
                    let neighborNode = openList.find(node => node.x === neighborX && node.y === neighborY);
                    if(!neighborNode) {
                        gScoreIsBest = true;
                        neighborNode = { x: neighborX, y: neighborY, h: 0 };
                        openList.push(neighborNode);
                    } else if(gScore < neighborNode.g) gScoreIsBest = true;
                    if(gScoreIsBest) {
                        neighborNode.parent = currentNode;
                        neighborNode.g = gScore;
                        neighborNode.h = Math.abs(neighborX - endNode.x) + Math.abs(neighborY - endNode.y);
                        neighborNode.f = neighborNode.g + neighborNode.h;
                    }
                }
            }
            return null;
        }


        // --- Main Game Loop ---
        function gameLoop() {
            if (isGameOver) {
                return;
            }

            if(isMapView) {
                drawFullScreenMap();
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            if(gamePaused) {
                // Oyun duraklatıldığında, konfeti gibi bazı animasyonları devam ettirirken
                // statik sahneyi çizmeye devam etmek istiyoruz. Sadece parçacıkları güncelliyoruz, oyun durumunu değil.
                updateParticles(); // Konfeti vb. güncelle.

                // --- ÇİZİM (DURAKLATILMIŞ DURUM) ---
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(-camera.x, -camera.y);
                
                drawBackground();
                obstacles.forEach(drawObstacle);
                powerups.forEach(drawPowerup);
                permanentUpgrades.forEach(drawPermanentUpgrade);
                flags.forEach(drawFlag);
                drawEscapePlane();
                xpOrbs.forEach(drawXpOrb);
                
                specialProjectiles.forEach(drawSpecialProjectile);
                if (!isGameOver) drawUnit(player);
                npcs.forEach(drawUnit);
                enemies.forEach(drawUnit);
                bullets.forEach(drawBullet);
                particles.forEach(drawParticle); // Tüm güncellenmiş parçacıkları çiz
                muzzleFlashes.forEach(drawMuzzleFlash);
                floatingTexts.forEach(drawFloatingText);
                drawFireWall();
                ctx.restore();

                // Kullanıcı arayüzünü üste çiz
                drawMinimap();
                drawObjectiveIndicators();
            
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            
            // --- GÜNCELLEME (ÇALIŞMA DURUMU) ---
            gameTimeInSeconds += 1/60;
            updatePlayer();
            updatePlayerNpcInteractions();
            updateNPCs();
            updateEnemies();
            handleUnitCollisions();
            updateBullets();
            updateSpecialProjectiles();
            updateParticles();
            updateXpOrbs();
            updateWeapons();
            updateFloatingTexts();
            updateFlags();
            updateFinalPhase();
            checkCollisions();
            updateCamera();
            updateUI();
            
            // --- DÜŞMAN VE GÜÇLENDİRME SPAWN'LAMA ---
            const nonBossEnemiesCount = enemies.filter(e => e.type !== 'boss' && e.type !== 'kule').length;
            const maxEnemies = 10 + player.level * 2;

            if (nonBossEnemiesCount < maxEnemies && !isFinalPhase) {
                // Spawn aralığı zamanla azalır, 2 saniyeden 0.5 saniyeye 5 dakikada düşer.
                const maxInterval = 120; // Başlangıçta 2 saniye
                const minInterval = 30;  // En yoğun anda 0.5 saniye
                const timeToReachMin = 300; // 5 dakika (300 saniye)
                
                enemySpawnInterval = Math.max(minInterval, maxInterval - (gameTimeInSeconds / timeToReachMin) * (maxInterval - minInterval));

                enemySpawnTimer++;
                if (enemySpawnTimer >= enemySpawnInterval) {
                    const spawnCount = 1 + Math.floor(player.level / 5) + Math.floor(score / 1000);
                    const allowedSpawns = Math.min(spawnCount, maxEnemies - nonBossEnemiesCount);
                    for (let i = 0; i < allowedSpawns; i++) {
                        createEnemy();
                    }
                    enemySpawnTimer = 0;
                }
            }
            
            // --- BOSS SPAWN ---
            if (!isFinalPhase && bossesSpawned < bossSpawnTimes.length && gameTimeInSeconds >= bossSpawnTimes[bossesSpawned]) {
                createBoss(bossesSpawned);
                bossesSpawned++;
            }

            // Her 10 dakikada bir ölçeklenen boss'ların sayısını artırma zamanı gelip gelmediğini kontrol et
            if (gameTimeInSeconds >= nextBossCountIncreaseTime) {
                scalingBossSpawnCount++;
                nextBossCountIncreaseTime += 600; // Bir sonraki artışı 10 dakika sonraya ayarla
                showObjectivePopup(`DİKKAT! MECHA BOT DALGALARI GÜÇLENDİ! (${scalingBossSpawnCount}x)`);
            }

            // İlk boss'lardan sonra ölçeklenen boss'lar
            if (!isFinalPhase && bossesSpawned >= bossSpawnTimes.length && gameTimeInSeconds >= nextScalingBossTime) {
                for (let i = 0; i < scalingBossSpawnCount; i++) {
                    createBoss(bossesSpawned);
                    bossesSpawned++;
                }
                nextScalingBossTime += 180; // Bir sonrakinin zamanlayıcısını 3 dakika sonraya ayarla
            }

            // --- ÇİZİM (ÇALIŞMA DURUMU) ---
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            if (screenShake.duration > 0) {
                const dx = (Math.random() - 0.5) * screenShake.intensity;
                const dy = (Math.random() - 0.5) * screenShake.intensity;
                ctx.translate(dx, dy);
                screenShake.duration--;
            }
            
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            
            drawBackground();
            obstacles.forEach(drawObstacle);
            powerups.forEach(drawPowerup);
            permanentUpgrades.forEach(drawPermanentUpgrade);
            flags.forEach(drawFlag);
            drawEscapePlane();
            xpOrbs.forEach(drawXpOrb);
            
            specialProjectiles.forEach(drawSpecialProjectile);
            if (!isGameOver) drawUnit(player);
            npcs.forEach(drawUnit);
            enemies.forEach(drawUnit);
            bullets.forEach(drawBullet);
            particles.forEach(drawParticle);
            muzzleFlashes.forEach(drawMuzzleFlash);
            floatingTexts.forEach(drawFloatingText);
            drawFireWall();
            ctx.restore();

            ctx.restore(); // Ekran sarsıntısı için olanı geri al
            
            // Kamera dönüşümünden sonra kullanıcı arayüzünü çiz
            drawMinimap();
            drawObjectiveIndicators();
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        
        function togglePause(forceState) {
            // Başka bir modal (seviye atlama/at) açıksa duraklatmaya izin verme.
            if (isModalActive && pauseMenuEl.style.display !== 'block') return;
            if (isGameOver) return;

            // Yeni durumu belirle
            const willBePaused = (typeof forceState === 'boolean') ? forceState : !gamePaused;

            gamePaused = willBePaused;
            isModalActive = willBePaused; // Duraklatma menüsü bir modaldır
            if (willBePaused) {
                updatePauseMenuWeaponsUI();
                pauseMenuEl.style.zIndex = modalBaseZIndex++;
            }
            pauseMenuEl.style.display = willBePaused ? 'block' : 'none';

            if (!willBePaused) {
                processModalQueue(); // Her ihtimale karşı devam ettirildiğinde kuyruğu işle
            }
        }

        window.addEventListener('keydown', (e) => {
             keys[e.key.toLowerCase()] = true;

             if (e.key.toLowerCase() === 'r') {
                restartGame();
                gameLoop();
            }
             if (e.key.toLowerCase() === 'm') {
                if (hasMapUpgrade && !gamePaused) {
                    isMapView = !isMapView;
                    if (mapHintEl.style.display === 'block') {
                        mapHintEl.style.display = 'none';
                    }
                } else if (!hasMapUpgrade && !gamePaused) {
                    showObjectivePopup('Haritayı bulman gerek.');
                }
            }
             if (e.key.toLowerCase() === 'escape') {
                 if (isMapView) {
                     isMapView = false;
                 } else {
                     togglePause();
                 }
             }
        });
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
            if (key === 'e') {
                player.headlightsOn = !player.headlightsOn;
            }
            if (key === ' ') e.preventDefault();
        });
        canvas.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; });
        
        restartButton.addEventListener('click', () => {
            restartGame();
            gameLoop();
        });
        pauseButton.addEventListener('click', () => togglePause(true));
        resumeButton.addEventListener('click', () => togglePause(false));
        restartFromPauseButton.addEventListener('click', () => {
            restartGame();
            gameLoop();
        });

        mapButton.addEventListener('click', () => {
            if (hasMapUpgrade && !gamePaused) {
                isMapView = !isMapView;
                if (mapHintEl.style.display === 'block') {
                    mapHintEl.style.display = 'none';
                }
            } else if (!hasMapUpgrade && !gamePaused) {
                showObjectivePopup('Haritayı bulman gerek.');
            }
        });

        function handleResize() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            camera.width = canvas.width;
            camera.height = canvas.height;
        }

        window.addEventListener('resize', () => {
            if (!gamePaused) {
                handleResize();
            }
        });

        // Start the game
        function startGame(mode) {
            
            gameMode = mode;
            mainMenuEl.style.display = 'none';
            gameContainer.style.display = 'block';

            if (gameMode === 'easy') {
                moneyEl.parentElement.style.display = 'none';
            } else {
                moneyEl.parentElement.style.display = ''; // Reset to default from stylesheet
            }

            handleResize(); // Ensure canvas is sized correctly before starting
            restartGame();
            gameLoop();
        }

        easyModeButton.addEventListener('click', () => {
            easyModeConfirmModal.style.display = 'block';
        });
        normalModeButton.addEventListener('click', () => startGame('normal'));

        confirmEasyModeButton.addEventListener('click', () => {
            easyModeConfirmModal.style.display = 'none';
            startGame('easy');
        });

        cancelEasyModeButton.addEventListener('click', () => {
            easyModeConfirmModal.style.display = 'none';
        });

        const mainMenuFromGameOverButton = document.getElementById('mainMenuFromGameOverButton');
        const mainMenuFromPauseButton = document.getElementById('mainMenuFromPauseButton');

        mainMenuFromGameOverButton.addEventListener('click', returnToMainMenu);
        mainMenuFromPauseButton.addEventListener('click', returnToMainMenu);

        buyArmorUpgradeButton.addEventListener('click', () => {
            const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
            if (!currentVehicleUpgrades || currentVehicleUpgrades.maxArmor >= 5) return;
            const cost = ARMOR_UPGRADE_COSTS[currentVehicleUpgrades.maxArmor];
            if (totalMoney >= cost) {
                totalMoney -= cost;
                currentVehicleUpgrades.maxArmor++;
                saveTotalMoney();
                savePermanentUpgrades();
                updateMainMenuUI();
            }
        });

        buyShieldUpgradeButton.addEventListener('click', () => {
            const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
            if (!currentVehicleUpgrades || currentVehicleUpgrades.shieldDuration >= 5) return;
            const cost = SHIELD_UPGRADE_COSTS[currentVehicleUpgrades.shieldDuration];
            if (totalMoney >= cost) {
                totalMoney -= cost;
                currentVehicleUpgrades.shieldDuration++;
                saveTotalMoney();
                savePermanentUpgrades();
                updateMainMenuUI();
            }
        });

        buyDashUpgradeButton.addEventListener('click', () => {
            const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
            if (!currentVehicleUpgrades || currentVehicleUpgrades.dashDuration >= 5) return;
            const cost = DASH_UPGRADE_COSTS[currentVehicleUpgrades.dashDuration];
            if (totalMoney >= cost) {
                totalMoney -= cost;
                currentVehicleUpgrades.dashDuration++;
                saveTotalMoney();
                savePermanentUpgrades();
                updateMainMenuUI();
            }
        });

    buyAttackSpeedUpgradeButton.addEventListener('click', () => {
        const currentVehicleUpgrades = allVehicleUpgrades[selectedVehicle];
        if (!currentVehicleUpgrades || currentVehicleUpgrades.attackSpeed >= 5) return;
        const cost = ATTACK_SPEED_UPGRADE_COSTS[currentVehicleUpgrades.attackSpeed];
        if (totalMoney >= cost) {
            totalMoney -= cost;
            currentVehicleUpgrades.attackSpeed++;
            saveTotalMoney();
            savePermanentUpgrades();
            updateMainMenuUI();
        }
    });

    controlsButton.addEventListener('click', () => {
        controlsModal.style.display = 'block';
    });
    closeControlsButton.addEventListener('click', () => {
        controlsModal.style.display = 'none';
    });

    resetDataButton.addEventListener('click', () => {
        resetConfirmModal.style.display = 'block';
    });
    cancelResetButton.addEventListener('click', () => {
        resetConfirmModal.style.display = 'none';
    });
    confirmResetButton.addEventListener('click', () => {
        localStorage.clear();
        location.reload();
    });

    showVehiclesTab.addEventListener('click', () => {
        playSound('click');
        showVehiclesTab.classList.add('active');
        showUpgradesTab.classList.remove('active');
        vehiclesContent.classList.add('active');
        upgradesContent.classList.remove('active');
    });

    showUpgradesTab.addEventListener('click', () => {
        playSound('click');
        showUpgradesTab.classList.add('active');
        showVehiclesTab.classList.remove('active');
        upgradesContent.classList.add('active');
        vehiclesContent.classList.remove('active');
    });

    function setupMainMenuAudio() {
        mainMenuEl.addEventListener('mouseenter', (e) => {
            const button = e.target.closest('button, .vehicle-item, .weapon-list li, h3[data-achievement-id]');
            if (button && !button.disabled && !button.classList.contains('locked')) {
                playSound('hover');
            }
        }, true);

        mainMenuEl.addEventListener('click', (e) => {
            if (!isAudioInitialized) {
                initAudio();
            }
            const button = e.target.closest('button, .vehicle-item');
            if (button) {
                if (button.disabled || (button.classList.contains('locked') && !button.classList.contains('buyable'))) {
                     playSound('error');
                     return;
                }
                
                if (button.classList.contains('buy-upgrade-button') || button.classList.contains('buyable')) {
                     playSound('purchase');
                } else {
                     playSound('click');
                }
            }
        });
    }

    function setupWeaponTooltip() {
        const weaponsPanel = document.getElementById('weapons-panel');
        const weaponTooltip = document.getElementById('weaponTooltip');

        if (!weaponsPanel || !weaponTooltip) return;

        weaponsPanel.addEventListener('mouseover', (e) => {
            const li = e.target.closest('li[data-weapon-id]');
            const h3 = e.target.closest('h3[data-achievement-id]');

            let contentSet = false;
            let targetRect;

            if (li) {
                const weaponId = li.dataset.weaponId;
                const weaponData = WEAPONS[weaponId];
                if (!weaponData) return;

                if (li.classList.contains('locked')) {
                    weaponTooltip.innerHTML = `
                        <h4><span class="weapon-icon">?</span> ???</h4>
                        <p>Bu silahın bilgilerine ulaşmak için silaha sahip olmanız gerekiyor.</p>
                    `;
                } else {
                    let statsHTML = `<table class="weapon-stats-table"><tr><th>Seviye</th><th>İstatistikler</th></tr>`;
                    const maxLevel = weaponData.maxLevel || 10;
                    for (let i = 1; i <= maxLevel; i++) {
                        statsHTML += `<tr><td>${i}</td><td>${weaponData.getUpgradeText(i)}</td></tr>`;
                    }
                    statsHTML += `</table>`;

                    weaponTooltip.innerHTML = `
                        <h4>${weaponData.icon} ${weaponData.name}</h4>
                        <p>${weaponData.description}</p>
                        ${statsHTML}
                    `;
                }
                contentSet = true;
                targetRect = li.getBoundingClientRect();

            } else if (h3) {
                const achievementId = h3.dataset.achievementId;
                const achievementData = ACHIEVEMENT_SETS[achievementId];
                if (achievementData) {
                    if (!unlockedAchievements.includes(achievementId)) {
                        weaponTooltip.innerHTML = `
                            <h4>???</h4>
                            <p>Gizli bilgi</p>
                        `;
                    } else {
                        weaponTooltip.innerHTML = `
                            <h4>${achievementData.name} Bonusu</h4>
                            <p>${achievementData.description}</p>
                        `;
                    }
                    contentSet = true;
                    targetRect = h3.getBoundingClientRect();
                }
            }


            if (contentSet) {
                weaponTooltip.style.display = 'block';
                const panelRect = weaponsPanel.getBoundingClientRect();
                
                weaponTooltip.style.left = `${panelRect.right + 10}px`;
                
                const tooltipHeight = weaponTooltip.offsetHeight;
                const windowHeight = window.innerHeight;
                let topPos = targetRect.top;
                if (topPos + tooltipHeight > windowHeight) {
                    topPos = windowHeight - tooltipHeight - 10;
                }
                weaponTooltip.style.top = `${topPos}px`;
            }
        });

        weaponsPanel.addEventListener('mouseleave', () => {
            weaponTooltip.style.display = 'none';
        });
    }

    function setupPauseMenuTooltip() {
        const pauseMenuContainer = document.getElementById('pause-panels-container');
        const pauseMenuEl = document.getElementById('pauseMenu');
        const weaponTooltip = document.getElementById('weaponTooltip');

        if (!pauseMenuContainer || !weaponTooltip || !pauseMenuEl) return;

        pauseMenuContainer.addEventListener('mouseover', (e) => {
            const li = e.target.closest('li[data-weapon-id]');
            const h3 = e.target.closest('h3[data-achievement-id]');

            let contentSet = false;
            let targetRect;

            if (li) {
                const weaponId = li.dataset.weaponId;
                const weaponData = WEAPONS[weaponId];
                if (!weaponData) return;

                if (li.classList.contains('locked')) {
                    weaponTooltip.innerHTML = `
                        <h4><span class="weapon-icon">?</span> ???</h4>
                        <p>Bu silahın bilgilerine ulaşmak için silaha sahip olmanız gerekiyor.</p>
                    `;
                } else {
                    let statsHTML = `<table class="weapon-stats-table"><tr><th>Seviye</th><th>İstatistikler</th></tr>`;
                    const maxLevel = weaponData.maxLevel || 10;
                    for (let i = 1; i <= maxLevel; i++) {
                        statsHTML += `<tr><td>${i}</td><td>${weaponData.getUpgradeText(i)}</td></tr>`;
                    }
                    statsHTML += `</table>`;

                    weaponTooltip.innerHTML = `
                        <h4>${weaponData.icon} ${weaponData.name}</h4>
                        <p>${weaponData.description}</p>
                        ${statsHTML}
                    `;
                }
                contentSet = true;
                targetRect = li.getBoundingClientRect();

            } else if (h3) {
                const achievementId = h3.dataset.achievementId;
                const achievementData = ACHIEVEMENT_SETS[achievementId];
                if (achievementData) {
                    if (h3.classList.contains('locked')) {
                        weaponTooltip.innerHTML = `
                            <h4>???</h4>
                            <p>Gizli bilgi</p>
                        `;
                    } else {
                        weaponTooltip.innerHTML = `
                            <h4>${achievementData.name} Bonusu</h4>
                            <p>${achievementData.description}</p>
                        `;
                    }
                    contentSet = true;
                    targetRect = h3.getBoundingClientRect();
                }
            }

            if (contentSet) {
                weaponTooltip.style.display = 'block';
                const pauseMenuRect = pauseMenuEl.getBoundingClientRect();
                
                // Tooltip'i duraklatma menüsünün sağına konumlandır
                weaponTooltip.style.left = `${pauseMenuRect.right + 10}px`;
                
                const tooltipHeight = weaponTooltip.offsetHeight;
                const windowHeight = window.innerHeight;
                let topPos = targetRect.top;

                // Tooltip'in ekranın altından taşmamasını sağla
                if (topPos + tooltipHeight > windowHeight) {
                    topPos = windowHeight - tooltipHeight - 10;
                }
                // Tooltip'in ekranın üstünden taşmamasını sağla
                if (topPos < 10) {
                    topPos = 10;
                }
                weaponTooltip.style.top = `${topPos}px`;
            }
        });

        pauseMenuContainer.addEventListener('mouseleave', () => {
            weaponTooltip.style.display = 'none';
        });
    }

    function updatePauseMenuWeaponsUI() {
        // Update achievement group titles
        const achievementTitles = document.querySelectorAll('#pauseMenu h3[data-achievement-id]');
        achievementTitles.forEach(h3 => {
            const achievementId = h3.dataset.achievementId;
            const achievementData = ACHIEVEMENT_SETS[achievementId];
            if (!achievementData) return;

            if (unlockedAchievements.includes(achievementId)) {
                h3.textContent = achievementData.name;
                h3.classList.remove('locked');
            } else {
                h3.textContent = '???';
                h3.classList.add('locked');
            }
        });

        // Update individual weapon visibility
        const weaponListItems = document.querySelectorAll('#pauseMenu .weapon-list li');
        weaponListItems.forEach(li => {
            const weaponId = li.dataset.weaponId;
            const weapon = WEAPONS[weaponId];
            if (!weapon) return;

            if (!discoveredWeapons.includes(weaponId)) {
                li.classList.add('locked');
                li.innerHTML = `<span class="weapon-icon">?</span> ???`;
            } else {
                li.classList.remove('locked');
                li.innerHTML = `<span class="weapon-icon">${weapon.icon}</span> ${weapon.name}`;
            }
        });
    }
    
    loadPermanentUpgrades();
    loadUnlockedVehicles();
    loadTotalMoney();
    loadDiscoveredWeapons();
    loadUnlockedAchievements();
    updateMainMenuUI(); // Make sure UI is up-to-date on load
    setupMainMenuAudio();
    setupWeaponTooltip();
    setupPauseMenuTooltip();
    
    handleResize();
    </script>
</body>
</html>
